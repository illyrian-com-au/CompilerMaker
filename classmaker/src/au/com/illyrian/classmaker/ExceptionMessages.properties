# Copyright (c) 2010, Donald Strong.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are those
# of the authors and should not be interpreted as representing official policies,
# either expressed or implied, of the FreeBSD Project.

ClassMaker.MustBeInMethod=Must be in a method
ClassMaker.MethodDeclaredMoreThanOnce_1=Method has been declared more than once: ${0}
ClassMaker.CannotDefineClassAfterFirstPhase=Cannot define a class after the first phase of a two phase generation
ClassMaker.ClassNameEndMaker_1=Class name must end with "Maker": ${0}
ClassMaker.CannotSetSourceFilename=Cannot set source filename because it is provided by the LineNumber interface
# ClassMaker.CouldNotDetermineSignatureForClass=Could not determine signature for Class
ClassMaker.MustUseFullyQualifiedClassName_1='${0}' is ambiguous; must use the fully qualified class name
ClassMaker.CannotLoadClass_1=Cannot load class: ${0}
ClassMaker.ReturnOrThrowMustPrecedeEnd=A call to Return or Throw must precede End()
ClassMaker.TypeIsNotAClass_1=Type ${0} is not a class
ClassMaker.StaticAccessToNonStaticField_1=Static access to non static field: ${0}
ClassMaker.StaticCallToNonStaticMethod_2=Static call to non static method: ${0} in class ${1}
ClassMaker.CannotResolveMethodCall_1=Cannot resolve method call : ${0}
ClassMaker.NoMethodCalled_1=Class contains no method called \'${0}\'
ClassMaker.NoClassTypeCalled_1=No class type called \'${0}\'
ClassMaker.NoTypeCalled_1=No type called \'${0}\'
ClassMaker.NotAClass_1=${0} is not a class
ClassMaker.CannotThrowType_1=Cannot throw type ${0}
ClassMaker.ClassCannotBeThrown_1=Class ${0} cannot be thrown
ClassMaker.ReturnWhileNotInAMethod=Return while not in a method
ClassMaker.MethodMustReturnType_2=Method ${0} must return type ${1}
ClassMaker.MethodIsVoidSoMustNotReturnAValue_1=Method ${0} returns void so must not return a value
ClassMaker.MethodReturnsTypeSoCannotReturnType_3=Method ${0} returns type ${1} so cannot return a value of type ${2}
ClassMaker.CannotReturnTypeVoid=Cannot return type void
ClassMaker.CannotDeclareType_1=Cannot declare a variable of type ${0}
ClassMaker.DontKnowHowToStoreType_1=Don't know how to store type: ${0}
ClassMaker.DontKnowHowToLoadType_1=Don't know how to load type: ${0}
ClassMaker.NoLocalCalled_1=No local variable called \'${0}\'
ClassMaker.CannotFindMemberFieldInClass_2=Cannot find member field \'${0}\' in class ${1}
ClassMaker.CannotFindStaticFieldInClass_2=Cannot find static field \'${0}\' in class ${1}
ClassMaker.CannotConvertFromTo_2=Cannot convert from ${0} to ${1}
ClassMaker.CannotCastFromTypeToType_2=Cannot cast from type ${0} to type ${1}
ClassMaker.CannotAssignToLocalVariableOfType_3=Cannot assign type ${0} to local variable \'${1}\' of type ${2}
ClassMaker.CannotAddType_2=Cannot add type ${0} to type ${1}
ClassMaker.CannotSubtractType_2=Cannot subtract type ${1} from type ${0}
ClassMaker.CannotMultiplyType_2=Cannot multiply type ${0} by type ${1}
ClassMaker.CannotDivideType_2=Cannot divide type ${0} by type ${1}
ClassMaker.CannotRemainderType_2=Cannot remainder type ${0} by type ${1}
ClassMaker.CannotOrType_2=Cannot Or type ${0} with type ${1}
ClassMaker.CannotAndType_2=Cannot And type ${0} with type ${1}
ClassMaker.CannotXorType_2=Cannot Xor type ${0} with type ${1}
ClassMaker.CannotNegType_1=Cannot Negate type ${0}
ClassMaker.CannotInvertType_1=Cannot Invert type ${0}
ClassMaker.CannotShiftLeftType_1=Cannot shift left type: ${0}
ClassMaker.CannotShiftRightType_1=Cannot shift right type: ${0}
ClassMaker.CannotUnsignedShiftRightType_1=Cannot unsigned shift right type: ${0}
ClassMaker.CannotGTTypes_2=Cannot GT(${0}, ${1})
ClassMaker.CannotGETypes_2=Cannot GE(${0}, ${1})
ClassMaker.CannotLETypes_2=Cannot LE(${0}, ${1})
ClassMaker.CannotLTTypes_2=Cannot LT(${0}, ${1})
ClassMaker.CannotEQTypes_2=Cannot EQ(${0}, ${1})
ClassMaker.CannotNETypes_2=Cannot NE(${0}, ${1})
ClassMaker.CannotNotType_1=Cannot Not type ${0}
ClassMaker.ShiftOperandMustBeIntegerTypeNot_1=Shift operand must be type int, short, byte or char; not ${0}
ClassMaker.MustBeIntegerTypeNot_2=${0} must be type int, short, byte or char; not ${1}
ClassMaker.MustBeAnArrayTypeNot_2=${0} must be an Array type, not ${1}
ClassMaker.NotATypeOfArray_1=${0} is not a type of array
ClassMaker.ArrayExpectedOnStack_1=Expected an array but was type ${0}
ClassMaker.ArrayIndexMustBeIntegerType_1=Array index must be must be type int, short, byte or char, not ${0}
ClassMaker.CannotCreateAnArrayOfType_1=Cannot create an array of type ${0}
ClassMaker.ArrayOfTypeCannotBeAssigned_2=An array of type ${0} cannot be assigned ${1}
#ClassMaker.ClassExpectedOnStack_1=Expected a class but was type ${0}
ClassMaker.FieldOfTypeCannotBeAssignedType_3=Field ${0} of type ${1} cannot be assigned type ${2}
ClassMaker.TypeMustBeAClass_1=Expected a class but was type ${0}
ClassMaker.ClassVariableIsNotStatic_1=Class variable \'${0}\' is not static
ClassMaker.StaticFieldOfTypeCannotBeAssignedType_3=Static field \'${0}\' of type ${1} cannot be assigned type ${2}
ClassMaker.CannotIncrementVariableOfType_2=Cannot increment variable \'${0}\' of type ${1}
ClassMaker.CannotIncrementFieldOfType_2=Cannot increment field \'${0}\' of type ${1}
ClassMaker.CannotIncrementArrayElementOfType_1=Cannot increment array element of type ${0}
ClassMaker.CannotDecrementVariableOfType_2=Cannot decrement variable \'${0}\' of type ${1}
ClassMaker.CannotDecrementFieldOfType_2=Cannot decrement field \'${0}\' of type ${1}
ClassMaker.CannotDecrementArrayElementOfType_1=Cannot decrement array element of type ${0}
ClassMaker.AbstractMethodsInConcreteClass_1=Abstract methods in a concrete class: ${0}
ClassMaker.ConcreteMethodsInInterface_1=Concrete methods in an interface: ${0}
ClassMaker.UnimplementedInterfaceMethods_1=Class does not implement all methods in interface: ${0}
ClassMaker.NotInMethod=Begin called when not in a method
ClassMaker.AbstractMethodCannotHaveBody_1=Abstract method cannot have a body. Use Forward() instead of ${0}
ClassMaker.DuplicateMemberFieldDeclaration_1=Duplicate member field declaration: ${0}
ClassMaker.DuplicateLocalVariableDeclaration_1=Duplicate local variable or parameter declaration: ${0}
# Access Modifiers
ClassMaker.InvalidModifier_1=Invalid modifier: ${0}
ClassMaker.InvalidClassModifier_1=Invalid class modifier: ${0}
ClassMaker.InvalidClassModifierCombination=Incompatible class modifier combination: abstract with final
ClassMaker.InvalidMethodModifier_1=Invalid method modifier: ${0}
ClassMaker.InvalidMethodModifierCombination_1=Incompatible method modifier combination: abstract with ${0}
ClassMaker.MultipleAccessModifiers_1=Cannot have more than one access modifier: ${0}
ClassMaker.InvalidFieldModifier_1=Invalid field modifier: ${0}
ClassMaker.InvalidFieldModifierCombination=Incompatible field modifier combination: final with volatile
ClassMaker.AccessDeniedToClass_1=Access Denied: class ${0} is not visible
ClassMaker.AccessDeniedToField_2=Access Denied: field ${0}.${1} is not visible
ClassMaker.AccessDeniedToProtectedField_2=Access Denied: field ${0}.${1} is protected so the type of the class being accessed must be the same or a subclass of the current class
ClassMaker.AccessDeniedToMethod_2=Access Denied: method ${1} in class ${0} is not visible
ClassMaker.AccessDeniedToProtectedMethod_2=Access Denied: method ${1} in class ${0} is protected so the type of the class being accessed must be the same or a subclass of the current class
ClassMaker.DuplicateModifier_1=Duplicate modifier: ${0}
# Configuration to late
ClassMaker.ToLateToSetClassType=To late to set the class type. Call method setClassType earlier.
ClassMaker.ToLateToExtendTheClass=To late to Extend the class. Call method Extend earlier.
ClassMaker.ToLateToNameTheClass=To late to name the class. Call method setSimpleClassName earlier.
ClassMaker.ToLateToNameThePackage=To late to name the package. Call method setPackageName earlier.
ClassMaker.ToLateToNameTheFullyQualifiedClass=To late to name the fully qualified class. Call method setFullQualifiedClassName earlier.
ClassMaker.ToLateToNameTheSourceFilename=To late to set the source file name. Call method setSourceFilename earlier.
ClassMaker.ToLateToSetFactory=To late to set the shared factory. Call method setFactory earlier.
ClassMaker.CannotExtendInterface=Cannot extend an interface: ${0}
ClassMaker.CannotImplementClass=Class is not an interface: ${0}
# Begin End Scope Statement
ClassMaker.EndWithoutMatchingBegin=End without a matching Begin
ClassMaker.CannotSetLabelOnMethodBlock=Cannot set a label on the Begin at the start of a method
# If statement
ClassMaker.IfConditionMustBeBoolean_1=If condition must be type boolean, not ${0}
ClassMaker.ElseCalledTwice=Else called twice
ClassMaker.EndIfWithoutMatchingIf=EndIf without a matching If
ClassMaker.ElseWithoutMatchingIf=Else without a matching If
# Loop statement
ClassMaker.LoopDoesNotContainBreak=Loop does not contain a Break
ClassMaker.WhileConditionMustBeTypeBooleanNot_1=While condition must be type boolean, not ${0}
ClassMaker.EndLoopWithoutMatchingLoop=EndLoop without a matching Loop
ClassMaker.WhileMustBeWithinLoop=While must be within a Loop
# For statement
ClassMaker.ForDoesNotContainBreak=For does not contain a Break
ClassMaker.EndForWithoutMatchingFor=EndFor without a matching For
ClassMaker.BreakWhileNotInLoopOrSwitch=Break while not in a Loop or Switch statement
ClassMaker.CouldNotFindTargetLabelForBreak_1=Could not find target label for Break statement: ${0}
ClassMaker.ContinueWhileNotInLoop=Continue while not in a Loop
# Switch Statement
ClassMaker.MoreThanOneDefaultInSwitch=More than one Default in Switch statement
ClassMaker.SwitchTypeMustBeNumberNot_1=Switch type must be int, char, short or byte but was ${0}
ClassMaker.DuplicateCaseKey_1=Duplicate Case key in Switch statement: ${0}
ClassMaker.CaseWhileNotInSwitch=Case while not in a Switch statement
ClassMaker.DefaultWhileNotInSwitch=Default while not in a Switch statement
ClassMaker.NoCaseClauseInSwitch=No Case clause in Switch statement
ClassMaker.EndSwitchWhileNotInSwitch=EndSwitch while not in a Switch statement
# Try statement
ClassMaker.CatchWithoutTry=Catch without Try block
ClassMaker.FinallyWithoutTry=Finally without Try block
ClassMaker.EndTryWithoutTry=EndTry without Try block
# Shortcut boolean logic
ClassMaker.LogicConditionMustBeBoolean_1=Condition for Logic must be type boolean, not ${0}
ClassMaker.AndThenConditionMustBeBoolean_1=Condition for AndThen must be type boolean, not ${0}
ClassMaker.OrElseConditionMustBeBoolean_1=Condition for OrElse must be type boolean, not ${0}
# Other
ClassMaker.OutputFolderDoesNotExist_1=Output folder does not exist: ${0}

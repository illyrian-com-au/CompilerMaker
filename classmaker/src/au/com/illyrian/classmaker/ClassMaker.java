// Copyright (c) 2010, Donald Strong.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// The views and conclusions contained in the software and documentation are those
// of the authors and should not be interpreted as representing official policies,
// either expressed or implied, of the FreeBSD Project.

package au.com.illyrian.classmaker;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.mozilla.classfile.ByteCode;
import org.mozilla.classfile.ClassFileWriter;

import au.com.illyrian.classmaker.members.MakerField;
import au.com.illyrian.classmaker.members.MakerMethod;
import au.com.illyrian.classmaker.types.ArrayType;
import au.com.illyrian.classmaker.types.ClassType;
import au.com.illyrian.classmaker.types.DeclaredType;
import au.com.illyrian.classmaker.types.DeclaredTypeMaker;
import au.com.illyrian.classmaker.types.PrimitiveType;
import au.com.illyrian.classmaker.types.Type;

/**
 * A ClassMaker instance is used to generate a class suitable to be loaded into
 * a Java Virtual Machine (JVM).
 * The generated byte code may be loaded directly from the ClassMaker instance
 * or it may be saved to a class file.
 * <br/>
 * The ClassMaker API allows fields and methods to be created in a manner similar to
 * writing java source code. The API supports the following features:
  <UL>
    <LI> methods and parameters</LI>
    <LI> expressions including numeric promotion and assignment conversion</LI>
    <LI> local, class and static fields</LI>
    <LI> loops with break and continue statements</LI>
    <LI> breaking to labelled statements</LI>
    <LI> for loop statements</LI>
    <LI> if-then-else statements</LI>
    <LI> switch statements with both contiguous and non-contiguous keys</LI>
    <LI> method calls including resolving methods and parameter conversion</LI>
    <LI> string concatenation including conversion between String and StringBuffer</LI>
    <LI> try-catch-finally blocks</LI>
    <LI> forward declaration or, alternatively, two pass generation.</LI>
    <LI> debugger support</LI>
    <LI> integration with ordinary java classes.</LI>
  </UL>
  
  Byte code is generated as a side effect of calling methods in the ClassMaker instance.
  <p/>
  The following non-trivial example show the java code to create a class that implements
  a factorial algorithm and the equivalent ClassMaker code to generate the same class.
  The <code>Unary</code> interface is shared between both implementations.
  <p/>
  <table width="100%" border="1">
  <tr>
    <td width="50%" >
  Java code
    </td>
    <td>
  ClassMaker code
    </td>
  </tr>
  <tr>
    <td>
      <pre>
    public interface Unary
    {
        int unary(int a);
    }

    public class Factorial
        implements Unary
    {
        public int unary(int n)
        {
            int x;
            x= 1;
            while (n>0)
            {
                x = x * n;
                n--;
            }
            return x;
        }
    }
      </pre>
    </td>
    <td>
      <pre>
    	ClassMakerFactory factory = new ClassMakerFactory();
        ClassMaker maker = factory.createClassMaker();

        maker.setModifiers(ClassMaker.ACC_PUBLIC);
        maker.setClassName("Factorial");
        maker.Implements(Unary.class);

        maker.Method("unary", int.class, ClassMaker.ACC_PUBLIC);
        maker.Declare("n", int.class, 0);
        maker.Begin();
	        maker.Declare("x", int.class, 0);
	        maker.Eval(maker.Set("x", maker.Literal(1)));
	        maker.Loop();
		        maker.While(maker.GT(maker.Get("n"), maker.Literal(0)));
		        maker.Eval(maker.Set("x", maker.Mult(maker.Get("x"), maker.Get("n"))));
		        maker.Eval(maker.Dec("n"));
	        maker.EndLoop();
	        maker.Return(maker.Get("x"));
        maker.End();
        
        Class myClass = maker.defineClass();
        Unary exec = (Unary)myClass.newInstance();
      </pre>
    </td>
  </tr>
</table>
 *
 * @author Donald Strong
 */
public class ClassMaker implements ClassMakerIfc
{
    private static final Logger log = Logger.getLogger(ClassMaker.class.getName());
    
	/** Bitmask for <code>public</code> access modifier */
    public static final short ACC_PUBLIC       = 0x0001;
	/** Bitmask for <code>private</code> access modifier */
    public static final short ACC_PRIVATE      = 0x0002;
	/** Bitmask for <code>protected</code> access modifier */
    public static final short ACC_PROTECTED    = 0x0004;
	/** Bitmask for <code>static</code> access modifier */
    public static final short ACC_STATIC       = 0x0008;
	/** Bitmask for <code>final</code> class and field modifier */
    public static final short ACC_FINAL        = 0x0010;
	/** Bitmask for <code>synchronized</code> method modifier */
    public static final short ACC_SYNCHRONIZED = 0x0020;
	/** Bitmask for <code>volatile</code> field modifier */
    public static final short ACC_VOLATILE     = 0x0040;
	/** Bitmask for <code>transient</code> field modifier */
    public static final short ACC_TRANSIENT    = 0x0080;
	/** Bitmask for <code>native</code> method modifier */
    public static final short ACC_NATIVE       = 0x0100;
	/** Bitmask for <code>interface</code> class modifier */
    public static final short ACC_INTERFACE    = 0x0200;
	/** Bitmask for <code>abstract</code> class and method modifier */
    public static final short ACC_ABSTRACT     = 0x0400;
	/** Bitmask for strict floating point class modifier */
    public static final short ACC_STRICTFP     = 0x0800;
    /** Bitmask to test for package visibility. Alias for zero (0). */
    public static final short ACC_PACKAGE      = 0;

    /* Bitmask for class modifier to indicate that the class follows java 1.3+ (?) semantics for method invocation. */
    private static final short MASK_SUPER       = 0x0002;
    /** Bitmask of valid access modifiers */
    public static final int MASK_ACCESS = ACC_PUBLIC | ACC_PROTECTED | ACC_PRIVATE;
    /** Bitmask of valid class modifiers */
    public static final int MASK_CLASS = MASK_ACCESS | ACC_ABSTRACT | ACC_FINAL | ACC_STRICTFP;
    /** Bitmask of valid interface modifiers */
    public static final int MASK_INTERFACE = ACC_PUBLIC | ACC_ABSTRACT | ACC_INTERFACE;
    /** Bitmask of valid field modifiers */
    public static final int MASK_FIELD = MASK_ACCESS | ACC_STATIC | ACC_FINAL | ACC_TRANSIENT | ACC_VOLATILE;
    /** Bitmask of valid method modifiers */
    public static final int MASK_METHOD = MASK_ACCESS | ACC_STATIC | ACC_FINAL | ACC_ABSTRACT | ACC_SYNCHRONIZED| ACC_NATIVE | ACC_STRICTFP;
    /** Bitmask of method modifiers that are incompatable with the <code>abstract</code> modifier. */
    public static final int MASK_INCOMPATABLE_WITH_ABSTRACT_METHOD = ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED| ACC_NATIVE | ACC_STRICTFP;

    /** Reference to <code>null</code> type */
    public static ClassType NULL_TYPE = new ClassType("null", (ClassType)null);
    /** Reference to <code>Object</code> type */
    public static final ClassType OBJECT_TYPE = new ClassType(Object.class);
    /** Reference to a special automatically created StringBuffer.
     *  An automatically created StringBuffer results from concatenating
     *  a String with any value or object.
     */
    public static final ClassType AUTO_STRING_TYPE = new ClassType(StringBuffer.class);
    /** Reference to <code>String</code> type */
    public static final ClassType STRING_TYPE = new ClassType(String.class);
    /** Reference to <code>StringBuffer</code> type */
    public static final ClassType STRING_BUFFER_TYPE = new ClassType(StringBuffer.class);
    /** Reference to <code>Cloneable</code> type */
    public static final ClassType CLONEABLE_TYPE = new ClassType(Cloneable.class);
    /** Reference to <code>Throwable</code> type */
    public static final ClassType THROWABLE_TYPE = new ClassType(Throwable.class);
    /** Reference to <code>Class</code> type */
    public static final ClassType CLASS_TYPE = new ClassType(Class.class);
    /** Reference to <code>void</code> type */
    public static final PrimitiveType VOID_TYPE = new PrimitiveType(PrimitiveType.VOID_INDEX, "void", "V", void.class);
    /** Reference to <code>byte</code> type */
    public static final PrimitiveType BYTE_TYPE = new PrimitiveType(PrimitiveType.BYTE_INDEX, "byte", "B", byte.class);
    /** Reference to <code>char</code> type */
    public static final PrimitiveType CHAR_TYPE = new PrimitiveType(PrimitiveType.CHAR_INDEX, "char", "C", char.class);
    /** Reference to <code>double</code> type */
    public static final PrimitiveType DOUBLE_TYPE = new PrimitiveType(PrimitiveType.DOUBLE_INDEX, "double", "D", double.class);
    /** Reference to <code>float</code> type */
    public static final PrimitiveType FLOAT_TYPE = new PrimitiveType(PrimitiveType.FLOAT_INDEX, "float", "F", float.class);
    /** Reference to <code>int</code> type */
    public static final PrimitiveType INT_TYPE = new PrimitiveType(PrimitiveType.INT_INDEX, "int", "I", int.class);
    /** Reference to <code>long</code> type */
    public static final PrimitiveType LONG_TYPE = new PrimitiveType(PrimitiveType.LONG_INDEX, "long", "J", long.class);
    /** Reference to <code>short</code> type */
    public static final PrimitiveType SHORT_TYPE = new PrimitiveType(PrimitiveType.SHORT_INDEX, "short", "S", short.class);
    /** Reference to <code>boolean</code> type */
    public static final PrimitiveType BOOLEAN_TYPE = new PrimitiveType(PrimitiveType.BOOLEAN_INDEX, "boolean", "Z", boolean.class);
    
    /** Enumeration to indicate that byte-code will be generated in one pass (default). */
    public static final int ONE_PASS = 0;
    /** Enumeration to indicate that this is the first pass of two pass byte-code generation. */
    public static final int FIRST_PASS = 1;
    /** Enumeration to indicate that this is the second pass of two pass byte-code generation. */
    public static final int SECOND_PASS = 2;
    /** Enumeration to indicate that byte-code generation is complete. */
    public static final int COMPLETED_PASS = -1;

    /** Constant for the <code>Return</code> jump target used by <code>Statement.jumpToTarget</code> */
    public static final String RETURN = "return";
    /** Constant for the <code>Break</code> jump target used by <code>Statement.jumpToTarget</code> */
    public static final String BREAK = "break";
    /** Constant for the <code>Continue</code> jump target used by <code>Statement.jumpToTarget</code> */
    public static final String CONTINUE = "continue";

    /** An empty call stack that may be used to call methods with no parameters */
    private final CallStackMaker EMPTY_CALL_STACK = new CallStackMaker(this);
    /** Constant for the name of a constructor method */
    public static final String INIT = "<init>";

    // Fields - internal references
    /** A list of constructors in the class being generated. */
    private Vector<MakerMethod>     constructors = new Vector<MakerMethod>();
    /** A list of methods in the class being generated. */
    private Vector<MakerMethod>     methods    = new Vector<MakerMethod>();
    /** A list of interfaces implemented by the class being generated. */
    private Vector<DeclaredType>    interfaces = new Vector<DeclaredType>();
    /** A list of member fields in the class being generated. */
    private Vector<MakerField>      fieldTable = new Vector<MakerField>();
    /** A list of local variables in the class being generated. */
    private Vector<MakerField>      localTable = new Vector<MakerField>();
    /** Short class names are mapped to class types as they are imported into the class being generated. */
//    private HashMap<String, ClassType> aliasMap = new HashMap<String, ClassType>();
    private HashMap<String, DeclaredType> aliasMap = new HashMap<String, DeclaredType>();
    /** A reference to the method currently being generated. */
    private MakerMethod method = null;
    /** Has the class  declared a constructor. */
    private boolean hasConstructor = false;
    /** Indicates that the previous statement was a call to Return(). */
    private boolean followsReturn = false;
    /** Get the maximum local slots used by this method. */
    private short maxLocalSlots = 0;

    /** The current phase of a two pass class generation */
    //private int generationPass = ONE_PASS;
    /** The fully qualified name of the package */
    private String packageName = null;
    /** The simple name of the class */
    private String simpleClassName;
    /** The fully qualified name of the class */
    private String fullyQualifiedClassName;
    /** A reference to the type information for the class being generated. */
    private ClassType thisClassType;
    /** A reference to the type declaration for the class being generated. */
    private DeclaredTypeMaker thisDeclaredType;
    /** A reference to the type declaration for the super class of the class being generated. */
    private DeclaredType superClass;
    /** The modifiers for the class being generated. */
    private int classModifiers = ACC_PUBLIC;

    // Fields - external references
    /* The ClassFileWriter instance that is used to generate byte-code for the class. */
    private ClassFileWriter cfw;
    /* A ClassMakerFactory instance that may be shared with other instances of ClassMaker. */
    private final ClassMakerFactory factory;
    
    /** The name of the source file relative to the source path */
    private int previousLineNumber = 0;
    private SourceLine sourceLine;
    private LocalSourceLine localSourceLine;
    
    public String toString()
    {
        StringBuffer buf = new StringBuffer();
        buf.append("ClassMaker(");
        if (fullyQualifiedClassName != null) {
            buf.append(fullyQualifiedClassName).append(' ');
        } else {
            if (packageName != null)
                buf.append(packageName).append('.');
            if (simpleClassName != null)
                buf.append(simpleClassName).append(' ');
            else
                buf.append("? ");
        }
        if (superClass != null)
            buf.append("extends ").append(superClass.getName());
        if (factory != null) {
            switch (getPass()) {
            case ONE_PASS: buf.append(", ONE_PASS"); break;
            case FIRST_PASS: buf.append(", FIRST_PASS"); break;
            case SECOND_PASS: buf.append(", SECOND_PASS"); break;
            case COMPLETED_PASS: buf.append(", COMPLETED_PASS"); break;
            }
        }
        if (sourceLine != null)
            buf.append(", ").append(sourceLine.getFilename()).append(":").append(sourceLine.getLineNumber());
        buf.append(')');
        return buf.toString();
    }
    
    //#################### Constructors #################

    /**
     * Creates a <code>ClassMaker</code> instance for generating the named class.
     * The <code>ClassMakerFactory</code> provides shared services for all instances of <code>ClassMaker</code>.
     * </br>
     * @param globalFactory the <code>ClassMakerFactory</code> instance that is used by all class generators
     * @param className the name of the class to be generated
     * @param extendsClass the class that the generated class will extend
     * @param sourceFile an optional source file name
     */
    protected ClassMaker(ClassMakerFactory globalFactory, String packageName, String simpleName, String sourceFile)
    {
        factory = globalFactory;
        setPackageName(packageName);
        setSimpleClassName(simpleName);
        setSourceFilename(sourceFile);
        getDeclaredType();
    }

    /**
     * Creates a <code>ClassMaker</code> instance given a <code>ClassMakerFactory</code>.
     * The <code>ClassMakerFactory</code> provides shared services for all instances of <code>ClassMaker</code>.
     * @param globalFactory the <code>ClassMakerFactory</code> instance that is used by all class generators
     */
    protected ClassMaker(ClassMakerFactory globalFactory)
    {
        factory = globalFactory;
    }

    /**
     * Creates a <code>ClassMaker</code> instance given a <code>ClassMakerFactory</code> and <code>LineNumber</code>.
     * The <code>ClassMakerFactory</code> provides shared services for all instances of <code>ClassMaker</code>.
     * The <code>LineNumber</code> interface provides the source file name and current line number for
     * debugging and error messages.
     * Don't call <code>setSourceFilename</code> if you use this constructor.
     * @param globalFactory the <code>ClassMakerFactory</code> instance that is used by all class generators
     * @param sourceLine returns the current source file and line number for errors and debugging.
     */
    protected ClassMaker(ClassMakerFactory globalFactory, SourceLine sourceLine)
    {
        factory = globalFactory;
        this.sourceLine = sourceLine;
        localSourceLine = null;
    }

    // Required properties

    /**
     * Provides a default name for the package.
     * </br>
     * The default is to have no package name, but this method may be overridden.
     * @return the name of the package
     */
    protected String defaultPackageName()
    {
        return "";
    }

    /**
     * Sets the package name of the class being generated.
     * @param fullyQualifiedClassName the fully qualified name of the class
     * @throws ClassMakerException if it is too late to call this method
     */
    public void setPackageName(String packageName) throws ClassMakerException
    {
        if (cfw != null)
            throw createException("ClassMaker.ToLateToNameThePackage");
        this.packageName = packageName;
    }

    /**
     * The package name of the class being generated.
     * </br>
     * Returns the default package name if one has not been set explicitly.
     * @see #defaultPackageName()
     * @return the name of the class
     */
    public String getPackageName()
    {
        if (packageName == null)
            setPackageName(defaultPackageName());
        return packageName;
    }

    /**
     * Provides a default simple name for the class being generated.
     * </br>
     * Derives a simple name from the name of the ClassMaker class.
     * The default name will be the name of the Maker class with '<code>_$</code>' appended.
     * This method may be overridden to provide another default.
     * @return the name of the generated class
     */
    protected String defaultSimpleClassName()
    {
        return getClass().getSimpleName() + "_$" + getFactory().incAnonomousClass();
    }

    /**
     * Sets the simple name of the class being generated.
     * @param className the fully qualified name of the class
     * @throws ClassMakerException if it is too late to call this method
     */
    public void setSimpleClassName(String className) throws ClassMakerException
    {
        if (cfw != null)
            throw createException("ClassMaker.ToLateToNameTheClass");
        this.simpleClassName = className;
    }

    /**
     * The fully qualified name of the generated class.
     * </br>
     * Generates a class name if one has not been set explicitly.
     * @see #defaultFullyQualifiedClassName()
     * @return the name of the class
     */
    public String getSimpleClassName()
    {
        if (simpleClassName == null)
            setSimpleClassName(defaultSimpleClassName());
        return simpleClassName;
    }

    /**
     * Provides a name for the generated class from the name of the ClassMaker class.
     * </br>
     * The default name will be the name of the Maker class with '<code>_$</code>' appended.
     * @return the name of the generated class
     */
    protected String defaultFullyQualifiedClassName()
    {
        String packageName = getPackageName();
        String simpleClassName = getSimpleClassName();
        return (packageName == null || "".equals(packageName)) 
                ? simpleClassName : packageName + "." + simpleClassName;
    }

    /**
     * Sets the name of the class being generated.
     * @param className the fully qualified name of the class
     * @throws ClassMakerException if it is too late to call this method
     */
    public void setFullyQualifiedClassName(String className) throws ClassMakerException
    {
        if (cfw != null)
            throw createException("ClassMaker.ToLateToNameTheFullyQualifiedClass");
        this.fullyQualifiedClassName = className;
        getDeclaredType();
    }

    /**
     * The fully qualified name of the generated class.
     * </br>
     * Generates a class name if one has not been set explicitly.
     * @see #defaultFullyQualifiedClassName()
     * @return the name of the class
     */
    public String getFullyQualifiedClassName()
    {
        if (fullyQualifiedClassName == null)
            setFullyQualifiedClassName(defaultFullyQualifiedClassName());
        return fullyQualifiedClassName;
    }

    /**
     * Generates a default source file name based on the class name.
     * @return the name of the source file relative to the source path
     */
    protected String defaultSourceFilename()
    {
        return ClassMaker.toSlashName(getFullyQualifiedClassName()) + ".java";
    }

    /**
     * Sets the name of the source file relative to the source path
     * @param filename the path to the source file
     * @throws ClassMakerException if it is too late to call this method
     */
    public void setSourceFilename(String filename) throws ClassMakerException
    {
        if (cfw != null)
            throw createException("ClassMaker.ToLateToNameTheSourceFilename");
        if (sourceLine != null)
            throw createException("ClassMaker.CannotSetSourceFilename");
        localSourceLine = new LocalSourceLine();
        localSourceLine.setFilename(filename);
        sourceLine = localSourceLine;
    }

    /** The signature of the generated class. */
    public String getClassSignature()
    {
        return getClassType().getSignature();
    }

    /**
     * Creates a default ClassType for the generated class.
     * @return the ClassType of the generated class
     */
    protected ClassType defaultThisClass()
    {
        ClassType classType = new ClassType(getFullyQualifiedClassName(), getSuperClass());
        classType.setModifiers(classModifiers);
        getFactory().putType(getFullyQualifiedClassName(), classType);
        return classType;
    }

    /**
     * Sets the ClassType of the generated class.
     * @param classType the ClassType of the generated class
     * @throws ClassMakerException if it is too late to call this method
     */
    protected void setClassType(ClassType classType)
    {
        if (cfw != null)
            throw createException("ClassMaker.ToLateToSetClassType");
        thisClassType = classType;
        addClassTypeAlias(classType);
    }

    /**
     * Gets the ClassType of the generated class.
     * </br>
     * Generates a default ClassType if one has not been set explicitly.
     * 
     * The <code>Type</code> represents a reference to an instance of the
     * class that has been pushed onto the stack, such as may be used when accessing
     * a non static member, while the <code>DeclaredType</code> represents the class, 
     * such as may be used when accessing a static member.
     * 
     * @see #defaultThisClass()
     * @return the ClassType of the generated class
     */
    public ClassType getClassType()
    {
        if (thisClassType == null)
            setClassType(defaultThisClass());
        return thisClassType;
    }
    
    /**
     * Gets the DeclaredType of the generated class.
     * </br>
     * The <code>DeclaredType</code> is a wrapper around the <code>Type</code> of the class
     * currently being generated. 
     * 
     * The <code>DeclaredType</code> represents the class, such as may be used when accessing
     * a static member, while the <code>Type</code> represents a reference to an instance of the
     * class that has been pushed onto the stack, such as may be used when accessing
     * a non static member.
     * 
     * @see #getClassType()
     * @return the ClassType of the generated class
     */
    public DeclaredType getDeclaredType()
    {
        if (thisDeclaredType == null)
            thisDeclaredType = getFactory().createDeclaredTypeMaker(this);
        return thisDeclaredType;
    }

    /**
     * Gets the DeclaredType of the given Type.
     * </br>
     * The <code>DeclaredType</code> is a wrapper around the <code>Type</code> of the class
     * currently being generated. 
     * 
     * The <code>DeclaredType</code> represents the class, such as may be used when accessing
     * a static member, while the <code>Type</code> represents a reference to an instance of the
     * class that has been pushed onto the stack, such as may be used when accessing
     * a non static member.
     * 
     * @see #getClassType()
     * @param type the Type to be converted to a DeclaredType
     * @return the ClassType of the generated class
     */
    public DeclaredType getDeclaredType(Type type)
    {
        return getFactory().typeToDeclaredType(type);
    }

    /**
     * Generates a ClassType for the super class of the generated class.
     * </br>
     * The default super class is <code>java.lang.Object</code>.
     * @return the ClassType of the super class
     */
    protected DeclaredType defaultSuperClass()
    {
        return getDeclaredType(OBJECT_TYPE);
    }

    /**
     * Sets the ClassType for the super class of the generated class.
     * @param classType the ClassType of the super class
     */
    protected void setSuperClass(DeclaredType classType)
    {
        superClass = classType;
    }

    /**
     * Gets the ClassType for the super class of the generated class.
     * </br>
     * Generates a default ClassType if one has not been set explicitly.
     * @see #defaultSuperClass()
     * @return classType the ClassType of the super class
     */
    public DeclaredType getSuperClass()
    {
        if (superClass == null)
            setSuperClass(defaultSuperClass());
        return superClass;
    }

    /** 
     * Determines whether the class should be generated using two passes.
     * </br>
     * The first pass will gather type information and method signatures.
     * The second pass will generate the byte-code. 
     * @return true if two passes should be used; otherwise false
     */
    public boolean isTwoPass()
    {
        return (getPass() != ClassMaker.ONE_PASS);
    }

    /**
     * The generated class extends the given class.
     * </br>
     * This version takes a <code>String</code> and can be used to extend other generated classes.
     * @param className the name of the class that the generated class extends
     * @throws ClassMakerException if it is too late to call this method
     */
    public void Extends(String className) throws ClassMakerException
    {
        if (cfw != null)
            throw createException("ClassMaker.ToLateToExtendTheClass");
        DeclaredType declared = stringToDeclaredType(className);
        if (getPass() != ClassMaker.FIRST_PASS)
        {
            ClassType type = declared.getClassType();
            if (declared.getClassType() == null)
            {
                throw createException("ClassMaker.NoClassTypeCalled_1", className);
            }
            int mod = type.getModifiers();
            if (Modifier.isInterface(mod))
                throw createException("ClassMaker.CannotExtendInterface", type.getName());
        }

        setSuperClass(declared);
    }

    /**
     * The generated class extends the given java class.
     * </br>
     * This version takes a <code>Class</code> which must be available at compile time.
     * This means the class must be a compiled java class or a generated class that has
     * been loaded using the <code>defineClass</code> method.
     * @param javaClass the class that the generated class extends
     * @throws ClassMakerException if it is too late to call this method
     */
    public void Extends(Class javaClass) throws ClassMakerException
    {
        if (cfw != null)
            throw createException("ClassMaker.ToLateToExtendTheClass");
        int mod = javaClass.getModifiers();
        if (Modifier.isInterface(mod))
            throw createException("ClassMaker.CannotExtendInterface", javaClass.getName());
            
        setSuperClass(classToDeclaredType(javaClass));
    }

    /** 
     * Creates an instance of the ClassFileWriter if one has not been set.
     * @return a ClassFileWriter instance
     */
    protected ClassFileWriter defaultClassFileWriter()
    {
        String className = getClassType().getName();
        String extendsClassName = getSuperClass().getName();
        String sourceFile = getSourceLine().getFilename();
        ClassFileWriter writer =  new ClassFileWriter(toSlashName(className), toSlashName(extendsClassName), sourceFile);
        // Setting the Super bit is required for class files after Java 1.2.
        writer.setFlags((short)(getModifiers() | MASK_SUPER));
        return writer;
    }

    /**
     * Sets the ClassFileWriter instance for this ClassMaker.
     * @param classFileWriter the ClassFileWriter instance
     */
    protected void setClassFileWriter(ClassFileWriter classFileWriter)
    {
        cfw = classFileWriter;
    }

    /** 
     * Each <code>ClassMaker</code> instance has its own <code>ClassFileWriter</code>. 
     * </br>
     * Generates a default ClassFileWriter if one has not been set explicitly.
     * @see #defaultClassFileWriter()
     * @return the <code>ClassFileWriter<code> instance for this <code>ClassMaker<code>
     */
    protected ClassFileWriter getClassFileWriter()
    {
        if (cfw == null && getPass() != FIRST_PASS)
            setClassFileWriter(defaultClassFileWriter());
        return cfw;
    }
    
    protected boolean isDebugCode()
    {
    	if (getClassFileWriter() != null)
    		return cfw.isDebugCode();
    	return false;
    }

    /** <code>ClassMaker</code>s share a common <code>ClassMakerFactory</code>. */
    public ClassMakerFactory getFactory()
    {
        return factory;
    }

    // Convenience methods

    /**
     * Gets the methods declared by the generated class.
     * @return an array of declared methods.
     */
    public MakerMethod[] getDeclaredMethods()
    {
        return methods.toArray(ClassMakerFactory.METHOD_ARRAY);
    }
    
    /**
     * Gets the methods declared by the generated class and its super classes.
     * @return an array of declared methods.
     */
    private MakerMethod[] getAllClassMethods()
    {
        HashMap<String, MakerMethod> allMethods = new HashMap<String, MakerMethod>();
        ClassMakerFactory.addMethods(allMethods, getDeclaredMethods());
        
    	getFactory().findJavaClassMethods(allMethods, getSuperClass().getClassType());
        if (isInterface())
            getFactory().findJavaInterfaceMethods(allMethods, getClassType());
        return allMethods.values().toArray(ClassMakerFactory.METHOD_ARRAY);
    }

    /**
     * Gets the methods declared by the interfaces implemented by this class.
     * @return an array of declared methods.
     */
    private MakerMethod[] getAllInterfaceMethods()
    {
        HashMap<String, MakerMethod> allMethods = new HashMap<String, MakerMethod>();
        // Add generated methods if this is an interface
        if (isInterface())
        {
            ClassMakerFactory.addMethods(allMethods, getDeclaredMethods());
        }
        getFactory().findJavaInterfaceMethods(allMethods, getClassType());
        return allMethods.values().toArray(ClassMakerFactory.METHOD_ARRAY);
    }

    /**
     * Gets the constructors declared by the generated class.
     * @return an array of declared constructors.
     */
    public MakerMethod[] getDeclaredConstructors()
    {
        return constructors.toArray(ClassMakerFactory.METHOD_ARRAY);
    }

    /**
     * Gets the interfaces implemented by the generated class.
     * @return an array of implemented interfaces
     */
    public DeclaredType[] getDeclaredInterfaces()
    {
        return interfaces.toArray(ClassMakerFactory.DECLARED_TYPE_ARRAY);
    }

    /**
     * Gets the member fields declared by the generated class.
     * @return an array of member fields
     */
    public MakerField[] getDeclaredFields()
    {
        return fieldTable.toArray(ClassMakerFactory.FIELD_ARRAY);
    }

    /**
     * Find a local variable by index.
     * @param index an index into <code>localTable</code>
     * @return the indexed local field
     */
    MakerField lookupLocal(int index)
    {
        return localTable.get(index);
    }

    /** The class modifiers for the generated class. */
    public int getModifiers()
    {
        return getClassType().getModifiers();
    }

    /**
     * Sets the class modifiers for the generated class.
     * @param modifiers valid class modifiers are:
     * <code>ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE, ACC_STATIC, ACC_FINAL</code>
     * and <code>ACC_ABSTRACT</code>
     */
    public void setClassModifiers(int modifiers)
    {
        if ((modifiers & ClassMaker.ACC_INTERFACE) == ClassMaker.ACC_INTERFACE)
        {
            checkInterfaceModifiers(modifiers);
            // Interface always has modifiers ACC_PUBLIC, ACC_INTERFACE and ACC_ABSTRACT
            classModifiers = MASK_INTERFACE;
        }
        else
        {
            checkClassModifiers(modifiers);
            classModifiers = modifiers;
        }
        if (thisClassType != null)
            thisClassType.setModifiers(classModifiers);

    }
    
    /**
     * Determines whether the class being generated is abstract.
     * @return true if the generated class is abstract
     */
    public boolean isAbstract()
    {
        return (getModifiers() & ClassMaker.ACC_ABSTRACT) == ClassMaker.ACC_ABSTRACT;
    }

    /**
     * Determines whether the class being generated is an interface.
     * @return true if the generated class is an interface
     */
    public boolean isInterface()
    {
        return (getModifiers() & ClassMaker.ACC_INTERFACE) == ClassMaker.ACC_INTERFACE;
    }

    /**
     * Sets the class modifiers to turn this class into an interface.
     */
    public void setIsInterface()
    {
        setClassModifiers(ACC_INTERFACE);
    }

    /**
     * Check that the bit mask only contains valid class modifiers.
     * <br/>
     * The following are valid modifiers for a class.
     * <ul>
     * <li><code>ClassMaker.ACC_PUBLIC</code></li>
     * <li><code>ClassMaker.ACC_PROTECTED</code></li>
     * <li><code>ClassMaker.ACC_PRIVATE</code></li>
     * <li><code>ClassMaker.ACC_ABSTRACT</code></li>
     * <li><code>ClassMaker.ACC_FINAL</code></li>
     * <li><code>ClassMaker.ACC_STRICTFP</code></li>
     * <li>zero</li>
     * </ul>
     * @param modifiers the bit mask of modifiers
     * @throws ClassMakerException if the bit mask includes an invalid modifier
     */
    protected void checkClassModifiers(int modifiers) throws ClassMakerException
    {
        int wrongModifiers = modifiers & (~MASK_CLASS);
        if (wrongModifiers != 0)
            throw createException("ClassMaker.InvalidClassModifier_1", toModifierString(wrongModifiers));
        checkMultipleAccessModifiers(modifiers);
        if (((modifiers & ClassMaker.ACC_FINAL) == ClassMaker.ACC_FINAL) &&
            ((modifiers & ClassMaker.ACC_ABSTRACT) == ClassMaker.ACC_ABSTRACT))
            throw createException("ClassMaker.InvalidClassModifierCombination");
    }

    /**
     * Check that the bit mask only contains valid interface modifiers.
     * <br/>
     * The following are valid modifiers for an interface.
     * <ul>
     * <li><code>ClassMaker.ACC_PUBLIC</code></li>
     * <li><code>ClassMaker.ACC_ABSTRACT</code></li>
     * <li><code>ClassMaker.ACC_INTERFACE</code></li>
     * <li>zero</li>
     * </ul>
     * @param modifiers the bit mask of modifiers
     * @throws ClassMakerException if the bit mask includes an invalid modifier
     */
    protected void checkInterfaceModifiers(int modifiers) throws ClassMakerException
    {
        int wrongModifiers = modifiers & (~MASK_INTERFACE);
        if (wrongModifiers != 0)
            throw createException("ClassMaker.InvalidInterfaceModifier_1", toModifierString(wrongModifiers));
        checkMultipleAccessModifiers(modifiers);
    }

    /**
     * Check that the bit mask only contains valid method modifiers.
     * </br>
     * The following are valid modifiers for a member method.
     * <ul>
     * <li><code>ClassMaker.ACC_PUBLIC</code></li>
     * <li><code>ClassMaker.ACC_PROTECTED</code></li>
     * <li><code>ClassMaker.ACC_PRIVATE</code></li>
     * <li><code>ClassMaker.ACC_STATIC</code></li>
     * <li><code>ClassMaker.ACC_FINAL</code></li>
     * <li><code>ClassMaker.ACC_ABSTRACT</code></li>
     * <li><code>ClassMaker.ACC_SYNCHRONIZED</code></li>
     * <li><code>ClassMaker.ACC_NATIVE</code></li> 
     * <li><code>ClassMaker.ACC_STRICTFP</code></li>
     * <li>zero</li>
     * </ul>
     * @param modifiers the bit mask of modifiers
     * @throws ClassMakerException if the bit mask includes an invalid modifier
     */
    protected void checkMethodModifiers(int modifiers) throws ClassMakerException
    {
    	// Check that the list contains valid modifiers
        int wrongModifiers = modifiers & (~MASK_METHOD);
        if (wrongModifiers != 0)
            throw createException("ClassMaker.InvalidMethodModifier_1", toModifierString(wrongModifiers));
        checkMultipleAccessModifiers(modifiers);
        // Check that abstract is not used with an incompatible modifier
        if (((modifiers & ClassMaker.ACC_ABSTRACT) == ClassMaker.ACC_ABSTRACT))
        {
            if ((modifiers & (MASK_INCOMPATABLE_WITH_ABSTRACT_METHOD)) > 0)
                throw createException("ClassMaker.InvalidMethodModifierCombination_1",
                                toModifierString(modifiers & MASK_INCOMPATABLE_WITH_ABSTRACT_METHOD));
        }
    }

    /**
     * Check that the bit mask only contains valid field modifiers.
     * </br>
     * The following are valid modifiers for a member field.
     * <ul>
     * <li><code>ClassMaker.ACC_PUBLIC</code></li>
     * <li><code>ClassMaker.ACC_PROTECTED</code></li>
     * <li><code>ClassMaker.ACC_PRIVATE</code></li>
     * <li><code>ClassMaker.ACC_STATIC</code></li>
     * <li><code>ClassMaker.ACC_FINAL</code></li>
     * <li><code>ClassMaker.ACC_TRANSIENT</code></li>
     * <li><code>ClassMaker.ACC_VOLATILE</code></li>
     * <li>zero</li>
     * </ul>
     * @param modifiers the bit mask of modifiers
     * @throws ClassMakerException if the bit mask includes an invalid modifier
     */
    protected void checkFieldModifiers(int modifiers) throws ClassMakerException
    {
        int wrongModifiers = modifiers & (~MASK_FIELD);
        if (wrongModifiers != 0)
            throw createException("ClassMaker.InvalidFieldModifier_1", toModifierString(wrongModifiers));
        checkMultipleAccessModifiers(modifiers);
        if (((modifiers & ClassMaker.ACC_FINAL) == ClassMaker.ACC_FINAL) &&
                        ((modifiers & ClassMaker.ACC_VOLATILE) == ClassMaker.ACC_VOLATILE))
        {
            throw createException("ClassMaker.InvalidFieldModifierCombination");
        }
    }

    /**
     * Check that the bit mask does not contain more than one access modifier.
     * </br>
     * The following are access modifiers.
     * <ul>
     * <li><code>ClassMaker.ACC_PUBLIC</code></li>
     * <li><code>ClassMaker.ACC_PROTECTED</code></li>
     * <li><code>ClassMaker.ACC_PRIVATE</code></li>
     * <li>zero</li>
     * </ul>
     * @param modifiers the bit mask of modifiers
     * @throws ClassMakerException if the bit mask includes more than one access modifier
     */
    protected void checkMultipleAccessModifiers(int modifiers) throws ClassMakerException
    {
        // Check there is no more than one access modifier
        int accessModifiers = modifiers & MASK_ACCESS;
        if (accessModifiers != ClassMaker.ACC_PUBLIC &&
            accessModifiers != ClassMaker.ACC_PROTECTED &&
            accessModifiers != ClassMaker.ACC_PRIVATE &&
            accessModifiers != 0)
        {
        	throw createException("ClassMaker.MultipleAccessModifiers_1", toModifierString(accessModifiers));
        }
    }

    /**
     * Ensures that a method is currently being generated.
     * @throws ClassMakerException if not generating a method
     */
    void checkInMethod() throws ClassMakerException
    {
    	if (method == null)
    		throw createException("ClassMaker.MustBeInMethod");
    }

    public int addModifier(int modifiers, String modifierName)
    {
        int modifier = fromModifierString(modifierName);
        if ((modifiers & modifier) > 0)
            throw createException("ClassMaker.DuplicateModifier_1", modifierName);            
        return modifiers | modifier;
    }
    
    public static int fromModifierString(String value)
    {
        if ("public".equals((value)))
            return ClassMaker.ACC_PUBLIC;
        else if ("protected".equals((value)))
            return ClassMaker.ACC_PROTECTED;
        else if ("private".equals((value)))
            return ClassMaker.ACC_PRIVATE;
        else if ("static".equals((value)))
            return ClassMaker.ACC_STATIC;
        else if ("final".equals((value)))
            return ClassMaker.ACC_FINAL;
        else if ("synchronized".equals((value)))
            return ClassMaker.ACC_SYNCHRONIZED;
        else if ("volatile".equals((value)))
            return ClassMaker.ACC_VOLATILE;
        else if ("transient".equals((value)))
            return ClassMaker.ACC_TRANSIENT;
        else if ("native".equals((value)))
            return ClassMaker.ACC_NATIVE;
        else if ("abstract".equals((value)))
            return ClassMaker.ACC_ABSTRACT;
        else if ("strictfp".equals((value)))
            return ClassMaker.ACC_STRICTFP;
        else 
            throw new IllegalArgumentException("Invalid modifier: " + value);
    }

    /**
     * Creates a white space separated string of modifiers from a bit mask.
     * @param modifiers a bit mask of modifiers.
     * @return a white space separated string of modifier names
     */
    public static String toModifierString(int modifiers)
    {
        StringBuffer buf = new StringBuffer();
        appendModifier(buf, modifiers, ClassMaker.ACC_PUBLIC, "public");
        appendModifier(buf, modifiers, ClassMaker.ACC_PROTECTED, "protected");
        appendModifier(buf, modifiers, ClassMaker.ACC_PRIVATE, "private");
        appendModifier(buf, modifiers, ClassMaker.ACC_STATIC, "static");
        appendModifier(buf, modifiers, ClassMaker.ACC_FINAL, "final");
        appendModifier(buf, modifiers, ClassMaker.ACC_SYNCHRONIZED, "synchronized");
        appendModifier(buf, modifiers, ClassMaker.ACC_VOLATILE, "volatile");
        appendModifier(buf, modifiers, ClassMaker.ACC_TRANSIENT, "transient");
        appendModifier(buf, modifiers, ClassMaker.ACC_NATIVE, "native");
        appendModifier(buf, modifiers, ClassMaker.ACC_ABSTRACT, "abstract");
        appendModifier(buf, modifiers, ClassMaker.ACC_STRICTFP, "strictfp");
        return buf.toString();
    }

    /* Appends a modifier to a StringBuffer. */
    private static void appendModifier(StringBuffer buf, int modifiers, int expected, String name)
    {
        if ((modifiers & expected) != 0)
        {
            appendStrings(buf, name, " ");
        }
    }

    /* Append a string to the StringBuffer placing a separator before subsequent values. */
    private static void appendStrings(StringBuffer buf, String value, String separator)
    {
        if (buf.length() > 0)
            buf.append(separator);
        buf.append(value);
    }

    /**
     * Determines whether a constructor has been declared for the generated class.
     */
    public boolean hasConstructor()
    {
        return hasConstructor;
    }

    /**
     * Get the current pass for the class generator.
     * </br>
     * The following are valid options.
     * <ul>
     * <li><code>ClassMaker.ONE_PASS</code></li>
     * <li><code>ClassMaker.FIRST_PASS</code></li>
     * <li><code>ClassMaker.SECOND_PASS</code></li>
     * </ul>
     * The default is <code>ClassMaker.ONE_PASS</code>.
     */
    public int getPass()
    {
        return getFactory().getPass();
    }

//############# Helper methods for derived classes #########

    /**
     * Determines whether the <code>Type</code> is a class.
     * @param type the type to be tested
     * @return true if <code>Type</code> implements a class
     */
    public static boolean isClass(Type type)
    {
        return type != null && type.toClass() != null;
    }

    /**
     * Determines whether the <code>Type</code> is an array.
     * @param type the type to be tested
     * @return true if <code>Type</code> implements a array
     */
    public static boolean isArray(Type type)
    {
        return type != null && type.toArray() != null;
    }

    /**
     * Determines whether the <code>Type</code> is an interface.
     * @param type the type to be tested
     * @return true if <code>Type</code> implements a class
     */
    public static boolean isInterface(Type type)
    {
        if (type != null && type.toClass() != null)
            return type.toClass().isInterface();
        return false;
    }

    /**
     * Determines whether the <code>Type</code> is a primitive type.
     * @param type the type to be tested
     * @return true if <code>Type</code> is a primitive type
     */
    public static boolean isPrimitive(Type type)
    {
        return type != null && type.toPrimitive() != null;
    }

    //###################  ################

    /**
     * Converts a <code>Class</code> into a class name.
     * @param javaClass the class from which to derive the name
     * @return a fully qualified class name delimited by dots
     */
    public static String classToName(Class javaClass)
    {
        if (javaClass.isArray())
            return toDotName(javaClass.getCanonicalName());
        else
            return toDotName(javaClass.getName());
    }

    /**
     * Converts a <code>Class</code> into a class name.
     * @param javaClass the class from which to derive the name
     * @return a fully qualified class name delimited by slashes
     */
    public static String classToSlashName(Class javaClass)
    {
        if (javaClass.isArray())
            return toSlashName(javaClass.getCanonicalName());
        else
            return toSlashName(javaClass.getName());
    }

    /**
     * Converts dots into slashes in a class name.
     * @param name the name to be converted
     * @return the name with dots replaced by slashes
     */
    public static String toSlashName(String name)
    {
        return name.replace('.', '/');
    }

    /**
     * Converts slashes into dots in a class name.
     * @param name the name to be converted
     * @return the name with slashes replaced by dots
     */
    public static String toDotName(String name)
    {
        return name.replace('/', '.');
    }

    /**
     * Converts a type Class into a signature.
     * @param javaClass a class representing a type from which to derive the signature
     * @return a JVM signature
     */
    public static String classToSignature(Class javaClass)
    {
        if (javaClass.isArray())
            return toSlashName(javaClass.getName());
        else if (javaClass.isPrimitive())
        {
            if ("int".equals(javaClass.getName()))
                return "I";
            if ("float".equals(javaClass.getName()))
                return "F";
            if ("long".equals(javaClass.getName()))
                return "J";
            if ("void".equals(javaClass.getName()))
                return "V";
            if ("byte".equals(javaClass.getName()))
                return "B";
            if ("char".equals(javaClass.getName()))
                return "C";
            if ("double".equals(javaClass.getName()))
                return "D";
            if ("short".equals(javaClass.getName()))
                return "S";
            if ("boolean".equals(javaClass.getName()))
                return "Z";
            // Should never get here.
            throw new IllegalArgumentException("Could not determine signature for primitive: " + javaClass.getName());
        } else
            return "L" + classToSlashName(javaClass) + ";";
    }

    /**
     * Creates a descriptor for the method suitable for display.
     * <br/>
     * E.g. MakerMethod resolveMethod(maker, methods, name, actualParameters)
     * @param name the name of the method
     * @param params the formal parameters
     * @param returnType the return type of the method
     * @return a string describing the method
     */
    public static String toMethodString(String name, Type[] params, Type returnType)
    {
        StringBuffer buf = new StringBuffer();

        buf.append((returnType != null) ? returnType.getName() : "void");
        buf.append(' ');
        buf.append(name);
        buf.append('(');
        if (params != null)
            for (int i = 0; i < params.length; i++)
            {
                if (i > 0)
                    buf.append(", ");
                Type type = params[i];
                if (type == null)
                    buf.append("null");
                else
                    buf.append(toDotName(type.getName()));
            }
        buf.append(')');
        return buf.toString();
    }

    //################# Class Loader methods ##############

    /**
     * Defines this class in the factory <code>ClassLoader</code>.
     * @return the generated class
     */
    public Class defineClass()
    {
        if (thisClassType != null && thisClassType.getJavaClass() != null)
            return thisClassType.getJavaClass();
        
        EndClass();  // declaredInterfaces is empty ???
        if (getPass() == FIRST_PASS)
            throw createException("ClassMaker.CannotDefineClassAfterFirstPhase");
        getSuperClass().defineClass();
        defineInterfaces(this.getDeclaredInterfaces());
        Class thisClass = getFactory().getClassLoader().defineClass(cfw.getClassName(), cfw.toByteArray());
        thisClassType.setJavaClass(thisClass);
        return thisClass;
    }
    
    private void defineInterfaces(DeclaredType [] interfaces)
    {
        for (DeclaredType declared : interfaces)
        {
            declared.defineClass();
        }
    }
    
    /**
     * Completes processing of the class.
     * This method is automatically called when the class is defined.
     */
    public void EndClass() throws ClassMakerException
    {
        if (method != null)
            throw createException("ClassMaker.MissingEndForPreviousMethod_1", method.toString());
        if (getPass() != COMPLETED_PASS) {
            getClassType(); // Loads generated class into types visible from the factory
            if (!hasConstructor() && !isInterface()) {
                defaultConstructor();
                // Reset the hasConstructor flag if we are doing two passes.
                if (getPass() == FIRST_PASS)
                    hasConstructor = false;
            }
            thisClassType.setConstructors(getDeclaredConstructors());
            thisClassType.setMethods(getDeclaredMethods());
            thisClassType.setInterfaces(getDeclaredInterfaces());
            thisClassType.setFields(getDeclaredFields());
            
            if (getPass() != FIRST_PASS)
            {
                checkClassMethodsAreConcrete();
                checkInterfaceMethodsAreAbstract();
                checkInterfaceMethodsAreImplemented();
            }
        }
    }

    /**
     * Checks that all the methods in the class are concrete.
     * </br>
     * The exception message includes a list of abstract methods.
     * @throws ClassMakerException if an abstract method is found
     */
    void checkClassMethodsAreConcrete() throws ClassMakerException
    {
        if (!isAbstract() && !isInterface())
        {
            boolean hasAbstractMethod = false;
            StringBuffer buf = new StringBuffer();
            for (MakerMethod method : getAllClassMethods())
            {
                if ((method.getModifiers() & ClassMaker.ACC_ABSTRACT) == ClassMaker.ACC_ABSTRACT)
                {
                    hasAbstractMethod = true;
                    appendStrings(buf, method.toString(), "\n");
                }
            }
            if (hasAbstractMethod)
                throw createException("ClassMaker.AbstractMethodsInConcreteClass_1", buf.toString());
        }
    }

    /**
     * Checks that all the methods in the interface are abstract.
     * </br>
     * The exception message includes a list of concrete methods.
     * @throws ClassMakerException if a concrete method is found
     */
    void checkInterfaceMethodsAreAbstract() throws ClassMakerException
    {
        if (isInterface())
        {
            boolean hasConcreteMethod = false;
            StringBuffer buf = new StringBuffer();
            for (MakerMethod method : getAllInterfaceMethods())
            {
                if ((method.getModifiers() & ClassMaker.ACC_ABSTRACT) != ClassMaker.ACC_ABSTRACT)
                {
                    hasConcreteMethod = true;
                    appendStrings(buf, method.toString(), "\n");
                }
            }
            if (hasConcreteMethod)
                throw createException("ClassMaker.ConcreteMethodsInInterface_1", buf.toString());
        }
    }

    /**
     * Checks that all of the interface methods in the generated class have been implemented.
     * </br>
     * The exception message includes a list of unimplemented methods.
     * @throws ClassMakerException if an unimplemented method is found
     */
    void checkInterfaceMethodsAreImplemented() throws ClassMakerException
    {
        if (!isInterface())
        {
            boolean hasUnimplementedMethod = false;
            StringBuffer buf = new StringBuffer();
            MakerMethod [] interfaceMethods = getAllInterfaceMethods();
            for (MakerMethod abstractMethod : interfaceMethods)
            {
                MakerMethod concreteMethod = findImplementingMethod(abstractMethod, !isAbstract());
                if (concreteMethod == null)
                {
                    hasUnimplementedMethod = true;
                    appendStrings(buf, abstractMethod.toString(), "\n");
                }
            }
            if (hasUnimplementedMethod)
                throw createException("ClassMaker.UnimplementedInterfaceMethods_1", buf.toString());
        }
    }

    /**
     * Find a method that implements the given interface method.
     * </br>
     * Abstract methods are sufficient to implement the interface if the class is abstract.
     * @param interfaceMethod the interface method that requires an implementation
     * @param excludeAbstract whether to exclude abstract methods
     * @return the method that implements the interface method
     */
    MakerMethod findImplementingMethod(MakerMethod interfaceMethod, boolean excludeAbstract)
    {
        for (MakerMethod method : getAllClassMethods())
        {
            if (excludeAbstract && (method.getModifiers() & ClassMaker.ACC_ABSTRACT) == ClassMaker.ACC_ABSTRACT)
            {
                continue; // ignore abstract methods
            }
            if (interfaceMethod.equals(method))
                return method;
        }
        return null;
    }

    /**
     * Determine whether the generated class can access the given field in the given class.
     * @param classType the type of the class being accessed
     * @param field the field being accessed
     */
    void checkAccessDenied(ClassType classType, MakerField field)
    {
    	// Determine whether the class is accessible
        if (isAccessDenied(getClassType(), classType, classType.getModifiers()))
            throw createException("ClassMaker.AccessDeniedToClass_1", classType.getName());
        // Determine whether the field is accessible
        if (isAccessDenied(getClassType(), field.getClassType(), field.getModifiers()))
            throw createException("ClassMaker.AccessDeniedToField_2", classType.getName(), field.getName());
        // Determine whether a protected field is accessible
        if (isAccessDeniedToProtected(getClassType(), classType, field.getModifiers()))
            throw createException("ClassMaker.AccessDeniedToProtectedField_2", classType.getName(), field.getName());
    }

    /**
     * Determine whether the generated class can access the given method in the given class.
     * @param classType the type of the class being accessed
     * @param method the method being accessed
     */
    void checkAccessDenied(ClassType classType, MakerMethod method)
    {
    	// Determine whether the class is accessible
        if (isAccessDenied(getClassType(), classType, classType.getModifiers()))
            throw createException("ClassMaker.AccessDeniedToClass_1", classType.getName());
        // Determine whether the method is accessible
        if (isAccessDenied(getClassType(), method.getClassType(), method.getModifiers()))
            throw createException("ClassMaker.AccessDeniedToMethod_2", classType.getName(), method.toString());
        // Determine whether a protected method is accessible
        if (isAccessDeniedToProtected(getClassType(), classType, method.getModifiers()))
            throw createException("ClassMaker.AccessDeniedToProtectedMethod_2", classType.getName(), method.toString());
    }

    /**
     * Determines whether access is denied to a protected method or field.
     * </br>
     * If the method or field is protected and not static this method ensures the following access restriction.
     * The called class must be of the same type as the caller class or a sub-type of it.
     * @param caller the caller is the class doing the access
     * @param called the class being accessed
     * @param modifiers the access modifiers of the method or field being accessed
     * @return true if the caller class is denied access to the method or field
     */
    boolean isAccessDeniedToProtected(ClassType caller, ClassType called, int modifiers)
    {
        // Test does not apply to static fields.
        if ((modifiers & ClassMaker.ACC_STATIC) == ClassMaker.ACC_STATIC)
            return false;
        modifiers &= MASK_ACCESS;
        // FIXME - include explanation and reference 
        return ((modifiers == ClassMaker.ACC_PROTECTED) &&
             !caller.getPackageName().equals(called.getPackageName()) &&
             !getFactory().getAssignmentConversion().isWideningClassConvertable(called, caller));
    }

    /**
     * Determines whether access is denied to a class, member method or member field.
     * </br>
     * This method is used to determine whether:
     * <ul>
     * <li> a class is accessible by providing the class modifiers</li>
     * <li> a method within a class is accessible by providing the method modifiers</li>
     * <li> a field within a class is accessible by providing the field modifiers.</li>
     * </ul>
     * This method ensures the following access restrictions. 
     * <UL>
     * <LI>A <code>public</code> class or member is accessible from anywhere. </LI> 
     * <LI>A <code>protected</code> class or member is accessible from the same package or a derived class. </LI> 
     * <LI>A <code>package</code> class or member has no access modifier and is accessible from the same package. </LI> 
     * <LI>A <code>private</code> class or member is accessible from within its own class. </LI>
     * </UL>
     * @param caller the caller is the class doing the access
     * @param called the class being accessed
     * @param modifiers the access modifiers of the class, method or field being accessed
     * @return true if the caller class is denied access to the class, method or field
     */
    boolean isAccessDenied(ClassType caller, ClassType called, int modifiers)
    {
        modifiers &= MASK_ACCESS;
        if (modifiers == ClassMaker.ACC_PUBLIC)
            return false;
        else if (((modifiers == ClassMaker.ACC_PACKAGE) || (modifiers == ClassMaker.ACC_PROTECTED)) &&
                   caller.getPackageName().equals(called.getPackageName()))
            return false;
        else if ((modifiers == ClassMaker.ACC_PROTECTED) &&
                  getFactory().getAssignmentConversion().isConvertable(caller, called))
            return false;
        else if ((modifiers == ClassMaker.ACC_PRIVATE) && caller.equals(called))
            return false;
        return true;
    }

    /**
     * Generate a default constructor for the class.
     */
    public void defaultConstructor()
    {
        Method(INIT, VOID_TYPE, ClassMaker.ACC_PUBLIC);
        Begin();
            Init(Super(), null);
            Return();
        End();
    }

    //##################### Import methods ###############

    /**
     * Imports the named class and creates a mapping for the short class name.
     * @param className the fully qualified name for the class
     * @throws ClassMakerException if the class does not exist
     */
    public void Import(String className) throws ClassMakerException
    {
        DeclaredType declaredType = aliasMap.get(toDotName(className));
        if (declaredType == null)
        {
        	DeclaredType declaredClass = stringToDeclaredClass(toDotName(className));
        	addClassTypeAlias(declaredClass);
            if (log.isLoggable(Level.FINE))
                log.finest("Import " + declaredClass);
        }
    }

    /**
     * Imports the given class and creates a mapping for the short class name.
     * @param javaClass the class to be imported
     * @throws ClassMakerException if the javaClass does not represent a class type
     */
    public void Import(Class javaClass) throws ClassMakerException
    {
        ClassType classType = classToClassType(javaClass);
        addClassTypeAlias(classType);
        if (log.isLoggable(Level.FINE))
            log.finest("Import " + javaClass.getName());
    }

    /**
     * Converts a class name to a <code>DeclaredType</code> containing a <code>ClassType</code>.
     * </br>
     * An existing <code>DeclaredType</code> is returned if the java class has been used previously.
     * A simple class name will be successful if the class was previously imported.
     * <code>DeclaredType</code>s are cached in the shared <code>ClassMakerFactory</code>.
     * @param className the short or fully qualified name of the <code>Class</code>
     * @return the <code>DeclaredType</code> associated with the className
     * @throws ClassMakerException if the class does not exist
     */
    DeclaredType stringToDeclaredClass(String className) throws ClassMakerException
    {
        DeclaredType declared = findDeclaredType(className);
        if (declared == null || declared.getClassType() == null)
        {
            throw createException("ClassMaker.NoClassTypeCalled_1", className);
        }
        return declared;
    }
    
    /**
     * Converts a type name to a <code>DeclaredType</code> containing a <code>Type</code>.
     * </br>
     * An existing Type is returned if a primitive type is named or the java class has been used previously.
     * A simple class name will be successful if the class was imported.
     * <code>Type</code>s are cached in the shared <code>ClassMakerFactory</code>.
     * @param typeName the simple name or fully qualified name of the type
     * @return the <code>Type</code> associated with the typeName
     * @throws ClassMakerException if the type does not exist
     */
    DeclaredType stringToDeclaredType(String typeName) throws ClassMakerException
    {
        // The alias table maps simple class names to ClassTypes.
        DeclaredType declared = findDeclaredType(typeName);
        if (declared == null)
        {
            throw createException("ClassMaker.NoTypeCalled_1", typeName);
        }
        return declared;
    }
    

    /**
     * Finds or creates a <code>ClassType</code> wrapper around a java <code>Class</code>.
     * </br>
     * An existing ClassType is returned if the java class has been used previously.
     * <code>ClassType</code>s are cached in the shared <code>ClassMakerFactory</code>.
     * @param javaClass the java class to be wrapped
     * @return the <code>ClassType</code> that describes the java class
     * @throws ClassMakerException if the javaClass does not represent a class type
     */
    public ClassType classToClassType(Class javaClass) throws ClassMakerException
    {
        Type type = getFactory().classToType(javaClass);
        if (type.toClass() != null)
            return type.toClass();
        throw createException("ClassMaker.NotAClass_1", javaClass.getSimpleName());
    }

    public DeclaredType classToDeclaredType(Class javaClass) throws ClassMakerException
    {
        DeclaredType declared = getFactory().classToDeclaredType(javaClass);
        if (declared == null)
            throw createException("ClassMaker.NotAType_1", javaClass.getSimpleName());
        return declared;
    }

    /**
     * Finds a <code>ClassType</code> given a simple or fully qualified class name.
     * </br>
     * Aliases are created by the <code>Import</code> method.
     * The simple class name is an alias for the fully qualified class name.
     * Aliases are stored locally in the <code>ClassMaker</code> instance.
     * </br>
     * A fully qualified class name must be used if two classes are imported with the same
     * simple name, e.g. java.util.Date and java.sql.Date. 
     * @param className the simple or fully qualified class name
     * @return the <code>ClassType</code> corresponding to the name
     * @throws ClassMakerException if a fully qualified class name must be used
     */
    ClassType getImported(String className) throws ClassMakerException
    {
        DeclaredType declaredType = aliasMap.get(toDotName(className));
        if (declaredType == null)
            return null;
        ClassType classType = declaredType.getType().toClass();
        //ClassType classType = aliasMap.get(toDotName(className));
        // The alias map uses NULL_TYPE if more than one class with the same simple class name has been imported.
        if (ClassMaker.NULL_TYPE.equals(classType))
            throw createException("ClassMaker.MustUseFullyQualifiedClassName_1", className);
        return classType;
    }

    DeclaredType getPackageDeclared(String className) throws ClassMakerException
    {
        DeclaredType declaredType = null;
        if (packageName != null && !"".equals(packageName))
        {
            String classNameFQ = packageName + "." + className;
            declaredType = getFactory().stringToDeclaredType(classNameFQ);
        }
        return declaredType;
    }

    DeclaredType getAliasMapDeclared(String className) throws ClassMakerException
    {
        DeclaredType declaredType = aliasMap.get(toDotName(className));
        if (declaredType != null)
        {
            // The alias map uses NULL_TYPE if more than one class with the same simple class name has been imported.
            if (ClassMaker.NULL_TYPE.equals(declaredType.getType()))
                throw createException("ClassMaker.MustUseFullyQualifiedClassName_1", className);
        }
        return declaredType;
    }
    
    /**
     * Allows a <code>ClassType</code> to be found using the short class name.
     * </br>
     * Aliases are created by the <code>Import</code> method.
     * The simple class name is an alias for the fully qualified class name.
     * Aliases are stored locally in the <code>ClassMaker</code> instance.
     * </br>
     * Only the fully qualified name will be used if two classes are imported with the same
     * name, e.g. java.util.Date and java.sql.Date. 
     * @param classType the class to be added to the alias table
     */
    void addClassTypeAlias(ClassType classType)
    {
        String className = toDotName(classType.getName());
        if (aliasMap.get(className) != null)
            return;
        int index = className.lastIndexOf('$');
        if (index == -1)
            index = className.lastIndexOf('.');
        if (index > -1)
        {   // A simple name exists so add it to the alias map.
            String simpleName = className.substring(index+1);
            DeclaredType aliasType = aliasMap.get(simpleName);
            if (aliasType == null)
                aliasMap.put(simpleName, new DeclaredType(classType));
            else
            {   // A clash of simple names exists so we must use fully qualified names.
                if (!NULL_TYPE.equals(aliasType.getType()))
                {   // Use NULL_TYPE as a marker to force fully qualified names.
                    aliasMap.put(simpleName, new DeclaredType(NULL_TYPE));
                }
            }
        }
        // Add the fully qualified class name to the alias map.
        aliasMap.put(className, new DeclaredType(classType));
    }

    void addClassTypeAlias(DeclaredType declared)
    {
        String className = toDotName(declared.getName());
        if (aliasMap.get(className) != null)
            return;
        int index = className.lastIndexOf('$');
        if (index == -1)
            index = className.lastIndexOf('.');
        if (index > -1)
        {   // A simple name exists so add it to the alias map.
            String simpleName = className.substring(index+1);
            DeclaredType aliasType = aliasMap.get(simpleName);
            if (aliasType == null)
                aliasMap.put(simpleName, declared);
            else
            {   // A clash of simple names exists so we must use fully qualified names.
                if (!NULL_TYPE.equals(aliasType.getType()))
                {   // Use NULL_TYPE as a marker to force fully qualified names.
                    aliasMap.put(simpleName, new DeclaredType(NULL_TYPE));
                }
            }
        }
        // Add the fully qualified class name to the alias map.
        aliasMap.put(className, declared);
    }

    //##################### Method resolving ###################

    /**
     * Determines which constructor in this class should be invoked.
     *
     * Uses <code>MethodResolver</code> to determine the appropriate constructor given the
     * actual parameters.
     * @param classType the type of the class containing the method
     * @param actualParameters the parameters on the call stack
     * @return a <code>MakerMethod</code> which represents the resolved method
     */
    MakerMethod resolveConstructor(ClassType classType, CallStack actualParameters)
    {
        MakerMethod [] constructors = getConstructors(classType);
        if (actualParameters == null)
            actualParameters = EMPTY_CALL_STACK;
        return getFactory().getMethodResolver().resolveMethod(this, constructors, INIT, actualParameters);
    }

    /**
     * Fetches the methods in the given ClassType.
     *
     * The methods are lazy loaded for existing java classes or the current list
     * of methods is used for the class being generated.
     * @param classType the ClassType that holds information about the class
     * @return an array of method descriptors
     */
    MakerMethod [] getConstructors(ClassType classType)
    {
        if (classType == thisClassType)
            return getDeclaredConstructors();
        if (classType.getConstructors() == null)
            getFactory().populateJavaClassConstructors(classType);
        return classType.getConstructors();
    }

    /**
     * Determines which method in the given class should be invoked.
     *
     * Uses <code>MethodResolver</code> to determine the appropriate method given the method name and actual parameters.
     * @param classType the type of the class containing the method
     * @param name the name of the method
     * @param actualParameters the parameters on the call stack
     * @return a <code>MakerMethod</code> which represents the resolved method
     */
    public MakerMethod resolveMethod(ClassType classType, String name, CallStack actualParameters)
    {
        MakerMethod [] methods = getMethods(classType);
        if (actualParameters == null)
            actualParameters = EMPTY_CALL_STACK;
        return getFactory().getMethodResolver().resolveMethod(this, methods, name, actualParameters);
    }

    /**
     * Fetches the methods in the given ClassType.
     *
     * The methods are lazy loaded for existing java classes or the current list
     * of methods is used for the class being generated.
     * @param classType the ClassType that holds information about the class
     * @return an array of method descriptors
     */
    MakerMethod [] getMethods(ClassType classType)
    {
        if (classType.getAllMethods() == null)
        {
            if (classType == thisClassType)
                thisClassType.setAllMethods(getAllClassMethods());
            else
                classType.setAllMethods(getFactory().getMethods(classType));
        }
        return classType.getAllMethods();
    }

    //################### Methods #####################
    /**
     * Starts the declaration of a method with a <code>Class</code> representing the return type.
     * @param methodName the name of the method to be generated
     * @param returnType the <code>Class</code> of the return type for the method
     * @param methodModifiers appropriate modifiers include:
     * <code>ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE, ACC_STATIC, ACC_FINAL</code>
     */
    public void Method(String methodName, Class returnType, int methodModifiers) throws ClassMakerException
    {
        DeclaredType declared = getFactory().classToDeclaredType(returnType);
        Method(methodName, declared, methodModifiers);
    }

    /**
     * Starts the declaration of a method.
     * @param methodName the name of the method to be generated
     * @param returnType the return type for the method
     * @param methodModifiers appropriate modifiers include:
     * <code>ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE, ACC_STATIC, ACC_FINAL</code>
     */
    public void Method(String methodName, String returnType, int methodModifiers) throws ClassMakerException
    {
        DeclaredType type = stringToDeclaredType(returnType);
        Method(methodName, type, methodModifiers);
    }

    /**
     * Starts the declaration of a method.
     * @param methodName the name of the method to be generated
     * @param returnType the return type for the method
     * @param methodModifiers appropriate modifiers include:
     * <code>ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE, ACC_STATIC, ACC_FINAL</code>
     */
    public void Method(String methodName, Type returnType, int methodModifiers) throws ClassMakerException
    {
        DeclaredType declared = getDeclaredType(returnType);
        Method(methodName, declared, methodModifiers);
    }

    /**
     * Starts the declaration of a method with a <code>Class</code> representing the return type.
     * @param methodName the name of the method to be generated
     * @param returnType the return <code>Type</code> for the method
     * @param methodModifiers appropriate modifiers include:
     * <code>ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE, ACC_STATIC, ACC_FINAL</code>
     */
    public void Method(String methodName, DeclaredType returnType, int methodModifiers) throws ClassMakerException
    {
        checkMethodModifiers(methodModifiers);
        if (method != null)
            throw createException("ClassMaker.MissingEndForPreviousMethod_1", method.toString());
        method = new MakerMethod(getClassType(), methodName, returnType, (short)methodModifiers);
        
        // Adjust the slots used to account for the this pointer, if present.
        maxLocalSlots = method.isStatic() ? 0 : getDeclaredType().getSlotSize();
        
        // Determine whether the class declares a constructor.
        if (INIT.equals(methodName))
            hasConstructor = true;
    }

    /**
     * Begins the body of a method.
     * All local variables declared before <code>Begin()</code> are the formal parameters
     * of the method.
     */
    void BeginMethod() throws ClassMakerException
    {
        if (method == null)
            throw createException("ClassMaker.NotInMethod");
        if (method.isAbstract())
            throw createException("ClassMaker.AbstractMethodCannotHaveBody_1", "Begin()");

        method.setFormalParams(createFormalParameters());

        if (getPass() == FIRST_PASS)
            method.setHasBody(false);
        else if (isForwardDeclared(method))
            removeMethod(method);
        addMethod(method);

        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            cfw.startMethod(method.getName(), method.getSignature(), method.getModifiers());
            if ((method.getModifiers() & ClassMaker.ACC_STATIC) == 0)
            {
                String classSignature = getClassSignature();
                cfw.addVariableDescriptor("this", classSignature, 0, 0, -1);
            }
        }
    }

    /**
     * Ends the body of a method.
     * Checks that the method body ends with a <code>Return</code> or <code>Throw</code>
     * statement.
     */
    void EndMethod() throws ClassMakerException
    {
        if (method.isAbstract())
            throw createException("ClassMaker.AbstractMethodCannotHaveBody_1", "End()");
        if (getClassFileWriter() != null)
        {
            // Check that Return has been called.
            if (!followsReturn)
                if (VOID_TYPE.equals(method.getReturnType()))
                    Return();
                else
                    throw createException("ClassMaker.ReturnOrThrowMustPrecedeEnd");

            // Local variable descriptors are used by the debugger.
            for (int i=0; i<localTable.size(); i++)
            {
                MakerField local = localTable.elementAt(i);
                if (local.getName() == null)
                    continue; // Skip anonymous local values
                cfw.addVariableDescriptor(local.getName(), local.getType().getSignature(), local.getStartPC(),
                                local.getSlot(), local.getEndPC());
            }

            markLineNumber(); // possibly add a new line number entry.

            cfw.add(ByteCode.NOP);
            cfw.stopMethod(maxLocalSlots);
        }

        // Exit method.
        method = null;
        localTable.clear();
    }

    /**
     * Begins a compound statement with its own scope.
     * <br/>
     * Local variables declared within this scope will be unaccessable when the scope is exited.
     * The compound statement may be labelled so it can be the target of a <code>Break</code> statement.
     * <pre>
          Begin();
            Declare("a", int.class);
            Set("a", Literal(2));
          End();
     * </pre>
     *
     * Delegates to <code>ScopeStatement.Begin</code>.
     * @return an interface to set a Label
     */
    public Labelled Begin() throws ClassMakerException
    {
        if (bottomStatement == null)
        {
            bottomStatement = new MethodBodyStatement();
            bottomStatement.Begin();
            return bottomStatement;
        }
        else
        {
            ScopeStatement stmt = new ScopeStatement();
            stmt.Begin();
            return stmt;
        }
    }

    /**
     * Ends the body of a method.
     * Checks that the method body ends with a <code>Return</code> or <code>Throw</code>
     * statement.
     * Delegates to <code>ScopeStatement.End</code>.
     */
    public void End() throws ClassMakerException
    {
        ScopeStatement stmt = topScopeStatement("ClassMaker.EndWithoutMatchingBegin");
        stmt.End();
    }

    /**
     * Adds a local variable or formal parameter to the list of scoped variables.
     * <br/>
     * Sets the start program counter and scope level. 
     * @param local the variable or parameter being added
     * @param scope the current nesting level of scoped code blocks
     */
    private void addToScope(MakerField local, int scope)
    {
        local.setStartPC(cfw.getCurrentCodeOffset());
        local.setEndPC(-1);
        local.setScopeLevel(scope);
    }

    /**
     * Limits the visibility of all local variables that were added at the given scope level.
     * <br/>
     * Assigns the program counter as the variable goes out of scope and marks the variable as out of scope.
     * Scope entries are added to the method as it is completed.
     * @param scope the level of nesting of the current scoped code block 
     */
    void exitScope(int scope)
    {
        if (getClassFileWriter() != null)
        {
	        // Local variable descriptors are used by the debugger.
	        for (int i=localTable.size()-1; i>=0; i--)
	        {
	            MakerField local = localTable.elementAt(i);
	            if (local.getName() == null)
	                continue; // Skip anonymous local variables
	            if (!local.isInScope())
	                continue; // Skip out of scope variables
	            if (local.getScopeLevel() < scope)
	                break;    // Stop when field is in wider scope
	            local.setEndPC(cfw.getCurrentCodeOffset());
	            local.setInScope(false);
	        }
        }
    }

    /**
     * Ends a method that does not have a body.
     * </br>
     * This may be because the method is abstract or because it is being forward declared
     * so that only one pass is necessary to parse the source file.
     */
    public void Forward() throws ClassMakerException
    {
        method.setFormalParams(createFormalParameters());
        if (getPass() == FIRST_PASS)
        {
            if (methods.indexOf(method) >= 0 || constructors.indexOf(method) >= 0)
                throw createException("ClassMaker.MethodDeclaredMoreThanOnce_1", method.toString());
        } else if (isForwardDeclared(method))
            removeMethod(method);
        method.setHasBody(false);
        addMethod(method);
        if (getClassFileWriter() != null)
        {
            if (method.isAbstract() || ClassMaker.isInterface(getClassType()))
            {
                addAbstractMethod();
            }
        }
        method = null;
        localTable.clear();
    }
    
    /**
     * Adds an abstract method to the generated class.
     * </br>
     * An abstract method cannot have a body so must be forward declared.
     *
     */
    void addAbstractMethod()
    {
        markLineNumber(); // possibly add a new line number entry.
        cfw.startMethod(method.getName(), method.getSignature(), method.getModifiers());
    }

    /**
     * Determines whether the current method is forward declared.
     * @param method the current method
     * @return true if the method has been forward declared or false if the method has not been declared
     * @throws ClassMakerException if the current method has been declared more than once
     */
    boolean isForwardDeclared(MakerMethod method) throws ClassMakerException
    {
        int index;
        if ((index = methods.indexOf(method)) >= 0)
        {
            MakerMethod forwardMethod = methods.elementAt(index);
            if (forwardMethod.hasBody() == false)
                return true;
            throw createException("ClassMaker.MethodDeclaredMoreThanOnce_1", method.toString());
        }
        else if ((index = constructors.indexOf(method)) >= 0)
        {
            MakerMethod forwardMethod = constructors.elementAt(index);
            if (forwardMethod.hasBody() == false)
                return true;
            throw createException("ClassMaker.MethodDeclaredMoreThanOnce_1", method.toString());
        }
        return false;
    }

    /**
     * Adds the given method to the class.
     * @param method the method to add
     */
    void addMethod(MakerMethod method)
    {
        if (INIT.equals(method.getName()))
            constructors.add(method);
        else
            methods.add(method);
    }

    /**
     * Removes the given method from the class.
     * </br>
     * Only used to remove methods that have been forward declared.
     * @param method the method to remove
     */
    void removeMethod(MakerMethod method)
    {
        if (INIT.equals(method.getName()))
            constructors.remove(method);
        else
            methods.remove(method);
    }

    /**
     * Checks whether a method is currently being generated.
     * @return true if generating a method
     */
    boolean isInMethod()
    {
        return method != null;
    }

    /**
     * Checks whther a method is currently being generated.
     * @return true if generating a method
     */
    boolean isInBody()
    {
        return bottomStatement != null;
    }

    /**
     * Creates a list of formal parameters for the method currently being generated.
     * @return an array of formal parameter <code>Type</code>s
     */
    DeclaredType[] createFormalParameters()
    {
        int size = localTable.size();
        DeclaredType[] params = new DeclaredType[size];
        for (int index = 0; index < size; index++)
            params[index] = lookupLocal(index).getDeclaredType();
        return params;
    }

    //################ Class Instantiation #########################
    /**
     * Creates a new instance of the given <code>Class</code>.
     * @param javaClass the <code>Class</code> to be instantiated
     * @return an <code>Initialiser</code> for the instance
     */
    public Initialiser New(Class javaClass) throws ClassMakerException
    {
        String className = classToName(javaClass);
        return New(className);
    }

    /**
     * Creates a new instance of the named class.
     * @param className the name of the class to instantiate
     * @return an <code>Initialiser</code> for the instance
     */
    public Initialiser New(String className) throws ClassMakerException
    {
        DeclaredType declared = null;
        if (getClassFileWriter() != null)
            declared = stringToDeclaredClass(className);
        return New(declared);
    }

    /**
     * Creates a new instance of the class.
     * @param declared a declared type represents the type of class
     * @return an <code>Initialiser</code> for the instance
     */
    public Initialiser New(DeclaredType declared) throws ClassMakerException
    {
        ClassType type = null;
        markLineNumber(); // possibly add a new line number entry.
        if (getClassFileWriter() != null)
        {
            type = declared.getClassType();
            cfw.add(ByteCode.NEW, toSlashName(type.getName()));
        }
        return new InitialiserImpl(type);
    }

    /**
     * Initialiser for a class that has just been instantiated.
     * </br>
     * An instance of this class is returned when <code>New</code> is called.
     * It can be used to call a constructor on the new instance.
     */
    public interface Initialiser
    {
        /**
         * Calls a constructor from the base class that is appropriate for the actual parameters.
         * </br>
         * Uses <code>MethodResolver</code> to determine the appropriate constructor for the
         * actual parameters and invokes that constructor using the reference to <code>super</code>
         * on top of the stack. The first parameter to this call must be <code>Super()</code>.
         * @param actualParameters the types of the actual parameters in the call stack
         * @return the return type of the called method
         */
        public ClassType Init(CallStack actualParameters);
        
    }
    
    /**
     * Initialiser for a class that has just been instantiated.
     * </br>
     * An instance of this class is returned when <code>New</code> is called.
     * It can be used to call a constructor on the new instance.
     */
    public class InitialiserImpl implements Initialiser
    {
        final ClassType classType;

        /**
         * Constructor that takes the type of class being initialised.
         * @param classType
         */
        InitialiserImpl(ClassType classType)
        {
            this.classType = classType;
            if (getClassFileWriter() != null)
            {
                dup(classType);
            }
        }

        /**
         * Calls a constructor from the base class that is appropriate for the actual parameters.
         * </br>
         * Uses <code>MethodResolver</code> to determine the appropriate constructor for the
         * actual parameters and invokes that constructor using the reference to <code>super</code>
         * on top of the stack. The first parameter to this call must be <code>Super()</code>.
         * @param actualParameters the types of the actual parameters in the call stack
         * @return the return type of the called method
         */
        public ClassType Init(CallStack actualParameters)
        {
            ClassMaker.this.Init(classType, actualParameters);
            return classType;
        }
    }

    /**
     * Calls a constructor from the base class that is appropriate for the actual parameters.
     * </br>
     * Uses <code>MethodResolver</code> to determine the appropriate constructor for the
     * actual parameters and invokes that constructor using the reference to <code>super</code>
     * on top of the stack. The first parameter to this call must be <code>Super()</code>.
     * @param classType the type of the base class
     * @param actualParameters the types of the actual parameters in the call stack
     */
    public void Init(ClassType classType, CallStack actualParameters) throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            MakerMethod method = resolveConstructor(classType, actualParameters);
            checkAccessDenied(classType, method);
            markLineNumber(); // possibly add a new line number entry.
            invokeSpecial(classType, method);
        }
    }

    //################## Method calls ##########################
    /**
     * Calls a static method in the given class that is appropriate for the actual parameters.
     * </br>
     * Uses <code>MethodResolver</code> to determine the appropriate method for the actual parameters and
     * then statically invokes the method.
     * @param javaClass the <code>Class<code> containing the method to be invoked
     * @param methodName the name of the method to call
     * @param actualParameters the types of the actual parameters in the call stack
     * @return the return type of the called method
     */
    public Type Call(Class javaClass, String methodName, CallStack actualParameters) throws ClassMakerException
    {
        String className = classToName(javaClass);
        return Call(className, methodName, actualParameters);
    }

    /**
     * Calls a static method in the named class that is appropriate for the actual parameters.
     * </br>
     * Uses <code>MethodResolver</code> to determine the appropriate method for the actual parameters and
     * then statically invokes the method.
     * @param className a fully qualified classname
     * @param methodName the name of the method to call
     * @param actualParameters the types of the actual parameters in the call stack
     * @return the return type of the called method
     */
    public Type Call(String className, String methodName, CallStack actualParameters) throws ClassMakerException
    {
        DeclaredType declaredType = stringToDeclaredClass(className);
        if (actualParameters == null)
            actualParameters = Push();
        actualParameters.setMethodName(methodName);
        return methodCall(declaredType.getType(), actualParameters, true);
    }

    /**
     * Calls a method from the class instance on top of the stack that is appropriate for the actual parameters.
     * </br>
     * Uses <code>MethodResolver</code> to determine the appropriate method for the actual parameters and
     * then determines whether the method is private, static, virtual or an interface method and
     * uses the appropriate invocation.
     * @param type the type of the reference on top of the stack
     * @param methodName the name of the method to call
     * @param actualParameters the types of the actual parameters in the call stack
     * @return the return type of the called method
     */
    public Type Call(Type reference, String methodName, CallStack actualParameters) throws ClassMakerException
    {
        if (actualParameters == null)
            actualParameters = Push();
        actualParameters.setMethodName(methodName);
        return methodCall(reference, actualParameters, false);
    }
    
    /**
     * Calls a method from the class instance on top of the stack that is appropriate for the actual parameters.
     * </br>
     * Uses <code>MethodResolver</code> to determine the appropriate method for the actual parameters and
     * then determines whether the method is private, static, virtual or an interface method and
     * uses the appropriate invocation.
     * @param reference the Type of the reference on top of the stack
     * @param actualParameters the Types of the actual parameters in the call stack
     * @return the return type of the called method
     */
    public Type Call(Type reference, CallStackMaker actualParameters) throws ClassMakerException
    {
        return methodCall(reference, actualParameters, false);
    }
    
    /**
     * Calls a method from the class instance on top of the stack that is appropriate for the actual parameters.
     * </br>
     * Uses <code>MethodResolver</code> to determine the appropriate method for the actual parameters and
     * then determines whether the method is private, static, virtual or an interface method and
     * uses the appropriate invocation.
     * @param type the type of the reference on top of the stack
     * @param actualParameters the types of the actual parameters in the call stack
     * @return the return type of the called method
     */
    private Type methodCall(Type type, CallStack actualParameters, boolean isStatic) throws ClassMakerException
    {
        if (getClassFileWriter() == null)
            return null;
        if (!isClass(type))
            throw createException("ClassMaker.TypeIsNotAClass_1", type.getName());
        ClassType classType = type.toClass();
        MakerMethod method = resolveMethod(classType, actualParameters.getMethodName(), actualParameters);
        // Method must be static if reference was a declared type.
        if (isStatic && !method.isStatic())
            throw createException("ClassMaker.StaticCallToNonStaticMethod_2",
                    method.toString(), method.getClassType().getName());
        checkAccessDenied(classType, method);
        markLineNumber(); // possibly add a new line number entry.
        if (classType.isInterface())
            invokeInterface(classType, method);
        else if (method.isStatic())
            invokeStatic(classType.getName(), method);
        else if (method.isPrivate())
            invokeSpecial(classType, method);
        else
            invokeVirtual(classType, method);
        return method.getReturnType().getType();
    }

    /**
     * Calls a virtual method in the class instance on top of the stack.
     * @param classType type of the class containing the method
     * @param method a descriptor of the resolved method
     */
    void invokeVirtual(ClassType classType, MakerMethod method)
    {
        String signature = method.getSignature();
        cfw.addInvoke(ByteCode.INVOKEVIRTUAL, toSlashName(classType.getName()), method.getName(), signature);
    }

    /**
     * Calls a method in the interface instance on top of the stack.
     * @param classType type of the interface containing the method
     * @param method a descriptor of the resolved method
     */
    void invokeInterface(ClassType classType, MakerMethod method)
    {
        String signature = method.getSignature();
        cfw.addInvoke(ByteCode.INVOKEINTERFACE, toSlashName(classType.getName()), method.getName(), signature);
    }

    /**
     * Calls a static method of the named class.
     * @param className a fully qualified classname
     * @param method a descriptor of the resolved method
     */
    void invokeStatic(String className, MakerMethod method)
    {
        String signature = method.getSignature();
        cfw.addInvoke(ByteCode.INVOKESTATIC, toSlashName(className), method.getName(), signature);
    }

    /**
     * Calls a private method or a method from the super class, in the class on top of the stack.
     * @param classType type of the class containing the method
     * @param method a descriptor of the resolved method
     */
    void invokeSpecial(ClassType classType, MakerMethod method)
    {
        String signature = method.getSignature();
        cfw.addInvoke(ByteCode.INVOKESPECIAL, toSlashName(classType.getName()), method.getName(), signature);
    }

    // Class relationships
    /**
     * Indicates that the class implements the interface represented by the given <code>Class</code>.
     * @param javaClass the <code>Class<code> of the implemented interface
     */
    public void Implements(Class javaClass) throws ClassMakerException
    {
        ClassType classType = classToClassType(javaClass);
        int mod = classType.getModifiers();
        if (!Modifier.isInterface(mod))
            throw createException("ClassMaker.CannotImplementClass", javaClass.getName());
        DeclaredType declared = getFactory().typeToDeclaredType(classType);
        implementsClassType(declared);
    }

    /**
     * Indicates that the class implements the named interface.
     * @param className the fully qualified class name
     */
    public void Implements(String className) throws ClassMakerException
    {
        DeclaredType declared = stringToDeclaredType(className);
        if (getPass() != ClassMaker.FIRST_PASS)
        {
            ClassType classType = declared.getClassType();
            if (declared.getClassType() == null)
            {
                throw createException("ClassMaker.NoClassTypeCalled_1", className);
            }
            int mod = classType.getModifiers();
            if (!Modifier.isInterface(mod))
                throw createException("ClassMaker.CannotImplementClass", classType.getName());
        }
        implementsClassType(declared);
    }

    /**
     * Indicates that the class implements the named interface.
     * @param classType the type of the interface
     */
    void implementsClassType(DeclaredType classType)
    {
        if (getClassFileWriter() != null)
        {
            cfw.addInterface(classType.getName());
        }
        if (getPass() != SECOND_PASS)
        {
            interfaces.add(classType);
            // Must keep interfaces synchronised in case this class type is assigned.
            getClassType().setInterfaces(getDeclaredInterfaces());
        }
    }

    /**
     * Throws an <code>Exception</code>.
     * </br>
     * The last statement of a method must be either <code>Return</code> or <code>Throw</code>.
     * @param exception type exception being thrown
     */
    public void Throw(Type exception) throws ClassMakerException
    {
        if (getClassFileWriter() == null)
            return;

        if (!isClass(exception))
            throw createException("ClassMaker.CannotThrowType_1", exception.getName());

        if (!getFactory().getAssignmentConversion().isConvertable(exception, ClassMaker.THROWABLE_TYPE))
            throw createException("ClassMaker.ClassCannotBeThrown_1", exception.getName());

        markLineNumber(); // possibly add a new line number entry.
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("Throw("+exception+");");
        cfw.add(ByteCode.ATHROW);

        // Throwing an exception is the equivalent of calling return;
        followsReturn = true;
    }

    /**
     * Returns from the current method.
     * </br>
     * The last statement of a method must be either <code>Return</code> or <code>Throw</code>.
     */
    public void Return() throws ClassMakerException
    {
        if (getClassFileWriter() == null)
            return;
        if (isDebugCode())
        	cfw.setDebugComment("Return();");

        // Call any finally subroutines before returning
        Statement stmt = topStatement();
        if (stmt == null || stmt.jumpToTarget(RETURN, null) == null)
            throw createException("ClassMaker.ReturnWhileNotInAMethod");

        if (!VOID_TYPE.equals(method.getReturnType()))
            throw createException("ClassMaker.MethodMustReturnType_2", method.getName(), method.getReturnType().getName());

        markLineNumber(); // possibly add a new line number entry.
        cfw.add(ByteCode.RETURN);

        // Indicate that return has been called.
        // This flag is reset by markLineNumber();
        followsReturn = true;
    }

    /**
     * Returns with the value on top of the stack.
     * </br>
     * Promotes the value to the return type using <code>AssignmentConversion</code>.
     * The last statement of a method must be either <code>Return</code> or <code>Throw</code>.
     */
    public void Return(Type type) throws ClassMakerException
    {
        if (getClassFileWriter() == null)
            return;
        if (isDebugCode())
        	cfw.setDebugComment("Return(" + type + ");");

        // Call any finally subroutines before returning
        Statement stmt = topStatement();
        if (stmt == null || stmt.jumpToTarget(RETURN, null) == null)
            throw createException("ClassMaker.ReturnWhileNotInAMethod");

        if (VOID_TYPE.equals(method.getReturnType()))
            throw createException("ClassMaker.MethodIsVoidSoMustNotReturnAValue_1", method.getName());

        if (VOID_TYPE.equals(type))
            throw createException("ClassMaker.CannotReturnTypeVoid");

        // possibly add a new line number entry.
        markLineNumber();
        Type returnType = method.getReturnType().getType();
        if (getFactory().getAssignmentConversion().isConvertable(type, returnType))
            type = getFactory().getAssignmentConversion().convertTo(this, type, returnType);
        else
            throw createException("ClassMaker.MethodReturnsTypeSoCannotReturnType_3",
                            method.getName(), method.getReturnType().getName(), type.getName());

        // Indicate that return has been called.
        // This flag is reset by markLineNumber();
        followsReturn = true;

        if (isClass(type))
        {
            cfw.add(ByteCode.ARETURN);
            return;
        }
        else if (isPrimitive(type))
        {
            switch (type.toPrimitive().index)
            {
            case PrimitiveType.BOOLEAN_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.IRETURN);
                return;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LRETURN);
                return;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FRETURN);
                return;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DRETURN);
                return;
            }
        }
        // Should not get here.
        throw new IllegalArgumentException("Cannot return type" + type.getName());
    }

    /**
     * Creates an empty call stack.
     * An empty stack can be used when calling methods that have no formal parameters.
     * @return an empty call stack
     */
    public CallStack Push() throws ClassMakerException
    {
        return new CallStackMaker(this);
    }

    /**
     * Pushes an actual parameter onto a call stack.
     * </br>
     * Creates a <code>CallStack</code> and pushes the given parameter onto it.
     * The <code>CallStack</code> instance can be used to push more actual parameters
     * by "daisy chaining" <code>Push</code> calls.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>process(1, a);<code></td>
     * <td><code>Call(This(), "process", Push(Literal(1)).Push(Get("a")));</code></td></tr>
     * </table>
     * @param param type of the actual parameter
     * @return a <code>CallStack</code> which can be used to <code>Push</code> more actual parameters types
     */
    public CallStack Push(Type param) throws ClassMakerException
    {
        CallStack stack = Push();
        if (param != null)
            stack.Push(param);
        return stack;
    }

    // Special references
    /**
     * Pushes a reference to <code>this</code> class onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>this.process();<code></td>
     * <td><code>Call(This(), "process", null);</code></td></tr>
     * </table>
     * @return the type for this class
     */
    public ClassType This() throws ClassMakerException
    {
        if (log.isLoggable(Level.FINE))
            log.finest("push this");
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("This();");
            cfw.addLoadThis();
        }
        return thisClassType;
    }

    /**
     * Pushes a reference to this class's <code>super</code> class onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>super();<code></td>
     * <td><code>Init(Super(), null);</code></td></tr>
     * <tr><td><code>super.process();<code></td>
     * <td><code>Call(Super(), "process", null);</code></td></tr>
     * </table>
     * @return the type for the super class
     */
    public ClassType Super() throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("Super();");
            cfw.addLoadThis();
        }
        return superClass.getClassType();
    }

    /**
     * Pushes <code>null</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>null<code></td>
     * <td><code>Null()</code></td></tr>
     * </table>
     * @return the type for <code>null</code>
     */
    public ClassType Null() throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("Null();");
            cfw.add(ByteCode.ACONST_NULL);
        }
        return NULL_TYPE;
    }

    // Literals
    /**
     * Pushes a literal <code>double</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>234.56789D<code></td>
     * <td><code>Literal(234.56789D)</code></td></tr>
     * </table>
     * @param value the double to be pushed onto the stack
     * @return the type for <code>double</code>
     */
    public PrimitiveType Literal(double value) throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("Literal(" + value + ");");
            cfw.addPush(value);
        }
        return DOUBLE_TYPE;
    }

    /**
     * Pushes a literal <code>float</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>223.345F<code></td>
     * <td><code>Literal(123.456F)</code></td></tr>
     * </table>
     * @param value the float to be pushed onto the stack
     * @return the type for <code>float</code>
     */
    public PrimitiveType Literal(float value) throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("Literal(" + value + ");");
            cfw.addPush(value);
        }
        return FLOAT_TYPE;
    }

    /**
     * Pushes a literal <code>long</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>2000000L<code></td>
     * <td><code>Literal(2000000L)</code></td></tr>
     * </table>
     * @param value the long to be pushed onto the stack
     * @return the type for <code>long</code>
     */
    public PrimitiveType Literal(long value) throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("Literal(" + value + ");");
            cfw.addPush(value);
        }
        return LONG_TYPE;
    }

    /**
     * Pushes a literal <code>int</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>200<code></td>
     * <td><code>Literal(200)</code></td></tr>
     * </table>
     * @param value the int to be pushed onto the stack
     * @return the type for <code>int</code>
     */
    public PrimitiveType Literal(int value) throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("Literal(" + value + ");");
            cfw.addPush(value);
        }
        // Return the most specific type.
        // This will be promoted to an INT by numeric promotion.
        if (Byte.MIN_VALUE <= value && value <= Byte.MAX_VALUE)
            return BYTE_TYPE;
        else if (Short.MIN_VALUE <= value && value <= Short.MAX_VALUE)
            return SHORT_TYPE;
        else
            return INT_TYPE;
    }

    /**
     * Pushes a literal <code>char</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>'Z'<code></td>
     * <td><code>Literal('Z')</code></td></tr>
     * </table>
     * @param value the char to be pushed onto the stack
     * @return the type for <code>char</code>
     */
    public PrimitiveType Literal(char value) throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("Literal(\'" + value + "\');");
            cfw.addPush(value);
        }
        return CHAR_TYPE;
    }

    /**
     * Pushes a literal <code>byte</code> value onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>(byte)200<code></td>
     * <td><code>Literal((byte)200)</code></td></tr>
     * </table>
     * @param value the byte to be pushed onto the stack
     * @return the type for <code>byte</code>
     */
    public PrimitiveType Literal(byte value) throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("Literal(" + value + ");");
            cfw.add(ByteCode.BIPUSH, value); // constant byte operand
        }
        return BYTE_TYPE;
    }

    /**
     * Pushes a literal <code>short</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>(short)32000<code></td>
     * <td><code>Literal((short)32000)</code></td></tr>
     * </table>
     * @param value the short to be pushed onto the stack
     * @return the type for <code>short</code>
     */
    public PrimitiveType Literal(short value) throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("Literal(" + value + ");");
            cfw.add(ByteCode.SIPUSH, value); // constant short operand
        }
        return SHORT_TYPE;
    }

    /**
     * Pushes a literal <code>boolean</code> value onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>true<code></td>
     * <td><code>Literal(true)</code></td></tr>
     * </table>
     * @param value the boolean value to be pushed onto the stack
     * @return the type for <code>boolean</code>
     */
    public PrimitiveType Literal(boolean value) throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("Literal(" + value + ");");
            cfw.addPush(value); // constant boolean operand
        }
        return BOOLEAN_TYPE;
    }

    /**
     * Pushes a literal <code>String</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>"Hello World"<code></td>
     * <td><code>Literal("Hello World")</code></td></tr>
     * </table>
     * @param value the string to be pushed onto the stack
     * @return the type for <code>String</code>
     */
    public ClassType Literal(String value) throws ClassMakerException
    {
        if (getClassFileWriter() != null)
        {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode())
            	cfw.setDebugComment("Literal(" + value + ");");
            cfw.addLoadConstant(value);
        }
        return STRING_TYPE;
    }


    //#################### Getters and Setters ######################
    /**
     * Assigns the value on top of the stack to a local variable or formal parameter and
     * leaves the value on the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>x = i = a;<code></td>
     * <td><code>Eval(Assign("x", Assign("i", Get("a"))));</code></td></tr>
     * </table>
     * Performs assignment conversion on the value before
     * assigning it. The unconverted value is left on top of the stack.
     * @param name name of the local variable
     * @param type type of the value being set
     * @return type of the value on the stack
     */
    public Type Assign(String name, Type type) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    	    cfw.setDebugComment("Assign(" + name + ", " + type + ")");
        dup(type);
        Set(name, type);
        return type;
    }

    /**
     * Assigns a value to a member variable and leaves the value on the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>x = obj.i = a;<code></td>
     * <td><code>Eval(Assign("x", Assign(Get("obj"), "i", Get("a"))));</code></td></tr>
     * </table>
     * The value is subject to assignment conversion before it is assigned.
     * The unconverted value is left on the stack.
     * @param refType the type of the class containing the variable
     * @param fieldName the name of the member variable
     * @param valueType the type of the value to be set
     * @return the type of the unconverted value left on the stack
     */
    public Type Assign(Type refType, String fieldName, Type valueType) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("Assign(" + refType + ", " + fieldName + ", " + valueType + ")");
        // Duplicate the value on top of the stack and put it under the reference.
        // Stack: reference, value
        dupunder(refType, valueType);
        // Stack: value, reference, value
        Set(refType, fieldName, valueType);
        // Stack: value
        return valueType;
    }

    /**
     * Assigns a value to a static member field, leaving the value on top of the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>MyClass.i = a;<code></td>
     * <td><code>Eval(Assign("MyClass", "i", Get("a")));</code></td></tr>
     * </table>
     * The value is subject to assignment conversion before it is assigned.
     * The unconverted value is left on top of the stack.
     * @param className the short or fully qualified name of the class
     * @param fieldName the name of the static member variable
     * @param valueType the type of the value to be set
     * @return type of the value on top of the stack
     */
    public Type Assign(String className, String fieldName, Type type) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("Assign(" + className + ", " + fieldName + ", " + type + ")");
        dup(type);
        Set(className, fieldName, type);
        return type;
    }


    /**
     * Sets the value on top of the stack to the named local variable or formal parameter.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>i = a;<code></td>
     * <td><code>Set("i", Get("a"));</code></td></tr>
     * </table>
     * Performs assignment conversion on the value on top of the stack before
     * storing it in the named local variable.
     * @param name name of the local variable
     * @param type type of the value being set
     * @return <code>ClassMaker.VOID_TYPE</code>
     */
    public Type Set(String name, Type valueType) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
        if (isDebugCode())
        	cfw.setDebugComment("Set(" + name + ", " + valueType + ")");
        markLineNumber(); // possibly add a new line number entry.

        MakerField field = Find(name);
        Type varType = field.getType();
        if (getFactory().getAssignmentConversion().isConvertable(valueType, varType))
            valueType = getFactory().getAssignmentConversion().convertTo(this, valueType, varType);
        else
            throw createException("ClassMaker.CannotAssignToLocalVariableOfType_3",
                            valueType.getName(), field.getName(), varType.getName());

        storeLocal(field, valueType);
        return VOID_TYPE;
    }

    /**
     * Sets a member variable to the value.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>obj.i = a;<code></td>
     * <td><code>Eval(Set(Get("obj"), "i", Get("a")));</code></td></tr>
     * </table>
     * The value is subject to assignment conversion before it is set.
     * @param type the type of the class containing the variable
     * @param fieldName the name of the member variable
     * @param valueType the type of the value to be set
     * @return a <code>Type</code> representing <code>void</code>
     */
    public Type Set(Type reference, String fieldName, Type valueType) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("Set(" + reference + ", " + fieldName + ", " + valueType + ")");
        MakerField field = Find(reference, fieldName);
        Type fieldType = field.getType();
        if (fieldType == null)
            throw new NullPointerException("Type for field " + fieldName + " cannot be determined.");
        if (!getFactory().getAssignmentConversion().isConvertable(valueType, fieldType))
        {
            String classField = field.getClassType().getName() + '.' + field.getName();
            throw createException("ClassMaker.FieldOfTypeCannotBeAssignedType_3",
                            classField, fieldType.getName(), valueType.getName());
        }

        markLineNumber(); // possibly add a new line number entry.
        getFactory().getAssignmentConversion().convertTo(this, valueType, fieldType);

        String className = field.getClassType().getName();
        String signature = fieldType.getSignature();
        cfw.add(ByteCode.PUTFIELD, className, field.getName(), signature);
        return VOID_TYPE;
    }

    /**
     * Sets a static member field to the value.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>MyClass.i = a;<code></td>
     * <td><code>Set("MyClass", "i", Get("a"));</code></td></tr>
     * </table>
     * The value is subject to assignment conversion before it is set.
     * @param className the short or fully qualified name of the class
     * @param fieldName the name of the static member variable
     * @param valueType the type of the value to be set
     * @return a <code>Type</code> representing <code>void</code>
     */
    public Type Set(String className, String fieldName, Type valueType) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("Set(" + className + ", " + fieldName + ", " + valueType + ")");
        MakerField field = Find(className, fieldName);
        Type declaredType = field.getType();

        // FIXME - check that field is static
        if (!getFactory().getAssignmentConversion().isConvertable(valueType, declaredType))
            throw createException("ClassMaker.StaticFieldOfTypeCannotBeAssignedType_3",
                            field.getName(), declaredType.getName(), valueType.getName());

        markLineNumber(); // possibly add a new line number entry.
        getFactory().getAssignmentConversion().convertTo(this, valueType, declaredType);

        String signature = declaredType.getSignature();
        cfw.add(ByteCode.PUTSTATIC, field.getClassType().getName(), field.getName(), signature);
        return VOID_TYPE;
    }

    /**
     * Gets a value from a member variable.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>obj.i<code></td>
     * <td><code>Get(Get("obj"), "i");</code></td></tr>
     * </table>
     * @param reference the type of the class containing the variable
     * @param fieldName the name of the member variable
     * @return the type of the value left on the stack
     */
    public Type Get(Type reference, String fieldName) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("Get(" + reference + ", " + fieldName+ ")");
        MakerField field = Find(reference, fieldName);
        return loadField(field);
    }

    private Type loadField(MakerField field)
    {
        assertNotNull(field, "field");
        markLineNumber(); // possibly add a new line number entry.
        ClassType classType = field.getClassType();
        if (log.isLoggable(Level.FINE))
            log.finest("load " + classType.getName() + ", " + field.getName() + ", " + field.getType().getSignature());
        cfw.add(ByteCode.GETFIELD, classType.getName(), field.getName(), field.getType().getSignature());
        return field.getType();
    }
    
    /**
     * Gets a value from a static member variable.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>MyClass.i<code></td>
     * <td><code>Get("MyClass", "i");</code></td></tr>
     * </table>
     * @param className the short or fully qualified name of the class
     * @param fieldName the name of the static member variable
     * @return the type of the value left on the stack
     */
    public Type Get(String className, String fieldName) throws ClassMakerException
    { 
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    	    cfw.setDebugComment("Get(\"" + className + "\", " + fieldName+ ")");
        MakerField field = Find(className, fieldName);
        return loadStatic(field);
    }

    private Type loadStatic(MakerField field)
    {
        assertNotNull(field, "field");
        markLineNumber(); // possibly add a new line number entry.
        ClassType classType = field.getClassType();
        if (log.isLoggable(Level.FINE))
            log.finest("static load " + classType.getName() + ", " + field.getName() + ", " + field.getType().getSignature());
        cfw.add(ByteCode.GETSTATIC, classType.getName(), field.getName(), field.getType().getSignature());
        return field.getType();
    }
    
    /**
     * Gets a local variable or formal parameter by name.
     * @param name name of the local variable
     * @return type of the local variable
     */
    public Type Get(String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
        MakerField field = Find(name);
        if (isDebugCode())
        	cfw.setDebugComment("Get(" + name + ");");
        return loadLocal(field);
    }

    //##################### Member Field Methods. #####################

    /**
     * Finds a named field in the given class.
     * </br>
     * Delegates to <code>findMemberField</code> and throws an <code>Exception</code> if the field is not found.
     * @param reference should be a DeclaredType
     * @param name name of the member field
     * @return the <code>MakerField</code> corresponding to the given name
     * @throws ClassMakerException if the field is not found
     */
    public MakerField Find(Type reference, String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
        assertNotNull(reference, "reference");
        assertNotNull(name, "name");
        ClassType classType = reference.toClass();
        if (classType == null) // FIXME may not be required.
            throw createException("ClassMaker.TypeMustBeAClass_1", reference.getName());
        MakerField field = findField(classType, name);
        if (field == null)
            throw createException("ClassMaker.CannotFindMemberFieldInClass_2", classType.getName(), name);
        return field;
    }
    
    public DeclaredType findDeclaredType(String name)
    {
        assertNotNull(name, "name");
        // The alias table maps simple class names to ClassTypes.
        DeclaredType declared = getAliasMapDeclared(name);
        if (declared == null)
            declared = getPackageDeclared(name);
        if (declared == null)
            declared = getFactory().stringToDeclaredType(name);
        return declared;
    }
    
    /**
     * Finds a named field in the given class.
     * </br>
     * Delegates to <code>findMemberField</code> and throws an <code>Exception</code> if the field is not found.
     * @param classType type of the class
     * @param name name of the member field
     * @return the <code>MakerField</code> corresponding to the given name
     * @throws ClassMakerException if the field is not found
     */
    public MakerField Find(String className, String fieldName) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
        DeclaredType declared = stringToDeclaredClass(className); 
        ClassType classType = declared.getClassType();
        MakerField field = findField(classType, fieldName);
        if (field == null)
            throw createException("ClassMaker.CannotFindStaticFieldInClass_2", classType.getName(), fieldName);
        if (!field.isStatic())
            throw createException("ClassMaker.ClassVariableIsNotStatic_1", classType.getName() + "." + fieldName);
        return field;
    }
    
    /**
     * Finds a named field in the given class.
     * </br>
     * Delegates to <code>findMemberField</code> and throws an <code>Exception</code> if the field is not found.
     * @param classType type of the class
     * @param name name of the member field
     * @return the <code>MakerField</code> corresponding to the given name
     * @throws ClassMakerException if the field is not found
     */
    MakerField findField(ClassType classType, String name) throws ClassMakerException
    {
        MakerField field = null;
        if (getClassType().equals(classType))
        {
            field = findMemberField(name);
            if (field == null)
                field = getFactory().findMemberField(classType.getExtendsType(), name);
        }
        else
            field = getFactory().findMemberField(classType, name);
        if (field == null)
            throw createException("ClassMaker.CannotFindMemberFieldInClass_2", name, classType.getName());
        checkAccessDenied(classType, field);
        return field;
    }

    /**
     * Finds a member field declared in the class being generated.
     * @param name name of the member field
     * @return the <code>MakerField</code> corresponding to the given name
     */
    private MakerField findMemberField(String name)
    {
        for (int i = 0; i < fieldTable.size(); i++)
        {
            MakerField field = fieldTable.get(i);
            if (name.equals(field.getName()))
            {
                return fieldTable.get(i);
            }
        }
        return null;
    }

    /**
     * Adds a member field to the class being generated.
     * @param name name of the field
     * @param type type of the field
     * @param modifiers access modifiers
     * @return index of the field in <code>fieldTable</code>
     */
    int addMemberField(String name, DeclaredType declared, int modifiers)
    {
        checkFieldModifiers(modifiers);

       // DeclaredType declared = getDeclaredType(type);
        MakerField field = new MakerField(getClassType(), name, declared, modifiers);
        int index = fieldTable.size();
        fieldTable.add(field);
        return index;
    }

    //############### Local variable methods ##################

    /**
     * Finds a local variable in the method.
     * @param name the name of the variable
     * @return a <code>Field</code> that describes the variable
     */
    public MakerField Find(String name)
    {
        if (getClassFileWriter() == null) return null;
        checkInMethod();
        MakerField field = findLocalField(name);
        //MakerField field = findField(name);
        if (field == null)
            throw createException("ClassMaker.NoLocalCalled_1", name );
        return field;
    }

    /**
     * Gets a local variable or formal parameter by name.
     * @param name name of the local variable
     * @return type of the local variable
     */
    public MakerField findField(String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
        checkInMethod();
        MakerField field = findLocalField(name); // Search method variables
        if (field == null)
        {
            // Search fields declared in this class
            field = findMemberField(name); 
            if (field == null)
            {    
                // Search fields declared in base classes
                field = getFactory().findMemberField(getSuperClass().getClassType(), name);
            }
        }
        return field;
    }
    
    /**
     * Loads a value onto the stack from a local variable.
     * @param local the <code>Field</code> that describes the member variable
     * @return the type of the variable on top of the stack
     */
    Type loadLocal(MakerField local) throws ClassMakerException
    {
        if (getClassFileWriter() == null)
            return null;

        markLineNumber(); // possibly add a new line number entry.
        int slot = local.getSlot();
        Type type = local.getType();

        if (isClass(type))
            cfw.addALoad(slot);
        else if (isPrimitive(type))
        {
            switch (type.toPrimitive().index)
            {
            case PrimitiveType.BOOLEAN_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                cfw.addILoad(slot);
                break;
            case PrimitiveType.LONG_INDEX:
                cfw.addLLoad(slot);
                break;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.addDLoad(slot);
                break;
            case PrimitiveType.FLOAT_INDEX:
                cfw.addFLoad(slot);
                break;
            default:
                throw createException("ClassMaker.DontKnowHowToLoadType_1", type.getName());
            }
        }
        return type.getType();
    }

    /**
     * Sets the value on top of the stack to a local variable.
     * @param slot the slot in the stack frame that contains the variable
     * @param type type of the value on top of the stack
     */
    void storeLocal(MakerField field, Type type) throws ClassMakerException
    {
        if (getClassFileWriter() == null)
            return;

        int slot = field.getSlot();
        if (isClass(type))
        {
            cfw.addAStore(slot);
            return;
        }
        else if (isPrimitive(type))
        {
            switch (type.toPrimitive().index)
            {
            case PrimitiveType.BOOLEAN_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                cfw.addIStore(slot);
                return;
            case PrimitiveType.LONG_INDEX:
                cfw.addLStore(slot);
                return;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.addDStore(slot);
                return;
            case PrimitiveType.FLOAT_INDEX:
                cfw.addFStore(slot);
                return;
            }
        }
        // Should never get here.
        throw createException("ClassMaker.DontKnowHowToStoreType_1", type.getName());
    }

    /**
     * Adds a formal parameter or local variable to the method.
     * @param name name of the local variable
     * @param type type of the local variable
     * @param modifiers access modifiers for the variable
     * @return index into <code>localTable</code>
     */
    int addLocal(String name, DeclaredType declared, int modifiers)
    {
        MakerField field = new MakerField(name, declared, modifiers);
        field.setSlot(maxLocalSlots);
        field.setScopeLevel(getScopeLevel());
        // Adjust the number of slots used.
        maxLocalSlots += declared.getSlotSize();
        if (getClassFileWriter() != null)
            field.setStartPC(cfw.getCurrentCodeOffset());
        int index = localTable.size();
        localTable.add(field);
        return index;
    }

    /**
     * Finds a local variable in the method.
     * @param name the name of the variable
     * @return a <code>Field</code> that describes the variable
     */
    MakerField findLocalField(String name)
    {
        for (int i=localTable.size()-1; i>=0; i--)
        {
            MakerField local = localTable.get(i);
            if (!local.isInScope())
                continue; // Skip locals that are out of scope
            if (name.equals(local.getName()))
            {
                return local;
            }
        }
        return null;
    }

    private void initLocal(MakerField field) 
    {
    	Type type = field.getType();
        int slot = field.getSlot();
        if (isClass(type))
        {
            cfw.add(ByteCode.ACONST_NULL);
            cfw.addAStore(slot);
            return;
        }
        else if (isPrimitive(type))
        {
            switch (type.toPrimitive().index)
            {
            case PrimitiveType.BOOLEAN_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
            	cfw.add(ByteCode.ICONST_0);
                cfw.addIStore(slot);
                return;
            case PrimitiveType.LONG_INDEX:
            	cfw.add(ByteCode.LCONST_0);
                cfw.addLStore(slot);
                return;
            case PrimitiveType.DOUBLE_INDEX:
            	cfw.add(ByteCode.DCONST_0);
                cfw.addDStore(slot);
                return;
            case PrimitiveType.FLOAT_INDEX:
            	cfw.add(ByteCode.FCONST_0);
                cfw.addFStore(slot);
                return;
            }
        }
        // Should never get here.
        throw createException("ClassMaker.DontKnowHowToStoreType_1", type.getName());
    }

//    /** 
//     * Get the maximum local slots used by this method.
//     * <br/>
//     * This value is required when creating a stack frame.
//     * @return the maximum local slots used by the method
//     */
//    private short getMaxLocalSlots()
//    {
//    	return maxLocalSlots;
//    }
//    
//    //############# Variable declarations ################

    /**
     * Declares a local variable or member field using a java class descriptor.
     * </br>
     * This method is used to declare all variables. The variable will be a
     * class member, formal parameter or local variable depending upon where
     * the <code>declare</code> method is called.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code><pre>
    class Process
    {
        public int       c1;
        protected String c2;
        private int      c3;
        int              c4;
        public static String s1;   &nbsp;

        public void process(
            String p1,
            final int p2 )
        {
            String l1;
            volatile int l2;
        }
    }
     * </pre><code></td>
     * <td><code><pre>
    class ProcessMaker extends ClassMakerBase {
    public void code() {
        Declare("c1", int.class, ACC_PUBLIC);
        Declare("c1", String.class, ACC_PROTECTED);
        Declare("c1", int.class, ACC_PRIVATE);
        Declare("c1", int.class, 0);
        Declare("s1", String.class, ACC_PUBLIC | ACC_STATIC);   &nbsp;

        Method("process", void.class, ACC_PUBLIC);
            Declare("p1", String.class, 0);
            Declare("p2", int.class, ACC_FINAL);
        Begin();
            Declare("l1", String.class, 0);
            Declare("l2", int.class, ACC_VOLATILE);
        End();
    }
       </pre></code></td></tr>
     * </table>
     * @param name the name of the variable
     * @param javaClass a class that describes the type of the variable
     * @param modifiers bitmask of variable modifiers
     */
    public void Declare(String name, Class javaClass, int modifiers) throws ClassMakerException
    {
        Type type = getFactory().classToType(javaClass);
        Declare(name, type, modifiers);
    }

    /**
     * Declares a local variable or member field using a java class descriptor.
     * </br>
     * This method is used to declare all variables. The variable will be a
     * class member, formal parameter or local variable depending upon where
     * the <code>declare</code> method is called.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code><pre>
    class Process
    {
        public int       c1;
        protected String c2;
        private int      c3;
        int              c4;
        public static String s1;   &nbsp;

        public void process(
            String p1,
            final int p2 )
        {
            String l1;
            volatile int l2;
        }
    }
     * </pre><code></td>
     * <td><code><pre>
    class ProcessMaker extends ClassMakerBase {
    public void code() {
        Declare("c1", "int", ACC_PUBLIC);
        Declare("c1", "String", ACC_PROTECTED);
        Declare("c1", "int", ACC_PRIVATE);
        Declare("c1", "int", 0);
        Declare("s1", "String", ACC_PUBLIC | ACC_STATIC);   &nbsp;

        Method("process", void.class, ACC_PUBLIC);
            Declare("p1", "String", 0);
            Declare("p2", "int", ACC_FINAL);
        Begin();
            Declare("l1", "String", 0);
            Declare("l2", "int", ACC_VOLATILE);
        End();
    }
       </pre></code></td></tr>
     * </table>
     * @param name the name of the variable
     * @param typeName the name of the type of the variable
     * @param modifiers bitmask of variable modifiers
     */
    public void Declare(String name, String typeName, int modifiers) throws ClassMakerException
    {
        DeclaredType type = stringToDeclaredType(typeName);
        Declare(name, type, modifiers);
    }

    /**
     * 
     * @param name the name of the variable
     * @param type
     * @param modifiers bitmask of variable modifiers
     */
    public void Declare(String name, DeclaredType type, int modifiers) throws ClassMakerException
    {
        declareVariable(name, type, modifiers);
    }

    /**
     * Declares a local variable or member field using a <code>Type</code>.
     * </br>
     * This version of <code>Declare</code> may be used when there is no
     * class descriptor for the type.
     * The first pass of a two pass compiler will produce a <code>Type</code>,
     * but the <code>Class</code> will not be available until after the second pass.
     * The <code>Type</code> can be used to declare Classes during the first pass.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code><pre>
        public OtherClass x;
     * </pre><code></td>
     * <td><code><pre>
        Type otherClass = findClass("au.com.Illyrian.OtherClass");
        Declare("x", otherClass, ACC_PUBLIC);
       </pre></code></td></tr>
     * </table>
     * @param name the name of the variable
     * @param type the type of the variable
     * @param modifiers bitmask of variable modifiers
     */
    public void Declare(String name, Type type, int modifiers) throws ClassMakerException
    {
        DeclaredType declared = getDeclaredType(type);
        declareVariable(name, declared, modifiers);
    }
    
    private  void declareVariable(String name, DeclaredType declared, int modifiers) throws ClassMakerException
    {
        if (getPass() != FIRST_PASS)
        {
            Type type = declared.getType();
            if (VOID_TYPE.equals(type) || NULL_TYPE.equals(type))
                throw createException("ClassMaker.CannotDeclareType_1", declared.getName());
        }
        if (!isInMethod())
        {   // Class Member Field
            MakerField field = findMemberField(name);
            if (getPass() != SECOND_PASS)
            {
            	if (field != null)
            	    throw createException("ClassMaker.DuplicateMemberFieldDeclaration_1", name);
                addMemberField(name, declared, modifiers);
            }
            if (getClassFileWriter() != null)
            {
                cfw.addField(name, declared.getSignature(), (short) modifiers);
            }
        }
        else
        {   // Local variable or parameter
            if (getPass() != SECOND_PASS && findLocalField(name)!= null)
                throw createException("ClassMaker.DuplicateLocalVariableDeclaration_1", name);
            addLocal(name, declared, modifiers);
            if (getClassFileWriter() != null)
            {
                MakerField local = findLocalField(name);
                addToScope(local, getScopeLevel());
                if (isInBody())
                {
                    if (isDebugCode())
                        cfw.setDebugComment("initialise local " + name);
                    initLocal(local);
                }
            }
        }
    }
    
    /**
     * The nesting level of the current scoped code block.
     * @return the nesting level of the current scoped code block
     */
    int getScopeLevel()
    {
        if (statementStack == null)
            return 1;
        else
            return statementStack.getScopeLevel();
    }

    //################### Casting methods. ##################
    /**
     * Casts a reference from one type to another.
     * </br>
     * Performs a casting conversion between the source and target types.
     * The short or fully qualified name of the target class may be used.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>(Runnable)a<code></td>
     * <td><code>Cast(Get("a"), "java/lang/Runnable")</code></td></tr>
     * <tr><td><code>(String)null<code></td>
     * <td><code>Cast(Null(), "String")</code></td></tr>
     * </table>
     * @param source the type of the reference on top of the stack
     * @param target the type into which to cast
     * @return the target type
     */
    public Type Cast(Type source, String target) throws ClassMakerException
    {
        DeclaredType makerType = stringToDeclaredType(target);
        return Cast(source, makerType);
    }

    /**
     * Casts a reference from one type to another.
     * </br>
     * Performs a casting conversion between the source and target types.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>(Runnable)a<code></td>
     * <td><code>Cast(Get("a"), Runnable.class)</code></td></tr>
     * <tr><td><code>(String)null<code></td>
     * <td><code>Cast(Null(), String.class)</code></td></tr>
     * </table>
     * @param source the type of the reference on top of the stack
     * @param target the type into which to cast
     * @return the target type
     */
    public Type Cast(Type source, Class target) throws ClassMakerException
    {
        DeclaredType declared = getFactory().classToDeclaredType(target);
        return Cast(source, declared);
    }

    /**
     * Casts a reference from one type to another.
     * </br>
     * Performs a casting conversion between the source and target types.
     * @param source the type of the reference on top of the stack
     * @param target the type into which to cast
     * @return the target type
     */
    public Type Cast(Type source, DeclaredType target) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
            cfw.setDebugComment("Cast("+source+", "+target+");");
        Type targetType = target.getType();
        if (getFactory().getCastingConversion().isConvertable(source, targetType))
            return getFactory().getCastingConversion().convertTo(this, source, targetType);
        else
            throw createException("ClassMaker.CannotCastFromTypeToType_2", source.getName(), target.getName());
    }

    /**
     * Converts a reference from one type to another.
     * </br>
     * Generates code to check the cast of the reference on top of the stack.
     * This method is called by CastingConversion.wideningReferenceConversion() to perform casts.
     *
     * @param source the type of the reference on top of the stack
     * @param target the type into which to cast
     * @return the target type
     */
    public ClassType toReference(ClassType source, ClassType target) throws ClassMakerException
    {   // FIXME - make package accessible
        markLineNumber(); // possibly add a new line number entry.
        String className = target.getName();
        cfw.add(ByteCode.CHECKCAST, className);
        return target;
    }

    public Type InstanceOf(Type reference, Class javaClass)
    {
        return InstanceOf(reference, javaClass.getName());
    }

    public Type InstanceOf(Type reference, String target)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("InstanceOf("+reference+", "+target+");");
        DeclaredType declared = findDeclaredType(target);
        if (reference.toClass() == null)
            throw createException("ClassMaker.InstanceOfMustTestAClass_1", reference.getName());
        if (declared == null || declared.getClassType() == null)
            throw createException("ClassMaker.CannotTestInstanceOfType_1", target);
        return checkInstanceOf(reference.toClass(), declared.getClassType());
    }
    
    Type checkInstanceOf(Type source, ClassType target) throws ClassMakerException
    {
        markLineNumber(); // possibly add a new line number entry.
        String className = target.getName().replace('.', '/');
        cfw.add(ByteCode.INSTANCEOF, className);
        return ClassMaker.BOOLEAN_TYPE;
    }
    /**
     * Converts a value to a byte.
     * </br>
     * The value on top of the stack is converted from any primitive type to a byte.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>(byte)a<code></td>
     * <td><code>toByte(Get("a"))</code></td></tr>
     * </table>
     * @param op the type of the operand
     * @return the type of the result is always byte
     */
    public Type toByte(Type op) throws ClassMakerException
    {   // FIXME - make package accessible
        if (getClassFileWriter() == null) return null;
        if (!BYTE_TYPE.equals(op))
        {
            toInt(op);
            cfw.add(ByteCode.I2B);
        }
        return BYTE_TYPE;
    }

    /**
     * Converts a value to a short.
     * </br>
     * The value on top of the stack is converted from any primitive type to a short.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>(short)a<code></td>
     * <td><code>toShort(Get("a"))</code></td></tr>
     * </table>
     * @param op the type of the operand
     * @return the type of the result is always short
     */
    public Type toShort(Type op) throws ClassMakerException
    {   // FIXME - make package accessible
        if (getClassFileWriter() == null) return null;
        if (!SHORT_TYPE.equals(op))
        {
            toInt(op);
            cfw.add(ByteCode.I2S);
        }
        return SHORT_TYPE;
    }

    /**
     * Converts a value to a char.
     * </br>
     * The value on top of the stack is converted from any primitive type to a char.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>(char)a<code></td>
     * <td><code>toChar(Get("a"))</code></td></tr>
     * </table>
     * @param op the type of the operand
     * @return the type of the result is always char
     */
    public Type toChar(Type op) throws ClassMakerException
    {   // FIXME - make package accessible
        if (getClassFileWriter() == null) return null;
        if (!CHAR_TYPE.equals(op))
        {
            toInt(op);
            cfw.add(ByteCode.I2C);
        }
        return CHAR_TYPE;
    }

    /**
     * Converts a value to an int.
     * </br>
     * The value on top of the stack is converted from any primitive type to an int.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>(int)a<code></td>
     * <td><code>toInt(Get("a"))</code></td></tr>
     * </table>
     * @param op the type of the operand
     * @return the type of the result is always int
     */
    public Type toInt(Type op) throws ClassMakerException
    {   // FIXME - make package accessible
        if (getClassFileWriter() == null) return null;
        if (isPrimitive(op))
        {
            markLineNumber(); // possibly add a new line number entry.
            switch (op.toPrimitive().index)
            {
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                return INT_TYPE;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.L2I);
                return INT_TYPE;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.D2I);
                return INT_TYPE;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.F2I);
                return INT_TYPE;
            }
        }
        throw createException("ClassMaker.CannotConvertFromTo_2", op.getName(), INT_TYPE.getName());
    }

    /**
     * Converts a value to a long.
     * </br>
     * The value on top of the stack is converted from any primitive type to a long.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>(long)a<code></td>
     * <td><code>toLong(Get("a"))</code></td></tr>
     * </table>
     * @param op the type of the operand
     * @return the type of the result is always long
     */
    public Type toLong(Type op) throws ClassMakerException
    {   // FIXME - make package accessible
        if (getClassFileWriter() == null) return null;
        if (isPrimitive(op))
        {
            markLineNumber(); // possibly add a new line number entry.
            switch (op.toPrimitive().index)
            {
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.I2L);
                return LONG_TYPE;
            case PrimitiveType.LONG_INDEX:
                return LONG_TYPE;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.D2L);
                return LONG_TYPE;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.F2L);
                return LONG_TYPE;
            }
        }
        throw createException("ClassMaker.CannotConvertFromTo_2", op.getName(), LONG_TYPE.getName());
    }

    /**
     * Converts a value to a float.
     * </br>
     * The value on top of the stack is converted from any primitive type to a float.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>(float)a<code></td>
     * <td><code>toFloat(Get("a"))</code></td></tr>
     * </table>
     * @param op the type of the operand
     * @return the type of the result is always float
     */
    public Type toFloat(Type op) throws ClassMakerException
    {   // FIXME - make package accessible
        if (getClassFileWriter() == null) return null;
        if (isPrimitive(op))
        {
            markLineNumber(); // possibly add a new line number entry.
            switch (op.toPrimitive().index)
            {
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.I2F);
                return FLOAT_TYPE;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.L2F);
                return FLOAT_TYPE;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.D2F);
                return FLOAT_TYPE;
            case PrimitiveType.FLOAT_INDEX:
                return FLOAT_TYPE;
            }
        }
        throw createException("ClassMaker.CannotConvertFromTo_2", op.getName(), FLOAT_TYPE.getName());
    }

    /**
     * Converts a value to a double.
     * </br>
     * The value on top of the stack is converted from any primitive type to a double.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>(double)a<code></td>
     * <td><code>toDouble(Get("a"))</code></td></tr>
     * </table>
     * @param op the type of the operand
     * @return the type of the result is always double
     */
    public Type toDouble(Type op) throws ClassMakerException
    {   // FIXME - make package accessible
        if (getClassFileWriter() == null) return null;
        if (isPrimitive(op))
        {
            markLineNumber(); // possibly add a new line number entry.
            switch (op.toPrimitive().index)
            {
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.I2D);
                return DOUBLE_TYPE;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.L2D);
                return DOUBLE_TYPE;
            case PrimitiveType.DOUBLE_INDEX:
                return DOUBLE_TYPE;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.F2D);
                return DOUBLE_TYPE;
            }
        }
        throw createException("ClassMaker.CannotConvertFromTo_2", op.getName(), DOUBLE_TYPE.getName());
    }

    //################ Arithmetic operators ######################

    /**
     * <b>Add</b>s the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then added.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a + b<code></td>
     * <td><code>Add(Get("a"), Get("b"))</code></td></tr>
     * </table>
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result after promotion
     */
    public Type Add(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("Add("+op1+", "+op2+");");
        if (isPrimitive(op1) && isPrimitive(op2))
        {
            if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
            {
                op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
            }
            return primitiveAdd(op1.toPrimitive(), op2.toPrimitive());
        }
        else if (getFactory().getStringConversion().isConvertable(op1.getType(), op2.getType()))
        {
            markLineNumber(); // possibly add a new line number entry.

            return getFactory().getStringConversion().convertTo(this, op1.getType(), op2.getType());
        }
        throw createException("ClassMaker.CannotAddType_2", op1.getName(), op2.getName());
    }

    /**
     * Integer addition on primitive operands.
     * </br>
     * This method is provided so that <code>Add</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to perform
     * integer addition for <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result
     */
    protected PrimitiveType primitiveAdd(PrimitiveType op1, PrimitiveType op2)
    {
        if (getClassFileWriter() == null) return null;
        markLineNumber(); // possibly add a new line number entry.

        if (op1.equals(op2))
        {
            switch (op1.index)
            {
            case PrimitiveType.BYTE_INDEX:
                cfw.add(ByteCode.IADD);
                cfw.add(ByteCode.I2B);
                return op1;
            case PrimitiveType.SHORT_INDEX:
                cfw.add(ByteCode.IADD);
                cfw.add(ByteCode.I2S);
                return op1;
            case PrimitiveType.CHAR_INDEX :
                cfw.add(ByteCode.IADD);
                cfw.add(ByteCode.I2C);
                return op1;
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.IADD);
                return op1;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LADD);
                return op1;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DADD);
                return op1;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FADD);
                return op1;
            }
        }
        throw createException("ClassMaker.CannotAddType_2", op1.getName(), op2.getName());
    }

    /**
     * <b>Subt</b>racts the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then subtracted.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a - b<code></td>
     * <td><code>Subt(Get("a"), Get("b"))</code></td></tr>
     * </table>
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result after promotion
     */
    public Type Subt(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("Subt("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isPrimitive(op1) && isPrimitive(op2))
        {
            return primitiveSubt(op1.toPrimitive(), op2.toPrimitive());
        }
        throw createException("ClassMaker.CannotSubtractType_2", op1.getName(), op2.getName());
    }

    /**
     * Integer subtraction on primitive operands.
     * </br>
     * This method is provided so that <code>Subt</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to perform
     * integer subtraction for <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result
     */
    protected PrimitiveType primitiveSubt(PrimitiveType op1, PrimitiveType op2)
    {
        markLineNumber(); // possibly add a new line number entry.
        if (op1.equals(op2))
        {
            switch (op1.index)
            {
            case PrimitiveType.BYTE_INDEX:
                cfw.add(ByteCode.ISUB);
                cfw.add(ByteCode.I2B);
                return op1;
            case PrimitiveType.SHORT_INDEX:
                cfw.add(ByteCode.ISUB);
                cfw.add(ByteCode.I2S);
                return op1;
            case PrimitiveType.CHAR_INDEX:
                cfw.add(ByteCode.ISUB);
                cfw.add(ByteCode.I2C);
                return op1;
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.ISUB);
                return op1;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LSUB);
                return op1;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DSUB);
                return op1;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FSUB);
                return op1;
            }
        }
        throw createException("ClassMaker.CannotSubtractType_2", op1.getName(), op2.getName());
    }

    /**
     * <b>Mult</b>iplies the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then multiplied.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a * b<code></td>
     * <td><code>Mult(Get("a"), Get("b"))</code></td></tr>
     * </table>
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result after promotion
     */
    public Type Mult(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("Mult("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isPrimitive(op1) && isPrimitive(op2))
        {
            return primitiveMult(op1.toPrimitive(), op2.toPrimitive());
        }
        throw createException("ClassMaker.CannotMultiplyType_2", op1.getName(), op2.getName());
    }

    /**
     * Integer multiply on primitive operands.
     * </br>
     * This method is provided so that <code>Mult</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to perform
     * integer multiplication for <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result
     */
    protected PrimitiveType primitiveMult(PrimitiveType op1, PrimitiveType op2)
    {
        markLineNumber(); // possibly add a new line number entry.
        if (op1.equals(op2))
        {
            switch (op1.index)
            {
            case PrimitiveType.BYTE_INDEX:
                cfw.add(ByteCode.IMUL);
                cfw.add(ByteCode.I2B);
                return op1;
            case PrimitiveType.SHORT_INDEX:
                cfw.add(ByteCode.IMUL);
                cfw.add(ByteCode.I2S);
                return op1;
            case PrimitiveType.CHAR_INDEX:
                cfw.add(ByteCode.IMUL);
                cfw.add(ByteCode.I2C);
                return op1;
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.IMUL);
                return op1;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LMUL);
                return op1;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DMUL);
                return op1;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FMUL);
                return op1;
            }
        }
        throw createException("ClassMaker.CannotMultiplyType_2", op1.getName(), op2.getName());
    }

    /**
     * <b>Div</b>ides the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then divided.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a / b<code></td>
     * <td><code>Div(Get("a"), Get("b"))</code></td></tr>
     * </table>
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result after promotion
     */
    public Type Div(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("Div("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isPrimitive(op1) && isPrimitive(op2))
        {
            return primitiveDiv(op1.toPrimitive(), op2.toPrimitive());
        }
        throw createException("ClassMaker.CannotDivideType_2", op1.getName(), op2.getName());
    }

    /**
     * Integer divide on primitive operands.
     * </br>
     * This method is provided so that <code>Rem</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to perform
     * integer division for <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result
     */
    protected PrimitiveType primitiveDiv(PrimitiveType op1, PrimitiveType op2)
    {
        markLineNumber(); // possibly add a new line number entry.
        if (op1.equals(op2))
        {
            switch (op1.index)
            {
            case PrimitiveType.BYTE_INDEX:
                cfw.add(ByteCode.IDIV);
                cfw.add(ByteCode.I2B);
                return op1;
            case PrimitiveType.SHORT_INDEX:
                cfw.add(ByteCode.IDIV);
                cfw.add(ByteCode.I2S);
                return op1;
            case PrimitiveType.CHAR_INDEX:
                cfw.add(ByteCode.IDIV);
                cfw.add(ByteCode.I2C);
                return op1;
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.IDIV);
                return op1;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LDIV);
                return op1;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DDIV);
                return op1;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FDIV);
                return op1;
            }
        }
        throw createException("ClassMaker.CannotDivideType_2", op1.getName(), op2.getName());
    }

    /**
     * Determines the integer <b>Rem</b>ainder after dividing the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then integer divided.
     * The remainder is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a % 3<code></td>
     * <td><code>Rem(Get("a"), Literal(3))</code></td></tr>
     * </table>
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result after promotion
     */
    public Type Rem(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("Rem("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isPrimitive(op1) && isPrimitive(op2))
        {
            return primitiveRem(op1.toPrimitive(), op2.toPrimitive());
        }
        throw createException("ClassMaker.CannotRemainderType_2", op1.getName(), op2.getName());
    }

    /**
     * Integer remainder on primitive operands.
     * </br>
     * This method is provided so that <code>Rem</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to calculate
     * the integer remainder for <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result
     */
    protected PrimitiveType primitiveRem(PrimitiveType op1, PrimitiveType op2)
    {
        markLineNumber(); // possibly add a new line number entry.

        if (op1.equals(op2))
        {
            switch (op1.index)
            {
            case PrimitiveType.BYTE_INDEX:
                cfw.add(ByteCode.IREM);
                cfw.add(ByteCode.I2B);
                return op1;
            case PrimitiveType.SHORT_INDEX:
                cfw.add(ByteCode.IREM);
                cfw.add(ByteCode.I2S);
                return op1;
            case PrimitiveType.CHAR_INDEX:
                cfw.add(ByteCode.IREM);
                cfw.add(ByteCode.I2C);
                return op1;
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.IREM);
                return op1;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LREM);
                return op1;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DREM);
                return op1;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FREM);
                return op1;
            }
        }
        throw createException("ClassMaker.CannotRemainderType_2", op1.getName(), op2.getName());
    }

    /**
     * Negates the numeric value on top of the stack.
     * </br>
     * The value is numerically promoted to <code>int</code>, if appropriate, and then negated.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>-a<code></td>
     * <td><code>Neg(Get("a"))</code></td></tr>
     * </table>
     * @param type the Type of the value
     * @return the type of the promoted value
     */
    public Type Neg(Type type)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("Neg("+type+");");
        if (getFactory().getNumericPromotion().isConvertable(type))
        {
            type = getFactory().getNumericPromotion().convertTo(this, type);
        }
        if (isPrimitive(type))
        {
            markLineNumber(); // possibly add a new line number entry.
            switch (type.toPrimitive().index)
            {
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.INEG);
                return type;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LNEG);
                return type;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DNEG);
                return type;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FNEG);
                return type;
            }
        }
        throw createException("ClassMaker.CannotNegType_1", type.getName());
    }

    /**
     * Applies bitwise <b>exclisive or</b> to the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then exclusive or'ed.
     * A result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a ^ 3<code></td>
     * <td><code>Xor(Get("a"), Literal(3))</code></td></tr>
     * </table>
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result after promotion
     */
    public Type Xor(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("Xor("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isPrimitive(op1) && isPrimitive(op2))
        {
            return primitiveXor(op1.toPrimitive(), op2.toPrimitive());
        }
        throw createException("ClassMaker.CannotXorType_2", op1.getName(), op2.getName());
    }

    /**
     * Bitwise XOR on primitive operands.
     * </br>
     * This method is provided so that <code>Xor</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to exclusive or
     * <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result
     */
    protected PrimitiveType primitiveXor(PrimitiveType op1, PrimitiveType op2)
    {
        markLineNumber(); // possibly add a new line number entry.

        if (op1.equals(op2))
        {
            switch (op1.index)
            {
            case PrimitiveType.BYTE_INDEX:
                cfw.add(ByteCode.IXOR);
                cfw.add(ByteCode.I2B);
                return op1;
            case PrimitiveType.SHORT_INDEX:
                cfw.add(ByteCode.IXOR);
                cfw.add(ByteCode.I2S);
                return op1;
            case PrimitiveType.CHAR_INDEX:
                cfw.add(ByteCode.IXOR);
                cfw.add(ByteCode.I2C);
                return op1;
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.IXOR);
                return op1;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LXOR);
                return op1;
            }
        }
        throw createException("ClassMaker.CannotXorType_2", op1.getName(), op2.getName());
    }

    /**
     * Applies bitwise <b>and</b> to the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then bitwised and'ed.
     * A result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a & 3<code></td>
     * <td><code>And(Get("a"), Literal(3))</code></td></tr>
     * </table>
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result after promotion
     */
    public Type And(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("And("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isPrimitive(op1) && isPrimitive(op2))
        {
            return primitiveAnd(op1.toPrimitive(), op2.toPrimitive());
        }
        throw createException("ClassMaker.CannotAndType_2", op1.getName(), op2.getName());
    }

    /**
     * Bitwise AND on primitive operands.
     * </br>
     * This method is provided so that <code>And</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to bitwise and
     * <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result
     */
    protected PrimitiveType primitiveAnd(PrimitiveType op1, PrimitiveType op2)
    {
        markLineNumber(); // possibly add a new line number entry.

        if (op1.equals(op2))
        {
            switch (op1.index)
            {
            case PrimitiveType.BYTE_INDEX:
                cfw.add(ByteCode.IAND);
                cfw.add(ByteCode.I2B);
                return op1;
            case PrimitiveType.SHORT_INDEX:
                cfw.add(ByteCode.IAND);
                cfw.add(ByteCode.I2S);
                return op1;
            case PrimitiveType.CHAR_INDEX:
                cfw.add(ByteCode.IAND);
                cfw.add(ByteCode.I2C);
                return op1;
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.IAND);
                return op1;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LAND);
                return op1;
            }
        }
        throw createException("ClassMaker.CannotAndType_2", op1.getName(), op2.getName());
    }

    /**
     * Applies bitwise <b>or</b> to the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then bitwised or'ed.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a | 3<code></td>
     * <td><code>Or(Get("a"), Literal(3))</code></td></tr>
     * </table>
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result after promotion
     */
    public Type Or(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("Or("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isPrimitive(op1) && op1.equals(op2))
        {
            return primitiveOr(op1.toPrimitive(), op2.toPrimitive());
        }
        throw createException("ClassMaker.CannotOrType_2", op1.getName(), op2.getName());
    }

    /**
     * Bitwise OR on primitive operands.
     * </br>
     * This method is provided so that <code>Or</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to bitwise or
     * <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the left operand
     * @param op2 the type of the right operand
     * @return the type of the result
     */
    protected PrimitiveType primitiveOr(PrimitiveType op1, PrimitiveType op2)
    {
        markLineNumber(); // possibly add a new line number entry.

        if (op1.equals(op2))
        {
            switch (op1.index)
            {
            case PrimitiveType.BYTE_INDEX:
                cfw.add(ByteCode.IOR);
                cfw.add(ByteCode.I2B);
                return op1;
            case PrimitiveType.SHORT_INDEX:
                cfw.add(ByteCode.IOR);
                cfw.add(ByteCode.I2S);
                return op1;
            case PrimitiveType.CHAR_INDEX:
                cfw.add(ByteCode.IOR);
                cfw.add(ByteCode.I2C);
                return op1;
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.IOR);
                return op1;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LOR);
                return op1;
            }
        }
        throw createException("ClassMaker.CannotOrType_2", op1.getName(), op2.getName());
    }

    /**
     * Applies bitwise <b>Inv</b>ersion to the value on top of the stack.
     * </br>
     * The operand is numerically promoted to an <code>int</code>, if appropriate,
     * and then bitwised inverted. The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>~ a<code></td>
     * <td><code>Inv(Get("a"))</code></td></tr>
     * </table>
     * @param op1 the type of the left operand
     * @return the type of the result after promotion
     */
    public Type Inv(Type op1)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("Inv("+op1+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType()))
        {
            op1 = getFactory().getNumericPromotion().convertTo(this, op1.getType());
        }
        if (isPrimitive(op1))
        {
            return primitiveInv(op1.toPrimitive());
        }
        throw createException("ClassMaker.CannotInvertType_1", op1.getName());
    }

    /**
     * Bitwise <b>Inversion</b> on primitive operands.
     * </br>
     * This method is provided so that <code>Inv</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to invert the bits on
     * <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the left operand
     * @return the type of the result
     */
    protected PrimitiveType primitiveInv(PrimitiveType op1)
    {
        markLineNumber(); // possibly add a new line number entry.

        switch (op1.index)
        {
        case PrimitiveType.BYTE_INDEX:
            cfw.addPush(0xFFFFFFFF);
            cfw.add(ByteCode.IXOR);
            cfw.add(ByteCode.I2B);
            break;
        case PrimitiveType.SHORT_INDEX:
            cfw.addPush(0xFFFFFFFF);
            cfw.add(ByteCode.IXOR);
            cfw.add(ByteCode.I2S);
            break;
        case PrimitiveType.CHAR_INDEX:
            cfw.addPush(0xFFFFFFFF);
            cfw.add(ByteCode.IXOR);
            cfw.add(ByteCode.I2C);
            break;
        case PrimitiveType.INT_INDEX:
            cfw.addPush(0xFFFFFFFF);
            cfw.add(ByteCode.IXOR);
            break;
        case PrimitiveType.LONG_INDEX:
            cfw.addPush(0xFFFFFFFFFFFFFFFFL);
            cfw.add(ByteCode.LXOR);
            break;
        default:
            throw createException("ClassMaker.CannotInvertType_1", op1.getName());
        }
        return op1;
    }

    //################ Bitwise shifting operators ####################
    /**
     * <b>SH</b>ifts <b>L</b>eft the value of the first operand by the number of bits indicated by the second operand.
     * </br>
     * The operands are independantly numerically promoted.
     * A shifted result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a << 3<code></td>
     * <td><code>SHL(Get("a"), Literal(3))</code></td></tr>
     * </table>
     * @param op1 the type of the operand being shifted
     * @param op2 the type of the operand indicating places to shift
     * @return the type of op1 after promotion
     */
    public Type SHL(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("SHL("+op1+", "+op2+");");
        // Promote left and right operands independantly.
        if (getFactory().getNumericPromotion().isConvertable(op1.getType()))
        {
            op1 = getFactory().getNumericPromotion().convertTo(this, op1.getType());
        }
        if (getFactory().getNumericPromotion().isConvertable(op2.getType()))
        {
            op2 = getFactory().getNumericPromotion().convertTo(this, op2.getType());
        }
        if (isPrimitive(op1) && isPrimitive(op2))
        {
            return primitiveShiftLeft(op1.toPrimitive(), op2.toPrimitive());
        }
        throw createException("ClassMaker.CannotShiftLeftType_1", op1.getName());
    }

    /**
     * Raw Shift left on primitive operands.
     * </br>
     * This method is provided so that <code>SHL</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to shift left
     * <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the operand being shifted
     * @param op2 the type of the operand indicating places to shift
     * @return the type of op1 after promotion
     */
    protected PrimitiveType primitiveShiftLeft(PrimitiveType op1, PrimitiveType op2)
    {
        if (!INT_TYPE.equals(op2) && !SHORT_TYPE.equals(op2) && !CHAR_TYPE.equals(op2) && !BYTE_TYPE.equals(op2))
            throw createException("ClassMaker.ShiftOperandMustBeIntegerTypeNot_1", op2.getName());

        markLineNumber(); // possibly add a new line number entry.
        switch (op1.index)
        {
        case PrimitiveType.BYTE_INDEX:
            cfw.add(ByteCode.ISHL);
            cfw.add(ByteCode.I2B);
            break;
        case PrimitiveType.SHORT_INDEX:
            cfw.add(ByteCode.ISHL);
            cfw.add(ByteCode.I2S);
            break;
        case PrimitiveType.CHAR_INDEX:
            cfw.add(ByteCode.ISHL);
            cfw.add(ByteCode.I2C);
            break;
        case PrimitiveType.INT_INDEX:
            cfw.add(ByteCode.ISHL);
            break;
        case PrimitiveType.LONG_INDEX:
            cfw.add(ByteCode.LSHL);
            break;
        default:
            throw createException("ClassMaker.CannotShiftLeftType_1", op1.getName());
        }
        return op1;
    }

    /**
     * <b>SH</b>ifts <b>R</b>ight the signed value of the first operand by the number of bits indicated by the second operand.
     * </br>
     * The operands are independantly numerically promoted.
     * A shifted result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a >> 3<code></td>
     * <td><code>SHR(Get("a"), Literal(3))</code></td></tr>
     * </table>
     * @param op1 the type of the operand being shifted
     * @param op2 the type of the operand indicating places to shift
     * @return the type of op1 after promotion
     */
    public Type SHR(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("SHR("+op1+", "+op2+");");
        // Promote left and right operands independantly.
        if (getFactory().getNumericPromotion().isConvertable(op1.getType()))
        {
            op1 = getFactory().getNumericPromotion().convertTo(this, op1.getType());
        }
        if (getFactory().getNumericPromotion().isConvertable(op2.getType()))
        {
            op2 = getFactory().getNumericPromotion().convertTo(this, op2.getType());
        }
        if (isPrimitive(op1) && isPrimitive(op2))
        {
            return primitiveShiftRight(op1.toPrimitive(), op2.toPrimitive());
        }
        throw createException("ClassMaker.CannotShiftRightType_1", op1.getName());
    }

    /**
     * Raw Shift Right on primitive operands.
     * </br>
     * This method is provided so that <code>SHR</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to shift right
     * <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the operand being shifted
     * @param op2 the type of the operand indicating places to shift
     * @return the type of op1 after promotion
     */
    protected PrimitiveType primitiveShiftRight(PrimitiveType op1, PrimitiveType op2)
    {
        if (!INT_TYPE.equals(op2) && !SHORT_TYPE.equals(op2) && !CHAR_TYPE.equals(op2) && !BYTE_TYPE.equals(op2))
            throw createException("ClassMaker.ShiftOperandMustBeIntegerTypeNot_1", op2.getName());

        markLineNumber(); // possibly add a new line number entry.
        switch (op1.index)
        {
        case PrimitiveType.BYTE_INDEX:
            cfw.add(ByteCode.ISHR);
            cfw.add(ByteCode.I2B);
            break;
        case PrimitiveType.SHORT_INDEX:
            cfw.add(ByteCode.ISHR);
            cfw.add(ByteCode.I2S);
            break;
        case PrimitiveType.CHAR_INDEX:
            cfw.add(ByteCode.ISHR);
            cfw.add(ByteCode.I2C);
            break;
        case PrimitiveType.INT_INDEX:
            cfw.add(ByteCode.ISHR);
            break;
        case PrimitiveType.LONG_INDEX:
            cfw.add(ByteCode.LSHR);
            break;
        default:
            throw createException("ClassMaker.CannotShiftRightType_1", op1.getName());
        }
        return op1;
    }

    /**
     * <b>U</b>nsigned <b>SH</b>ifts <b>R</b>ight the value of the first operand by the number of bits indicated by the second operand.
     * </br>
     * The operands are independantly numerically promoted.
     * A shifted result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a >>> 3<code></td>
     * <td><code>USHR(Get("a"), Literal(3))</code></td></tr>
     * </table>
     * @param op1 the type of the operand being shifted
     * @param op2 the type of the operand indicating places to shift
     * @return the type of op1 after promotion
     */
    public Type USHR(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("USHR("+op1+", "+op2+");");
        // Promote left and right operands independantly.
        if (getFactory().getNumericPromotion().isConvertable(op1.getType()))
        {
            op1 = getFactory().getNumericPromotion().convertTo(this, op1.getType());
        }
        if (getFactory().getNumericPromotion().isConvertable(op2.getType()))
        {
            op2 = getFactory().getNumericPromotion().convertTo(this, op2.getType());
        }
        if (isPrimitive(op1) && isPrimitive(op2))
        {
            return primitiveUnsignedShiftRight(op1.toPrimitive(), op2.toPrimitive());
        }
        throw createException("ClassMaker.CannotUnsignedShiftRightType_1", op1.getName());
    }

    /**
     * Raw Unsigned Shift Right on primitive operands.
     * </br>
     * This method is provided so that <code>USR</code> can be overridden to handle
     * new types of operands and promotions. The method generates bytecode to unsigned shift right
     * <code>byte, short, char, int and long</code> operand types.
     * The operands are not numerically promoted.
     * @param op1 the type of the operand being shifted
     * @param op2 the type of the operand indicating places to shift
     * @return the type of op1 after promotion
     */
    protected PrimitiveType primitiveUnsignedShiftRight(PrimitiveType op1, PrimitiveType op2)
    {
        if (!INT_TYPE.equals(op2) && !SHORT_TYPE.equals(op2) && !CHAR_TYPE.equals(op2) && !BYTE_TYPE.equals(op2))
            throw createException("ClassMaker.ShiftOperandMustBeIntegerTypeNot_1", op2.getName());

        markLineNumber(); // possibly add a new line number entry.

        switch (op1.index)
        {
        case PrimitiveType.BYTE_INDEX:
            cfw.add(ByteCode.IUSHR);
            cfw.add(ByteCode.I2B);
            break;
        case PrimitiveType.SHORT_INDEX:
            cfw.add(ByteCode.IUSHR);
            cfw.add(ByteCode.I2S);
            break;
        case PrimitiveType.CHAR_INDEX:
            cfw.add(ByteCode.IUSHR);
            cfw.add(ByteCode.I2C);
            break;
        case PrimitiveType.INT_INDEX:
            cfw.add(ByteCode.IUSHR);
            break;
        case PrimitiveType.LONG_INDEX:
            cfw.add(ByteCode.LUSHR);
            break;
        default:
            throw createException("ClassMaker.CannotUnsignedShiftRightType_1", op1.getName());
        }
        return op1;
    }

    //################# Comparison operators ######################
    /**
     * Tests whether the first value is <b>G</b>reater <b>T</b>han the second.
     * </br>
     * The operand are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a > b<code></td>
     * <td><code>GT(Get("a"), Get("b"))</code></td></tr>
     * </table>
     * @param op1 the type of the first operand
     * @param op2 the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Type GT(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("GT("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isPrimitive(op1) && op1.equals(op2))
        {
            markLineNumber(); // possibly add a new line number entry.
            switch (op1.toPrimitive().index)
            {
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                addCompare(ByteCode.IF_ICMPGT);
                return BOOLEAN_TYPE;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LCMP);
                addCompare(ByteCode.IFGT);
                return BOOLEAN_TYPE;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DCMPL);
                addCompare(ByteCode.IFGT);
                return BOOLEAN_TYPE;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FCMPL);
                addCompare(ByteCode.IFGT);
                return BOOLEAN_TYPE;
            }
        }
        throw createException("ClassMaker.CannotGTTypes_2", op1.getName(), op2.getName());
    }

    /**
     * Tests whether the first value is <b>G</b>reater than or <B>E</B>qual to the second.
     * </br>
     * The operand are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a >= b<code></td>
     * <td><code>GE(Get("a"), Get("b"))</code></td></tr>
     * </table>
     * @param op1 the type of the first operand
     * @param op2 the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Type GE(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("GE("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isPrimitive(op1) && op1.equals(op2))
        {
            markLineNumber(); // possibly add a new line number entry.
            switch (op1.toPrimitive().index)
            {
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                addCompare(ByteCode.IF_ICMPGE);
                return BOOLEAN_TYPE;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LCMP);
                addCompare(ByteCode.IFGE);
                return BOOLEAN_TYPE;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DCMPL);
                addCompare(ByteCode.IFGE);
                return BOOLEAN_TYPE;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FCMPL);
                addCompare(ByteCode.IFGE);
                return BOOLEAN_TYPE;
            }
        }
        throw createException("ClassMaker.CannotGETypes_2", op1.getName(), op2.getName());
    }

    /**
     * Tests whether the first value is <b>L</b>ess than or <B>E</B>qual to the second.
     * </br>
     * The operand are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a <= b<code></td>
     * <td><code>LE(Get("a"), Get("b"))</code></td></tr>
     * </table>
     * @param op1 the type of the first operand
     * @param op2 the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Type LE(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("LE("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isPrimitive(op1) && op1.equals(op2))
        {
            markLineNumber(); // possibly add a new line number entry.
            switch (op1.toPrimitive().index)
            {
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                addCompare(ByteCode.IF_ICMPLE);
                return BOOLEAN_TYPE;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LCMP);
                addCompare(ByteCode.IFLE);
                return BOOLEAN_TYPE;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DCMPG);
                addCompare(ByteCode.IFLE);
                return BOOLEAN_TYPE;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FCMPG);
                addCompare(ByteCode.IFLE);
                return BOOLEAN_TYPE;
            }
        }
        throw createException("ClassMaker.CannotLETypes_2", op1.getName(), op2.getName());
    }

    /**
     * Tests whether the first value is <b>L</b>ess <b>T</b>han the second.
     * </br>
     * The operand are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a < b<code></td>
     * <td><code>LT(Get("a"), Get("b"))</code></td></tr>
     * </table>
     * @param op1 the type of the first operand
     * @param op2 the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Type LT(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("LT("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isPrimitive(op1) && op1.equals(op2))
        {
            markLineNumber(); // possibly add a new line number entry.
            switch (op1.toPrimitive().index)
            {
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                addCompare(ByteCode.IF_ICMPLT);
                return BOOLEAN_TYPE;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LCMP);
                addCompare(ByteCode.IFLT);
                return BOOLEAN_TYPE;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DCMPG);
                addCompare(ByteCode.IFLT);
                return BOOLEAN_TYPE;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FCMPG);
                addCompare(ByteCode.IFLT);
                return BOOLEAN_TYPE;
            }
        }
        throw createException("ClassMaker.CannotLTTypes_2", op1.getName(), op2.getName());
    }

    /**
     * Tests whether the two values are <b>Eq</b>ual.
     * </br>
     * The operands are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a == b<code></td>
     * <td><code>EQ(Get("a"), Get("b"))</code></td></tr>
     * </table>
     * @param op1 the type of the first operand
     * @param op2 the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Type EQ(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("EQ("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }
        if (isClass(op1) && isClass(op2))
        {
            addCompare(ByteCode.IF_ACMPEQ);
            return BOOLEAN_TYPE;
        }
        else if (isPrimitive(op1) && op1.equals(op2))
        {
            markLineNumber(); // possibly add a new line number entry.
            switch (op1.toPrimitive().index)
            {
            case PrimitiveType.BOOLEAN_INDEX: // fall thru
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                addCompare(ByteCode.IF_ICMPEQ);
                return BOOLEAN_TYPE;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LCMP);
                addCompare(ByteCode.IFEQ);
                return BOOLEAN_TYPE;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DCMPL);
                addCompare(ByteCode.IFEQ);
                return BOOLEAN_TYPE;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FCMPL);
                addCompare(ByteCode.IFEQ);
                return BOOLEAN_TYPE;
            }
        }
        throw createException("ClassMaker.CannotEQTypes_2", op1.getName(), op2.getName());
    }

    /**
     * Tests whether the two values are <b>N</b>ot <b>E</b>qual.
     * </br>
     * The operands are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a != b<code></td>
     * <td><code>NE(Get("a"), Get("b"))</code></td></tr>
     * </table>
     * @param op1 the type of the first operand
     * @param op2 the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Type NE(Type op1, Type op2)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("NE("+op1+", "+op2+");");
        if (getFactory().getNumericPromotion().isConvertable(op1.getType(), op2.getType()))
        {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1.getType(), op2.getType());
        }

        if (isClass(op1) && isClass(op2))
        {
            addCompare(ByteCode.IF_ACMPNE);
            return BOOLEAN_TYPE;
        }
        else if (isPrimitive(op1) && op1.equals(op2))
        {
            markLineNumber(); // possibly add a new line number entry.
            switch (op1.toPrimitive().index)
            {
            case PrimitiveType.BOOLEAN_INDEX: // fall thru
            case PrimitiveType.BYTE_INDEX: // fall thru
            case PrimitiveType.SHORT_INDEX: // fall thru
            case PrimitiveType.CHAR_INDEX: // fall thru
            case PrimitiveType.INT_INDEX:
                addCompare(ByteCode.IF_ICMPNE);
                return BOOLEAN_TYPE;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LCMP);
                addCompare(ByteCode.IFNE);
                return BOOLEAN_TYPE;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DCMPL);
                addCompare(ByteCode.IFNE);
                return BOOLEAN_TYPE;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FCMPL);
                addCompare(ByteCode.IFNE);
                return BOOLEAN_TYPE;
            }
        }
        throw createException("ClassMaker.CannotNETypes_2", op1.getName(), op2.getName());
    }

    /**
     * Compares the two values on top of the stack using the given bytecode operator.
     * </br>
     * There is no convenient way using JVM bytecode to compare two values and leave a boolean
     * result on the stack. It must be done by pushing 1 or 0 onto the stack, as appropriate.
     * @param ifOperator the bytcode comparison operator to use.
     */
    protected void addCompare(int ifOperator)
    {
        int jumpTrue = cfw.acquireLabel();
        int jumpFalse = cfw.acquireLabel();

        cfw.add(ifOperator, jumpTrue);
        if (isDebugCode()) cfw.setDebugComment("false");
        cfw.add(ByteCode.ICONST_0);
        cfw.add(ByteCode.GOTO, jumpFalse);
        cfw.markLabel(jumpTrue);
        if (isDebugCode()) cfw.setDebugComment("true");
        cfw.add(ByteCode.ICONST_1);
        cfw.markLabel(jumpFalse);
    }

    /**
     * Negates a boolean value.
     * </br>
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code> ! a<code></td>
     * <td><code>Not(Get("a"))</code></td></tr>
     * </table>
     * @param op1 the type of the first operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Type Not(Type op1)
    {
        if (getClassFileWriter() == null) return null;
        if (isPrimitive(op1))
        {
            markLineNumber(); // possibly add a new line number entry.
            if (cfw.isDebugCode()) 
            	cfw.setDebugComment("Not("+op1+");");
            if (op1.toPrimitive().index == PrimitiveType.BOOLEAN_INDEX)
            {
                cfw.add(ByteCode.ICONST_1);
                cfw.add(ByteCode.IXOR);
                return BOOLEAN_TYPE;
            }
        }
        throw createException("ClassMaker.CannotNotType_1", op1.getName());
    }

    //##################### Arrays ##########################
    /**
     * Checks that the array dimension is of an appropriate type.
     * @param msg message describing the dimension of the array
     * @param sizeType the type of the dimension
     */
    protected void checkArrayDimensionType(String msg, Type sizeType)
    {
        if (!INT_TYPE.equals(sizeType) && !SHORT_TYPE.equals(sizeType)
            && !BYTE_TYPE.equals(sizeType) && !CHAR_TYPE.equals(sizeType))
            throw createException("ClassMaker.MustBeIntegerTypeNot_2", msg, sizeType.getName());
    }

    /**
     * Checks that an array index is of an appropriate type.
     * @param indexType the Type of the index to the array
     * @throws ClassMakerException if the type cannot be used to index the array
     */
    protected void checkArrayIndex(Type indexType) throws ClassMakerException
    {
        if (!INT_TYPE.equals(indexType) && !SHORT_TYPE.equals(indexType) && !CHAR_TYPE.equals(indexType) && !BYTE_TYPE.equals(indexType))
            throw createException("ClassMaker.ArrayIndexMustBeIntegerType_1", indexType.getName());
    }

    public ArrayType NewArray(DeclaredType arrayType, Type size)
    {
        return NewArray(arrayType.getType(), size);
    }
    
    /**
     * Creates an array using the dimension on the stack.
     * <pre>
        Set("x" , NewArray(ArrayOf(int.class), Literal(5)));
     * </pre>
     * @param arrayType the type of array to be created
     * @param sizeType the type of the dimension
     * @return the type of the new array instance
     */
    public ArrayType NewArray(Type arrayType, Type size)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("NewArray("+arrayType+", "+size+");");
        if (!isArray(arrayType))
            throw createException("ClassMaker.NotATypeOfArray_1", arrayType.getName());
        checkArrayDimensionType("Array size", size);
        markLineNumber(); // possibly add a new line number entry.
        ArrayType array = arrayType.toArray();

        Type arrayOfType = array.getArrayOfType();
        if (isPrimitive(arrayOfType))
        {
            byte elementType = typeToArrayElement(arrayOfType.toPrimitive());
            cfw.add(ByteCode.NEWARRAY, elementType);
        }
        else if (isClass(arrayOfType))
        {
            String className = arrayOfType.getName();
            cfw.add(ByteCode.ANEWARRAY, className);
        }
        return array;
    }

    public ArrayType NewArray(DeclaredType array, CallStack dimensions)
    {
        return NewArray(array.getType(), dimensions);
    }

    /**
     * Creates an multi-dimensional array using the dimensions on the stack.
      <pre>
       Type mint_array = ArrayOf(ArrayOf(ArrayOf(int.class)));
       Declare("x", mint_array, 0);
       // x = new int[3,2,2];
       Set("x", NewArray(mint_array, Push(Literal(3)).Push(Literal(2)).Push(Literal(2))));
      </pre>
     * Note:
     * @param array the type of array to be created
     * @param dimensions the call stack
     * @return an new instance of a multi-dimensional array
     */
    public ArrayType NewArray(Type array, CallStack dimensions)
    {
        if (getClassFileWriter() == null) return null;
        if (!isArray(array))
            throw createException("ClassMaker.NotATypeOfArray_1", array.getName());
        ArrayType arrayType = array.toArray();
        Type [] dims = dimensions.toArray();
        for (int i = 0; i < dims.length; i++)
        {
            Type sizeType = dims[i];
            checkArrayDimensionType("Type of array dimension " + i, sizeType);
        }
        markLineNumber(); // possibly add a new line number entry.

        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("NewArray("+array+", "+dims+");");
        cfw.add(ByteCode.MULTIANEWARRAY, arrayType.getSignature(), (byte) dims.length);
        return arrayType;
    }

    /**
     * Finds a type representing an array of the given java class.
      <pre>
         Declare("intArray", ArrayOf(int.class), 0);
      </pre>
     * @param javaClass the class of element in the array
     * @return an <code>ArrayType</code> whose elements are of the given class
     */
    public DeclaredType ArrayOf(Class javaClass)
    {
        String typeName = classToName(javaClass);
        return ArrayOf(typeName);
    }

    /**
     * Finds a type representing an array of the given java class.
      <pre>
         Declare("intArray", ArrayOf("int"), 0);
      </pre>
     * @param typeName the class name of the element in the array
     * @return an <code>ArrayType</code> whose elements are of the given class
     */
    public DeclaredType ArrayOf(String typeName)
    {
        DeclaredType type = stringToDeclaredType(typeName);
        return ArrayOf(type);
    }

    /**
     * Finds a type representing an array of the given type.
      <pre>
         Declare("intArray", ArrayOf(ClassMaker.INT_TYPE), 0);
         Declare("processArray", ArrayOf(getClassType()), 0);
      </pre>
     * This method must be used when there is no concrete <code>Class</code>
     * for the array element, for example when declaring an array of
     * the class currently being generated.
     * @param type the type of element in the array
     * @return an <code>ArrayType</code> whose elements are of the given type
     */
    public ArrayType ArrayOf(Type type)
    {
        return getFactory().typeToArray(type);
    }
    
    public DeclaredType ArrayOf(DeclaredType declared)
    {
        Type type = getFactory().typeToArray(declared.getType());
        return getFactory().typeToDeclaredType(type);
    }

    /**
     * Gets a value from an array element.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a[0]<code></td>
     * <td><code>GetAt(Get("a"), Literal(0));</code></td></tr>
     * </table>
     * The <code>indexType</code> must be int, short, char or byte.
     * @param array the Type of the array containing the element
     * @param index the Type of the index into the array
     * @return the type of the value on the stack
     */
    public Type GetAt(Type array, Type index)
    {
        if (getClassFileWriter() == null) return null;
        ArrayType arrayType = array.toArray();
        if (arrayType == null)
            throw createException("ClassMaker.ArrayExpectedOnStack_1", array.getName());
        Type indexType = index; //load(index);
        checkArrayIndex(indexType.getType());
        markLineNumber(); // possibly add a new line number entry.
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("GetAt("+array+", "+index+");");

        Type elementType = arrayType.getArrayOfType();
        if (isClass(elementType) || isArray(elementType))
        {
            cfw.add(ByteCode.AALOAD);
        }
        else
        {
            switch (elementType.toPrimitive().index)
            {
            case PrimitiveType.BOOLEAN_INDEX: // Fall thru.
            case PrimitiveType.BYTE_INDEX:
                cfw.add(ByteCode.BALOAD);
                break;
            case PrimitiveType.SHORT_INDEX:
                cfw.add(ByteCode.SALOAD);
                break;
            case PrimitiveType.CHAR_INDEX:
                cfw.add(ByteCode.CALOAD);
                break;
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.IALOAD);
                break;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LALOAD);
                break;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DALOAD);
                break;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FALOAD);
                break;
            default:
                throw new IllegalArgumentException("Cannot load type " + elementType.getName() + " from array type: " + array.getName());
            }
        }
        return arrayType.getArrayOfType();
    }

    /**
     * Assigns an array element to a value and leaves the value on the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>x = a[0] = b;<code></td>
     * <td><code>Set("x", AssignAt(Get("a"), Literal(0), Get("b")));</code></td></tr>
     * </table>
     * The <code>indexType</code> must be int, short, char or byte.
     * The value is subject to assignment conversion before it is set.
     * @param arrayType the type of the array containing the element
     * @param indexType the type of the index into the array
     * @param valueType the type of the value to be set
     * @return the type of the value on the stack
     */
    public Type AssignAt(Type arrayType, Type indexType, Type valueType)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("AssignAt("+arrayType+", "+indexType+", "+valueType+");");
        // Cannot dupunder two wide types so store value in an anonomous local variable.
        dup(valueType);
        int offset = storeAnonymousValue(valueType);
        SetAt(arrayType, indexType, valueType);
        this.loadAnonymousValue(offset);
        return valueType;
    }

    /**
     * Sets an array element to a value.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a[0] = b;<code></td>
     * <td><code>SetAt(Get("a"), Literal(0), Get("b"));</code></td></tr>
     * </table>
     * The <code>indexType</code> must be int, short, char or byte.
     * The value is subject to assignment conversion before it is set.
     * @param arrayType the type of the array containing the element
     * @param indexType the type of the index into the array
     * @param value the type of the value to be set
     * @return a <code>Type</code> representing <code>void</code>
     */
    public Type SetAt(Type arrayType, Type indexType, Type valueType)
    {
        if (getClassFileWriter() == null) return null;
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("SetAt("+arrayType+", "+indexType+", "+valueType+");");
        ArrayType element = arrayType.toArray();
        if (element == null)
            throw createException("ClassMaker.ArrayExpectedOnStack_1", arrayType.getName());
        checkArrayIndex(indexType);
        Type declaredType = element.getArrayOfType();
        if (!getFactory().getAssignmentConversion().isConvertable(valueType, declaredType))
            throw createException("ClassMaker.ArrayOfTypeCannotBeAssigned_2",
                            declaredType.getName(), valueType.getName());
        markLineNumber(); // possibly add a new line number entry.

        getFactory().getAssignmentConversion().convertTo(this, valueType, declaredType);

        if (isClass(declaredType))
        {
            cfw.add(ByteCode.AASTORE);
        }
        else if (isPrimitive(declaredType))
        {
            switch (declaredType.toPrimitive().index)
            {
            case PrimitiveType.BOOLEAN_INDEX: // Fall thru.
            case PrimitiveType.BYTE_INDEX:
                cfw.add(ByteCode.BASTORE);
                break;
            case PrimitiveType.SHORT_INDEX:
                cfw.add(ByteCode.SASTORE);
                break;
            case PrimitiveType.CHAR_INDEX:
                cfw.add(ByteCode.CASTORE);
                break;
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.IASTORE);
                break;
            case PrimitiveType.LONG_INDEX:
                cfw.add(ByteCode.LASTORE);
                break;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.add(ByteCode.DASTORE);
                break;
            case PrimitiveType.FLOAT_INDEX:
                cfw.add(ByteCode.FASTORE);
                break;
            default:
                throw new IllegalArgumentException("Cannot assign type " + valueType.getName() + " to an array.");
            }
        }
        return VOID_TYPE;
    }

    /**
     * Gets the length of the array on top of the stack.
     * <pre>
     *    Eval(Set("len", Length(Get("anArray"))));
     * </pre>
     * @param array the Type of the array
     * @return the length of the array
     */
    public PrimitiveType Length(Type array)
    {
        if (getClassFileWriter() == null) return null;
        ArrayType element = array.toArray();
        if (element == null)
            throw createException("ClassMaker.ArrayExpectedOnStack_1", array.getName());
        markLineNumber(); // possibly add a new line number entry.
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("Length("+array+");");

        cfw.add(ByteCode.ARRAYLENGTH);
        return INT_TYPE;
    }

    /**
     * Converts a Primitive type into an appropriate element code
     * @param type the type of element in the array
     * @return a element code suitable for the JVM
     */
    protected byte typeToArrayElement(PrimitiveType type)
    {
        switch (type.index)
        {
        case PrimitiveType.BOOLEAN_INDEX:
            return ByteCode.T_BOOLEAN;
        case PrimitiveType.BYTE_INDEX:
            return ByteCode.T_BYTE;
        case PrimitiveType.SHORT_INDEX:
            return ByteCode.T_SHORT;
        case PrimitiveType.CHAR_INDEX:
            return ByteCode.T_CHAR;
        case PrimitiveType.INT_INDEX:
            return ByteCode.T_INT;
        case PrimitiveType.LONG_INDEX:
            return ByteCode.T_LONG;
        case PrimitiveType.DOUBLE_INDEX:
            return ByteCode.T_DOUBLE;
        case PrimitiveType.FLOAT_INDEX:
            return ByteCode.T_FLOAT;
        }
        throw new IllegalArgumentException("Cannot create an array of type: " + type.getName());
    }
    
    /**
     * Evaluate an expression as though it were a statement.
     * </br>
     * An <code>Eval</code> should surround each expression that is used like a statement.
     * Expressions leave their results on the top of the program stack. Calling
     * <code>Eval</code> discards the result of the expression by popping it off the stack.
     * Expressions that have no result, such as method calls that return <code>void</code>,
     * are ignored.
     * <pre>
          Eval(Dec("a"));
     * </pre>
     * @param type the result Type of the expression
     */
    public void Eval(Type type)
    {
        if (getClassFileWriter() == null) return;
        if (!VOID_TYPE.equals(type))
        {
        	if (isDebugCode())
            	cfw.setDebugComment("Eval("+ type + ")");
            pop(type.getType());
        }
    }

    /**
     * Pops a value off the program stack.
     * </br>
     * If the <code>type</code> is <code>long</code> or <code>double</code>
     * two words (64 bits) are popped; otherwise one word (32 bits) are popped.
     * @param type the type of the value on top of the stack
     */
    protected void pop(Type type)
    {
        markLineNumber(); // possibly add a new line number entry.
        if (LONG_TYPE.equals(type) || DOUBLE_TYPE.equals(type))
            cfw.add(ByteCode.POP2);
        else
            cfw.add(ByteCode.POP);
    }

    /**
     * Duplicate the value on top of the stack.
     * </br>
     * If the <code>type</code> is <code>long</code> or <code>double</code>
     * two words (64 bits) are duplicated; otherwise one word (32 bits) is duplicated.
     * @param type the type of the value on top of the stack
     */
    protected void dup(Type type)
    {
        if (LONG_TYPE.equals(type) || DOUBLE_TYPE.equals(type))
            cfw.add(ByteCode.DUP2);
        else
            cfw.add(ByteCode.DUP);
    }

    /**
     * Duplicates the value on top of the stack and place it underneath the next value.
     * </br>
     * If the <code>type</code> is <code>long</code> or <code>double</code>
     * two words (64 bits) are duplicated; otherwise one word (32 bits) are duplicated.
     * The duplicated value us placed underneath the next value down from the top
     * of the stack.
     * @param underType the type of the second value on the stack
     * @param type the type of the top value on the stack
     */
    protected void dupunder(Type underType, Type type)
    {
        if (LONG_TYPE.equals(type) || DOUBLE_TYPE.equals(type))
        {
            if (LONG_TYPE.equals(underType) || DOUBLE_TYPE.equals(underType))
                cfw.add(ByteCode.DUP2_X2);
            else
                cfw.add(ByteCode.DUP2_X1);
        } else
        {
            if (LONG_TYPE.equals(underType) || DOUBLE_TYPE.equals(underType))
                cfw.add(ByteCode.DUP_X2);
            else
                cfw.add(ByteCode.DUP_X1);
        }
    }

    /**
     * Swaps the two values on top of the stack.
     * </br>
     * If the type is <code>long</code> or <code>double</code>
     * two words (64 bits) are moved; otherwise one word (32 bits) are moved.
     * @param underType the type of the second value on the stack
     * @param type the type of the top value on the stack
     */
    public void swap(Type underType, Type type)
    {
        if (LONG_TYPE.equals(type) || DOUBLE_TYPE.equals(type))
        {
            if (LONG_TYPE.equals(underType) || DOUBLE_TYPE.equals(underType))
            {
                cfw.add(ByteCode.DUP2_X2);
                cfw.add(ByteCode.POP2);
            } else
            {
                cfw.add(ByteCode.DUP2_X1);
                cfw.add(ByteCode.POP2);
            }
        } else
        {
            if (LONG_TYPE.equals(underType) || DOUBLE_TYPE.equals(underType))
            {
                cfw.add(ByteCode.DUP_X2);
                cfw.add(ByteCode.POP);
            } else
            {
                cfw.add(ByteCode.SWAP);
            }
        }
    }

    //############# Increment & Decrement operators ###############

    /**** Inc ****/
    
    /**
     * Gets the value of a local variable after incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>++i;<code></td>
     * <td><code>Inc("i")</code></td></tr>
     * </table>
     * @param name the name of the member variable
     * @return the value of the variable after it is incremented
     */
    public Type Inc(String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("Inc(" + name + ")");
        MakerField local = Find(name);
        return incLocal(local);
    }
    
    Type incLocal(MakerField local)
    {
        markLineNumber(); // possibly add a new line number entry.
        if (!increment(local, 1))
            throw createException("ClassMaker.CannotIncrementVariableOfType_2", local.getName(),  local.getType().getName());
        return loadLocal(local);
    }

    /**
     * Gets the value of a member variable after incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>++obj.i;<code></td>
     * <td><code>Inc(Get("obj"), "i")</code></td></tr>
     * </table>
     * @param type the type of the class containing the variable
     * @param name the name of the member variable
     * @return the value of the variable after it is incremented
     */
    public Type Inc(Type reference, String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("Inc(" + reference + ", " + name+ ")");
        MakerField field = Find(reference, name);
        return incField(field);
    }

    Type incField(MakerField field)
    {
        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        ClassType classType = field.getClassType();
        String className = classType.getName();
        String name = field.getName();

        // GET myclass.id
        dup(classType);
        cfw.add(ByteCode.GETFIELD, toSlashName(className), name, fieldType.getSignature());

        if (!increment(fieldType, 1))
            throw createException("ClassMaker.CannotIncrementFieldOfType_2", name, fieldType.getName());
        dupunder(thisClassType, fieldType);

        cfw.add(ByteCode.PUTFIELD, toSlashName(className), name, fieldType.getSignature());

        return fieldType;
    }

    /**
     * Gets the value of a static member variable after incrementing it.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>++MyClass.i;<code></td>
     * <td><code>Inc("MyClass", "i")</code></td></tr>
     * </table>
     * @param className the short or fully qualified name of the class
     * @param name the name of the static member variable
     * @return the value of the variable after it is incremented
     */
    public Type Inc(String className, String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("Inc(\"" + className + "\", " + name+ ")");
        MakerField field = Find(className, name);
        return incStatic(field);
    }

    Type incStatic(MakerField field)
    {
        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();
        ClassType classType = field.getClassType();
        String className = classType.getName();

        markLineNumber(); // possibly add a new line number entry.
        // GET myclass.id
        cfw.add(ByteCode.GETSTATIC, toSlashName(className), fieldName, fieldType.getSignature());

        if (!increment(fieldType, 1))
            throw createException("ClassMaker.CannotIncrementFieldOfType_2", fieldName, fieldType.getName());
        dup(fieldType);

        cfw.add(ByteCode.PUTSTATIC, toSlashName(className), fieldName, fieldType.getSignature());

        return fieldType;
    }

    /**** Dec ****/
    
    /**
     * Gets the value of a local variable after decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>--i;<code></td>
     * <td><code>Dec("i")</code></td></tr>
     * </table>
     * @param name the name of the member variable
     * @return the value of the variable after it is decremented
     */
    public Type Dec(String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("Dec(" + name + ")");
        MakerField field = Find(name);
        return decLocal(field);
    }
    
    Type decLocal(MakerField local)
    {
        markLineNumber(); // possibly add a new line number entry.
        if (!increment(local, -1))
            throw createException("ClassMaker.CannotDecrementVariableOfType_2", local.getName(),  local.getType().getName());
        return loadLocal(local);
    }

    /**
     * Gets the value of a member variable after decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>--obj.i;<code></td>
     * <td><code>Dec(Get("obj"), "i")</code></td></tr>
     * </table>
     * @param type the type of the class containing the variable
     * @param name the name of the member variable
     * @return the value of the variable after it is decremented
     */
    public Type Dec(Type reference, String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    	    cfw.setDebugComment("Dec(" + reference + ", " + name+ ")");
        MakerField field = Find(reference, name);
        return decField(field);
    }

    Type decField(MakerField field)
    {
        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();
        ClassType classType = field.getClassType();
        String className = classType.getName();

        // GET myclass.id
        dup(classType);
        cfw.add(ByteCode.GETFIELD, toSlashName(className), fieldName, fieldType.getSignature());

        if (!increment(fieldType, -1))
            throw createException("ClassMaker.CannotDecrementFieldOfType_2", fieldName, fieldType.getName());
        dupunder(classType, fieldType);

        // PUT myclass.id
        cfw.add(ByteCode.PUTFIELD, toSlashName(className), fieldName, fieldType.getSignature());

        return fieldType;
    }

    /**
     * Gets the value of a static member variable after decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>--MyClass.i;<code></td>
     * <td><code>Dec("MyClass", "i")</code></td></tr>
     * </table>
     * @param className the short or fully qualified name of the class
     * @param name the name of the static member variable
     * @return the value of the variable after it is decremented
     */
    public Type Dec(String className, String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    	    cfw.setDebugComment("Dec(\"" + className + "\", " + name+ ")");
        MakerField field = Find(className, name);
        return decStatic(field);
    }

    Type decStatic(MakerField field)
    {
        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();
        ClassType classType = field.getClassType();
        String className = classType.getName();

        markLineNumber(); // possibly add a new line number entry.
        // GET myclass.id
        cfw.add(ByteCode.GETSTATIC, toSlashName(className), fieldName, fieldType.getSignature());

        if (!increment(fieldType, -1))
            throw createException("ClassMaker.CannotDecrementFieldOfType_2", fieldName, fieldType.getName());
        dup(fieldType);

        cfw.add(ByteCode.PUTSTATIC, toSlashName(className), fieldName, fieldType.getSignature());

        return fieldType;
    }

    /**** PostInc ****/
    
    /**
     * Gets the value of a local variable before incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>i++;<code></td>
     * <td><code>PostInc("i")</code></td></tr>
     * </table>
     * @param name the name of the member variable
     * @return the value of the variable before it is incremented
     */
    public Type PostInc(String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("PostInc(" + name+ ")");
        MakerField local = Find(name);
        return postIncLocal(local);
    }
    
    Type postIncLocal(MakerField local)
    {
        markLineNumber(); // possibly add a new line number entry.
        Type type = loadLocal(local);
        if (!increment(local, 1))
            throw createException("ClassMaker.CannotIncrementVariableOfType_2", local.getName(),  local.getType().getName());
        return type;
    }

    /**
     * Gets the value of a member variable before incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>obj.i++;<code></td>
     * <td><code>PostInc(Get("obj"), "i")</code></td></tr>
     * </table>
     * @param type the type of the class containing the variable
     * @param name the name of the member variable
     * @return the value of the variable before it is incremented
     */
    public Type PostInc(Type reference, String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("PostInc(" + reference + ", " + name+ ")");
        MakerField field = Find(reference, name);
        return postIncField(field);
    }

    Type postIncField(MakerField field)
    {
        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();
        ClassType classType = field.getClassType();
        String className = classType.getName();

        markLineNumber(); // possibly add a new line number entry.

        dup(classType);
        cfw.add(ByteCode.GETFIELD, toSlashName(className), fieldName, fieldType.getSignature());

        dupunder(classType, fieldType);
        if (!increment(fieldType, 1))
            throw createException("ClassMaker.CannotIncrementFieldOfType_2", fieldName, fieldType.getName());

        // PUT myclass.id
        cfw.add(ByteCode.PUTFIELD, toSlashName(className), fieldName, fieldType.getSignature());

        return fieldType;
    }

    /**
     * Gets the value of a static member variable before incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>MyClass.i++;<code></td>
     * <td><code>PostInc("MyClass", "i")</code></td></tr>
     * </table>
     * @param className the short or fully qualified name of the class
     * @param name the name of the static member variable
     * @return the value of the variable before it is incremented
     */
    public Type PostInc(String className, String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("PostInc(\"" + className + "\", " + name+ ")");
        MakerField field = Find(className, name);
        return postIncStatic(field);
    }

    Type postIncStatic(MakerField field)
    {
        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();
        ClassType classType = field.getClassType();
        String className = classType.getName();

        markLineNumber(); // possibly add a new line number entry.
        // GET myclass.id
        cfw.add(ByteCode.GETSTATIC, toSlashName(className), fieldName, fieldType.getSignature());

        dup(fieldType);
        if (!increment(fieldType, 1))
            throw createException("ClassMaker.CannotIncrementFieldOfType_2", fieldName, fieldType.getName());

        cfw.add(ByteCode.PUTSTATIC, toSlashName(className), fieldName, fieldType.getSignature());

        return fieldType;
    }

    /**** PostDec ****/
    
    /**
     * Gets the value of a local variable before decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>i--;<code></td>
     * <td><code>PostDec("i")</code></td></tr>
     * </table>
     * @param name the name of the member variable
     * @return the value of the variable before it is decremented
     */
    public Type PostDec(String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("PostDec(" + name+ ")");
        MakerField local = Find(name);
        return postDecLocal(local);
    }
    
    Type postDecLocal(MakerField local)
    {
        markLineNumber(); // possibly add a new line number entry.
        Type type = loadLocal(local);
        if (!increment(local, -1))
            throw createException("ClassMaker.CannotDecrementVariableOfType_2", local.getName(),  local.getType().getName());
        return type;
    }

    /**
     * Gets the value of a member variable before decrementing it.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>obj.i--;<code></td>
     * <td><code>PostDec(Get("obj"), "i")</code></td></tr>
     * </table>
     * @param type the type of the class containing the variable
     * @param name the name of the member variable
     * @return the value of the variable before if is decremented
     */
    public Type PostDec(Type reference, String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("PostDec(" + reference + ", " + name+ ")");
        MakerField field = Find(reference, name);
        return postDecField(field);
    }

    Type postDecField(MakerField field)
    {
        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();
        ClassType classType = field.getClassType();
        String className = classType.getName();

        markLineNumber(); // possibly add a new line number entry.
        // GET myclass.id
        dup(classType);
        cfw.add(ByteCode.GETFIELD, toSlashName(className), fieldName, fieldType.getSignature());

        dupunder(classType, fieldType);
        if (!increment(fieldType, -1))
            throw createException("ClassMaker.CannotDecrementFieldOfType_2", fieldName, fieldType.getName());

        // PUT myclass.id
        cfw.add(ByteCode.PUTFIELD, toSlashName(className), fieldName, fieldType.getSignature());

        return fieldType;
    }

    /**
     * Gets the value of a static member variable before decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>MyClass.i--;<code></td>
     * <td><code>PostDec("MyClass", "i")</code></td></tr>
     * </table>
     * @param className the short or fully qualified name of the class
     * @param name the name of the static member variable
     * @return the value of the variable before if is decremented
     */
    public Type PostDec(String className, String name) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
    	if (isDebugCode())
    		cfw.setDebugComment("PostDec(\"" + className + "\", " + name+ ")");
        MakerField field = Find(className, name);
        return postDecStatic(field);
    }

    Type postDecStatic(MakerField field)
    {
        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();
        ClassType classType = field.getClassType();
        String className = classType.getName();

        markLineNumber(); // possibly add a new line number entry.
        // GET myclass.id
        cfw.add(ByteCode.GETSTATIC, toSlashName(className), fieldName, fieldType.getSignature());

        dup(fieldType);
        if (!increment(fieldType, -1))
            throw createException("ClassMaker.CannotDecrementFieldOfType_2", fieldName, fieldType.getName());

        cfw.add(ByteCode.PUTSTATIC, toSlashName(className), fieldName, fieldType.getSignature());

        return fieldType;
    }

    /**** IncAt ****/
    
    /**
     * Gets the value of an array element after incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>a = ++values[2];<code></td>
     * <td><code>Set("a", IncAt(Get("values"), Literal(2)));</code></td></tr>
     * </table>
     * @param array the type of the array
     * @param index the type of the index
     * @return the value of the array element after it is incremented
     */
    public Type IncAt(Type array, Type index) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
        ArrayType arrayType = array.toArray();
        Type indexType = index; //load(index);
        if (arrayType == null)
            throw createException("ClassMaker.NotATypeOfArray_1", array.getName());
        Type elementType = arrayType.getArrayOfType();
        if (!INT_TYPE.equals(index) && !SHORT_TYPE.equals(index) && !CHAR_TYPE.equals(index) && !BYTE_TYPE.equals(index))
            throw createException("ClassMaker.ArrayIndexMustBeIntegerType_1", index.getName());
        markLineNumber(); // possibly add a new line number entry.

        //# Stack contents
        //# array index
        swap(arrayType, indexType);
        //# index array
        dupunder(indexType, arrayType);
        //# array index array
        swap(indexType, arrayType);
        //# array array index
        dupunder(arrayType, indexType);
        //# array index array index
        GetAt(array, index);
        //# array index value
        if (!increment(elementType, 1))
            throw createException("ClassMaker.CannotIncrementArrayElementOfType_1", elementType.getName());
        //# array index value+1
        dup(elementType);
        //# array index value+1 value+1
        int slot = storeAnonymousValue(elementType);
        //# array index value+1
        SetAt(array, index, elementType);
        //# -
        this.loadAnonymousValue(slot);
        //# value+1

        return elementType;
    }

    /**
     * Gets the value of an array element after decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>--obj.i;<code></td>
     * <td><code>Dec(Get("obj"), "i")</code></td></tr>
     * </table>
     * @param array the type of the array
     * @param index the type of the index
     * @return the value of the array element after it is decremented
     */
    public Type DecAt(Type array, Type index) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
        ArrayType arrayType = array.toArray();
        Type indexType = index; //load(index);
        if (arrayType == null)
            throw createException("ClassMaker.NotATypeOfArray_1", array.getName());
        Type elementType = arrayType.getArrayOfType();
        if (!INT_TYPE.equals(index) && !SHORT_TYPE.equals(index) && !CHAR_TYPE.equals(index) && !BYTE_TYPE.equals(index))
            throw createException("ClassMaker.ArrayIndexMustBeIntegerType_1", index.getName());
        markLineNumber(); // possibly add a new line number entry.

        //# Stack contents
        //# array index
        swap(arrayType, indexType);
        //# index array
        dupunder(indexType, arrayType);
        //# array index array
        swap(indexType, arrayType);
        //# array array index
        dupunder(arrayType, indexType);
        //# array index array index
        GetAt(array, index);
        //# array index value
        if (!increment(elementType, -1))
            throw createException("ClassMaker.CannotDecrementArrayElementOfType_1", elementType.getName());
        //# array index value-1
        dup(elementType);
        //# array index value-1 value-1
        int slot = storeAnonymousValue(elementType);
        //# array index value-1
        SetAt(array, index, elementType);
        //# -
        this.loadAnonymousValue(slot);
        //# value-1

        return elementType;
    }

    /**
     * Gets the value of an array element before incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>obj.i++;<code></td>
     * <td><code>PostInc(Get("obj"), "i")</code></td></tr>
     * </table>
     * @param array the type of the array
     * @param index the type of the index
     * @return the value of the array element before it is incremented
     */
    public Type PostIncAt(Type array, Type index) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
        ArrayType arrayType = array.toArray();
        Type indexType = index; //load(index);
        if (arrayType == null)
            throw createException("ClassMaker.NotATypeOfArray_1", array.getName());
        Type elementType = arrayType.getArrayOfType();
        if (!INT_TYPE.equals(index) && !SHORT_TYPE.equals(index) && !CHAR_TYPE.equals(index) && !BYTE_TYPE.equals(index))
            throw createException("ClassMaker.ArrayIndexMustBeIntegerType_1", index.getName());
        markLineNumber(); // possibly add a new line number entry.

        //# Stack contents
        //# array index
        swap(arrayType, indexType);
        //# index array
        dupunder(indexType, arrayType);
        //# array index array
        swap(indexType, arrayType);
        //# array array index
        dupunder(arrayType, indexType);
        //# array index array index
        GetAt(array, index);
        //# array index value
        dup(elementType);
        //# array index value value
        int slot = storeAnonymousValue(elementType);
        //# array index value
        if (!increment(elementType, 1))
            throw createException("ClassMaker.CannotIncrementArrayElementOfType_1", elementType.getName());
        //# array index value+1
        SetAt(array, index, elementType);
        //# -
        this.loadAnonymousValue(slot);
        //# value

        return elementType;
    }

    /**
     * Gets the value of an array element before decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr><td>Java code</td><td>ClassMaker code</td></tr>
     * <tr><td><code>obj.i--;<code></td>
     * <td><code>PostDec(Get("obj"), "i")</code></td></tr>
     * </table>
     * @param array the type of the array
     * @param index the type of the index
     * @return the value of the array element before if is decremented
     */
    public Type PostDecAt(Type array, Type index) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return null;
        ArrayType arrayType = array.toArray();
        Type indexType = index;
        if (arrayType == null)
            throw createException("ClassMaker.NotATypeOfArray_1", array.getName());
        Type elementType = arrayType.getArrayOfType();
        if (!INT_TYPE.equals(index) && !SHORT_TYPE.equals(index) && !CHAR_TYPE.equals(index) && !BYTE_TYPE.equals(index))
            throw createException("ClassMaker.ArrayIndexMustBeIntegerType_1", index.getName());
        markLineNumber(); // possibly add a new line number entry.

        //# Stack contents
        //# array index
        swap(arrayType, indexType);
        //# index array
        dupunder(indexType, arrayType);
        //# array index array
        swap(indexType, arrayType);
        //# array array index
        dupunder(arrayType, indexType);
        //# array index array index
        GetAt(array, index);
        //# array index value
        dup(elementType);
        //# array index value value
        int slot = storeAnonymousValue(elementType);
        //# array index value
        if (!increment(elementType, -1))
            throw createException("ClassMaker.CannotDecrementArrayElementOfType_1", elementType.getName());
        //# array index value-1
        SetAt(array, index, elementType);
        //# -
        this.loadAnonymousValue(slot);
        //# value

        return elementType;
    }

    /**
     * Increments a local variable by the given amount.
     * @param local the variable to be incremented
     * @param amount the amount to increment the variable
     * @return <code>false</code> if value cannot be incremented
     */
    protected boolean increment(MakerField local, int amount)
    {
        if (isPrimitive(local.getType()))
        {
            PrimitiveType prim = local.getType().toPrimitive();
            switch (prim.index)
            {
            case PrimitiveType.BYTE_INDEX:
                cfw.addILoad(local.getSlot());
                cfw.addLoadConstant(amount);
                cfw.add(ByteCode.IADD);
                cfw.add(ByteCode.I2B);
                cfw.addIStore(local.getSlot());
                return true;
            case PrimitiveType.SHORT_INDEX:
                cfw.addILoad(local.getSlot());
                cfw.addLoadConstant(amount);
                cfw.add(ByteCode.IADD);
                cfw.add(ByteCode.I2S);
                cfw.addIStore(local.getSlot());
                return true;
            case PrimitiveType.CHAR_INDEX:
                cfw.addILoad(local.getSlot());
                cfw.addLoadConstant(amount);
                cfw.add(ByteCode.IADD);
                cfw.add(ByteCode.I2C);
                cfw.addIStore(local.getSlot());
                return true;
            case PrimitiveType.INT_INDEX:
                cfw.add(ByteCode.IINC, local.getSlot(), amount);
                return true;
            case PrimitiveType.LONG_INDEX:
                cfw.addLLoad(local.getSlot());
                cfw.addLoadConstant((long) amount);
                cfw.add(ByteCode.LADD);
                cfw.addLStore(local.getSlot());
                return true;
            case PrimitiveType.FLOAT_INDEX:
                cfw.addFLoad(local.getSlot());
                cfw.addLoadConstant((float) amount);
                cfw.add(ByteCode.FADD);
                cfw.addFStore(local.getSlot());
                return true;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.addDLoad(local.getSlot());
                cfw.addLoadConstant((double) amount);
                cfw.add(ByteCode.DADD);
                cfw.addDStore(local.getSlot());
                return true;
            }
        }
        return false;
    }

    /**
     * Increments the value on top of the stack by the given amount
     * @param type the type of the value on top of the stack
     * @param amount the amount to increment the value
     * @return <code>false</code> if value cannot be incremented
     */
    protected boolean increment(Type type, int amount)
    {
        if (isPrimitive(type))
        {
            markLineNumber(); // possibly add a new line number entry.

            switch (type.toPrimitive().index)
            {
            case PrimitiveType.BYTE_INDEX:  // fall thru
                cfw.addLoadConstant(amount);
                cfw.add(ByteCode.IADD);
                cfw.add(ByteCode.I2B);
                return true;
            case PrimitiveType.SHORT_INDEX: // fall thru
                cfw.addLoadConstant(amount);
                cfw.add(ByteCode.IADD);
                cfw.add(ByteCode.I2S);
                return true;
            case PrimitiveType.CHAR_INDEX:  // fall thru
                cfw.addLoadConstant(amount);
                cfw.add(ByteCode.IADD);
                cfw.add(ByteCode.I2C);
                return true;
            case PrimitiveType.INT_INDEX:
                cfw.addLoadConstant(amount);
                cfw.add(ByteCode.IADD);
                return true;
            case PrimitiveType.LONG_INDEX:
                cfw.addLoadConstant((long) amount);
                cfw.add(ByteCode.LADD);
                return true;
            case PrimitiveType.FLOAT_INDEX:
                cfw.addLoadConstant((float) amount);
                cfw.add(ByteCode.FADD);
                return true;
            case PrimitiveType.DOUBLE_INDEX:
                cfw.addLoadConstant((double) amount);
                cfw.add(ByteCode.DADD);
                return true;
            }
        }
        return false;
    }

    //################# Statement Management ###################

    /* The bottom of the Statement stack is always a method body. */
    MethodBodyStatement bottomStatement = null;

    /* Top of the statement stack. Statements are pushed and popped from here. */
    Statement statementStack = null;

    /** Top of the statement stack. */
    public Statement topStatement()
    {
        return statementStack;
    }

    /**
     * Provides methods to set and get Label names.
     * @author dstrong
     */
    public interface Labelled
    {
        /**
         * Labels a <code>Statement</code>.
         * The statement can then be the target of a <code>Break</code> or <code>Continue</code>.
         * @param label the name of the label
         */
        void setLabel(String label);

        /**
         * The label for a <code>Statement</code>.
         * @return the name of the label
         */
        String getLabel();
    }

    /**
     * <code>Statement</code> instances form a stack of nested statements in a method.
     * This is a base class for specific statement types like <code>LoopStatement</code>.
     * @author dstrong
     */
    protected abstract class Statement implements Labelled
    {
        /* Next Statement down the statement stack. */
        private Statement next = null;

        /* Label for this statement. */
        private String label = null;

        /* The jump address for this statement. This is typically the end of the statement. */
        protected int labelTarget;

        /** The default constructor pushes this instance onto the statement stack. */
        public Statement()
        {
            next = statementStack;
            statementStack = this;
        }

        /** Is there another <code>Statement</code> nested around this one? */
        boolean hasNext()
        {
            return next != null;
        }

        /** Gets the <code>Statement</code> nested around this one. */
        Statement getNext()
        {
            return next;
        }

        public int getScopeLevel()
        {
            if (next == null)
                throw new IllegalStateException("Statement Stack should start with class MethodBodyStatement");
            return next.getScopeLevel();
        }
        
        protected abstract int getStatementEnd();

        /**
         * Jumps to a <code>Statement</code>.
         * This default implementation passess the jump request down the statement stack.
         * The label identifies which <code>Statement<code> to jump to. If the label is <code>null<code>
         * the first appropriate <code>Statement<code> will be the target.
         * The <code>jumpType</code> determines where in the statement execution will jump to.
         * This will typically be the start of the statement for continue, the end of the
         * statement for break or the end of the method for return.
         * @param jumpType <code>ClassMaker.BREAK</code>, <code>ClassMaker.CONTINUE</code>, <code>ClassMaker.RETURN</code> or <code>null</code>.
         * @param label the name of the statement to jump to
         * @return the target <code>Statement</code> or <code>null</code> if not found.
         */
        protected Statement jumpToTarget(String jumpType, String label)
        {
            if (BREAK.equals(jumpType) && getLabel() != null && getLabel().equals(label))
            {   // Break jumps to the end of the loop
                cfw.add(ByteCode.GOTO, getStatementEnd());
                return this;
            }
            else if (hasNext())
                return getNext().jumpToTarget(jumpType, label);
            else
                return null;
        }

        /* Implements Labelled. */
        public void setLabel(String label)
        {
            this.label = label;
        }

        /* Implements Labelled. */
        public String getLabel()
        {
            return label;
        }

        /** Pops the Statement off the stack. */
        protected void dispose()
        {
            if (statementStack != this) // Should not get here.
                throw new IllegalStateException("Can only dispose of top most Statement.");
            statementStack = getNext();
        }
    }

    // ##################  Method Begin End  ###################

    /**
     * Represents the body of a method.
     * An instance of this class is always created when the body of a method
     * is entered. Consequently, there will always be an instance of this class
     * at the bottom of the stack.
     */
    protected class MethodBodyStatement extends ScopeStatement
    {
        /**
         * Jumps to a <code>Statement</code>.
         * Returns this instance if the jumpTarget is <code>ClassMaker.RETURN</code>;
         * all other options should have been handleded further up the statement stack.
         * Otherwise, calls <code>super.jumpToTarget</code> which will probably return null.
         * @param jumpTarget must be <code>ClassMaker.RETURN</code>.
         * @param label the name of the statement to jump to
         * @return the target <code>Statement</code> or <code>null</code> if not found.
         */
        protected Statement jumpToTarget(String jumpTarget, String label)
        {
            if (RETURN.equals(jumpTarget) && getNext() == null)
            {
                return this;
            }
            return null;
        }

        /* Implements Labelled. */
        public void setLabel(String label)
        {
            throw createException("ClassMaker.CannotSetLabelOnMethodBlock");
        }

        protected int getStatementEnd()
        {
            return 0;
        }

        public void Begin()
        {
            bottomStatement = this;
            BeginMethod();
        }

        /**
         * Ends the body of a method.
         * Checks that the method body ends with a <code>Return</code> or <code>Throw</code>
         * statement.
         * Delegates to <code>ScopeStatement.End</code>.
         */
        public void End() throws ClassMakerException
        {
            // Save local variable descriptors to be used by the debugger.
            exitScope(getScopeLevel());
            EndMethod();
            // Pop ScopeStatement off statement stack.
            dispose();
            // Pop MethodBodyStatement off statement stack.
            bottomStatement = null;
        }

        public int getScopeLevel()
        {
            return 1;
        }

        /** Pops the Statement off the stack. */
        protected void dispose()
        {
            bottomStatement = null;
            super.dispose();
        }
    }

    // ##################  Begin End  ###################

    /**
     * Fetches the <code>ScopeStatement</code> at the top of the statement stack.
     * Casts the statement on the top of the statement stack or throws an
     * <code>IllegalStateException</code> if this is not possible.
     * @return the <code>ScopeStatement</code> on top of the stack
     */
    protected ScopeStatement topScopeStatement(String msg)
    {
        if ((topStatement() instanceof ScopeStatement))
            return (ScopeStatement) topStatement();
        throw createException(msg);
    }

    /**
     * Represents the scope of enclosed variables.
     */
    protected class ScopeStatement extends Statement
    {
        /** Break target at the end of labelled block. */
        protected int blockEnd = 0;

        public void Begin()
        {
            if (getClassFileWriter() != null) 
                blockEnd = cfw.acquireLabel();
        }

        /**
         * Ends the body of a method.
         * Checks that the method body ends with a <code>Return</code> or <code>Throw</code>
         * statement.
         */
        public void End() throws ClassMakerException
        {
            if (getClassFileWriter() != null) 
                cfw.markLabel(blockEnd);
            // Save local variable descriptors to be used by the debugger.
            exitScope(getScopeLevel());
            // Pop ScopeStatement off statement stack.
            dispose();
        }

        public int getScopeLevel()
        {
            return super.getScopeLevel() +1;
        }

        protected int getStatementEnd()
        {
            return blockEnd;
        }
    }

    // ##################  If Then Else EndIf  ###################
    /**
     * Fetches the <code>IfStatement</code> at the top of the statement stack.
     * Casts the statement on the top of the statement stack or throws an
     * <code>IllegalStateException</code> if this is not possible.
     * @return the <code>IfStatement</code> on top of the stack
     */
    protected IfStatement topIfStatement(String msg)
    {
        if ((topStatement() instanceof IfStatement))
            return (IfStatement) topStatement();
        throw createException(msg);
    }

    /**
     * Represents an <code>If Then Else </code> statement.
     * Manages the jump labels and generates the bytecode for the <code>If</code> statement.
     */
    protected class IfStatement extends Statement
    {
        /** Jump label at the end of the Then block. */
        protected int jumpThen = 0;

        /** Jump label at the end of the Else block. */
        protected int jumpElse = 0;

        /** Jump label at the end of the If-Then-Else block. */
        protected int endStatement = 0;

        /*
         * Tried implementing Elsif(condition) but Else must be called before
         * condition is evaluated so cannot be solved without daisy chaining.
         * Not worth the effort. Donald Strong 25/08/2011.
         */

        /**
         * Begins an <code>If</code> statement.
         * The subsequent code block is executed if the <code>condition</code>
         * evaluates to <code>true</code>.
         */
        public void If(Type condition) throws ClassMakerException
        {
            if (getClassFileWriter() == null) return;
            if (!BOOLEAN_TYPE.equals(condition))
            {
                dispose();
                throw createException("ClassMaker.IfConditionMustBeBoolean_1", condition.getName());
            }
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode()) cfw.setDebugComment("If");

            endStatement = cfw.acquireLabel();
            // Boolean value on stack will be 1 to execute Then block or 0 to
            // execute Else block.
            jumpThen = cfw.acquireLabel();
            cfw.add(ByteCode.IFEQ, jumpThen); // Jump over Then block if equal to zero.
        }

        /**
         * Begins an <code>Else</code> clause of an <code>If</code> statement.
         * The subsequent code block is executed if the <code>condition</code> in the
         * <code>If</code> clause evaluated to <code>false</code>.
         */
        public void Else() throws ClassMakerException
        {
            if (getClassFileWriter() == null) return;
            if (jumpElse != 0)
                throw createException("ClassMaker.ElseCalledTwice");
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode()) cfw.setDebugComment("Else");

            jumpElse = cfw.acquireLabel();
            cfw.add(ByteCode.GOTO, jumpElse);
            cfw.markLabel(jumpThen);
            jumpThen = 0;
        }

        /**
         * Ends an <code>If</code> Statement.
         * Control jumps to here if the preceeding code block is not executed.
         */
        public void EndIf() throws ClassMakerException
        {
            if (getClassFileWriter() != null)
            {
                markLineNumber(); // possibly add a new line number entry.
                if (isDebugCode()) cfw.setDebugComment("End If");

                if (jumpElse != 0)
                {
                    cfw.markLabel(jumpElse);
                }
                else
                {
                    cfw.markLabel(jumpThen);
                }
                cfw.markLabel(endStatement);
            }
            // Pop IfStatement off statement stack.
            dispose();
        }
        
        protected int getStatementEnd()
        {
        	return endStatement;
        }
    }

    /**
     * Begins an <code>If</code> statement.
     * The subsequent code block is executed if the <code>condition</code>
     * evaluates to <code>true</code>.
     * <pre>
          If(LT(Get("a"), Literal(0)));
            Set("a", Literal(0));
          EndIf();
     * </pre>
     *
     * Delegates to <code>IfStatement.If</code>.
     * @return an interface to set a Label
     */
    public Labelled If(Type condition) throws ClassMakerException
    {
        IfStatement stmt = new IfStatement();
        stmt.If(condition);
        return stmt;
    }

    /**
     * Begins an <code>Else</code> clause of an <code>If</code> statement.
     * The subsequent code block is executed if the <code>condition</code> in the
     * <code>If</code> clause evaluated to <code>false</code>.
     * <pre>
          If(LT(Get("a"), Literal(0)));
            Set("a", Literal(0));
          Else();
            Set("a", Literal(1));
          EndIf();
     * </pre>
     *
     * Delegates to <code>IfStatement.Else</code>.
     */
    public void Else() throws ClassMakerException
    {
        IfStatement stmt = topIfStatement("ClassMaker.ElseWithoutMatchingIf");
        stmt.Else();
    }

    /**
     * Ends an <ocde>If</code> Statement.
     * Control jumps to here if the preceeding code block is not executed.
     *
     * Delegates to <code>IfStatement.Else</code>.
     */
    public void EndIf() throws ClassMakerException
    {
        IfStatement stmt = topIfStatement("ClassMaker.EndIfWithoutMatchingIf");
        stmt.EndIf();

        followsReturn = true;
    }

    // #######################  Loop Statement ######################
    /**
     * Fetches the <code>LoopStatement</code> at the top of the statement stack.
     * Casts the statement on the top of the statement stack or throws an
     * <code>IllegalStateException</code> if this is not possible.
     * @return the <code>LoopStatement</code> on top of the stack
     */
    protected LoopStatement topLoopStatement(String msg)
    {
        if ((topStatement() instanceof LoopStatement))
            return (LoopStatement) topStatement();
        throw createException(msg);
    }

    /**
     * Represents a <code>Loop</code> statement.
     * Manages the jump labels and generates the bytecode for the <code>Loop</code> statement.
     */
    protected class LoopStatement extends Statement
    {
        /** Jump label for the start of the loop. */
        protected int beginLoop = 0;

        /** Jump label for the end of the loop. */
        protected int endLoop = 0;

        /** There must be at least one <code>Break</code> or equivalent within the <code>Loop</code>. */
        protected int breakCount = 0;

        /**
         * Begins a <code>Loop</code> statement.
         * Control will jump here from the <code>EndLoop</code> clause or from
         * an enclosed <code>Continue</code> statement.
         * The loop will not terminate unless there is an enclosed statement that
         * breaks out of the loop, for example, <code>While</code> or <code>Break</code>.
         */
        public void Loop() throws ClassMakerException
        {
            if (getClassFileWriter() == null) return;
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode()) cfw.setDebugComment("Loop()");

            beginLoop = cfw.acquireLabel();
            endLoop = cfw.acquireLabel();
            cfw.markLabel(beginLoop);
            cfw.add(ByteCode.NOP);
        }

        /**
         * Ends a <code>Loop</code> statement.
         * Jumps to the <code>Loop</code> clause.
         *
         * A <code>Break</code> or <code>While</code> will jump to the end of this clause;
         * thus terminating the loop.
         */
        public void EndLoop() throws ClassMakerException
        {
            if (getClassFileWriter() != null)
            {
                if (breakCount == 0)
                    throw createException("ClassMaker.LoopDoesNotContainBreak");
                markLineNumber(); // possibly add a new line number entry.

                if (isDebugCode()) cfw.setDebugComment("   Jump to begining of Loop");
                cfw.add(ByteCode.GOTO, beginLoop);

                if (isDebugCode()) cfw.setDebugComment("End of Loop");
                cfw.markLabel(endLoop);
            }
            // Pop LoopStatement off statement stack.
            dispose();
        }

        /**
         * Iterates through a <code>Loop</code> while the condition is <code>true</code>
         * Breaks out of the enclosing <code>Loop</code> when the condition is <code>false</code>.
         * The <code>While</code> clause should be the first or last in a loop; however, this is not enforced.
         * @param condition the type of the condition expression must be boolean
         */
        public ForStep While(Type condition) throws ClassMakerException
        {
            if (getClassFileWriter() == null) return null;
            if (!BOOLEAN_TYPE.equals(condition))
            {
                throw createException("ClassMaker.WhileConditionMustBeTypeBooleanNot_1", condition.getName());
            }
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode()) cfw.setDebugComment("    jump conditional to end of loop");
            // Boolean value on stack will be 1 (true) to continute Loop or 0 (false) to exit Loop.
            cfw.add(ByteCode.IFEQ, endLoop);   // Break out of the loop if equal to zero.
            breakCount++;
            return null;
        }

        /**
         * Jumps to <code>EndLoop</code> when <code>Break</code> is called.
         * The <code>label</code> must also match this statement if it is provided;
         * otherwise, passes the jump request down the statement stack.
         * @param jumpTarget <code>ClassMaker.BREAK</code>,
         *                   <code>ClassMaker.CONTINUE</code> or
         *                   <code>ClassMaker.RETURN</code>.
         * @param label the name of the statement to jump to or <code>null</code>
         * @return the target <code>Statement</code> or <code>null</code> if not found.
         */
        protected Statement jumpToTarget(String jumpTarget, String label)
        {
            if (BREAK.equals(jumpTarget) && (label == null || label.equals(getLabel())))
            {   // Break jumps to the end of the loop
                if (isDebugCode()) cfw.setDebugComment("    Break jumps to end of loop" + (label == null ? "" : label));
                cfw.add(ByteCode.GOTO, endLoop);
                breakCount++;
            }
            else if (CONTINUE.equals(jumpTarget) && (label == null || label.equals(getLabel())))
            {   // Continue jumps to the start of the loop
                if (isDebugCode()) 
                	cfw.setDebugComment("    Continue jumps to start of loop " + (label == null ? "" : label));
                continueLoop();
            }
            else
            {   // We have not found the appropriate break.
                if (BREAK.equals(jumpTarget))
                    breakCount++; // indicate that this statement has at least one break.
                // Pass the request down the statement stack
                return super.jumpToTarget(jumpTarget, label);
            }
            return this;
        }

        /** Jumps to the begining of the loop. */
        protected void continueLoop()
        {
            cfw.add(ByteCode.GOTO, beginLoop);
        }
        
        protected int getStatementEnd()
        {
        	return endLoop;
        }
    }

    /**
     * Fetches the <code>ForStatement</code> at the top of the statement stack.
     * Casts the statement on the top of the statement stack or throws an
     * <code>IllegalStateException</code> if this is not possible.
     * @return the <code>LoopStatement</code> on top of the stack
     */
    protected ForStatement topForStatement(String msg)
    {
        if ((topStatement() instanceof ForStatement))
            return (ForStatement) topStatement();
        throw createException(msg);
    }

    /**
     * Represents a <code>For</code> statement.
     * Manages the jump labels and generates the bytecode for the <code>Loop</code> statement.
     */
    protected class ForStatement extends LoopStatement implements ForWhile, ForStep
    {
        /** Jump label for the start of the step. */
        protected int beginStep = 0;

        /** Jump label for the end of the step. */
        protected int endStep = 0;

        /** Set <code>true</code> when <code>While</code> is called. */
        protected boolean calledWhile = false;

        /** Set <code>true</code> when <code>Step</code> is called. */
        protected boolean calledStep  = false;

        /** Top of the For loop statement. */
        public void Loop() throws ClassMakerException
        {
            if (getClassFileWriter() == null) return;
            markLineNumber(); // possibly add a new line number entry.
            beginLoop = cfw.acquireLabel();
            endLoop = cfw.acquireLabel();
            if (isDebugCode()) cfw.setDebugComment("For loop");
            cfw.markLabel(beginLoop);
            cfw.add(ByteCode.NOP);
        }

        /**
         * Implements a While clause of a For loop.
         *
         * Jumps to the end of the loop if the condition eveluates to true; otherwise
         * jumps to the body of the loop.
         *
         * @param condition the type of the condition must be <code>boolean</code>
         * @return an interface for the <code>Step</code> clause
         */
        public ForStep While(Type condition) throws ClassMakerException
        {
            if (getClassFileWriter() == null) return this;
            markLineNumber(); // possibly add a new line number entry.
            if (condition != null)
            {
	            if (!BOOLEAN_TYPE.equals(condition))
	            {
	                throw createException("ClassMaker.WhileConditionMustBeTypeBooleanNot_1", condition.getName());
	            }
	            if (isDebugCode()) cfw.setDebugComment("For while");
	            // Boolean value on stack will be 1 (true) to continute Loop or 0 (false) to exit Loop.
	            cfw.add(ByteCode.IFEQ, endLoop);   // Break out of the loop if equal to zero.
        	
            }
            endStep = cfw.acquireLabel();
            beginStep = cfw.acquireLabel();
            cfw.add(ByteCode.GOTO, endStep);
            cfw.markLabel(beginStep);
            breakCount++;
            calledWhile = true;
            return this;
        }

        /**
         * Implements a Step clause of a For loop.
         *
         * Jumps to the begining of the loop after evaluating the Step clause.
         *
         * @param step the type of the Step expression
         * @return an interface to set a Label
         */
        public Labelled Step(Type step) throws ClassMakerException
        {
            if (getClassFileWriter() == null) return this;
            if (isDebugCode()) cfw.setDebugComment("For step");
            if (step != null)
            	Eval(step);
            markLineNumber(); // possibly add a new line number entry.

            cfw.add(ByteCode.GOTO, beginLoop);
            cfw.markLabel(endStep);
            calledStep = true;
            return this;
        }

        /**
         * Ends a <code>For</code> statement.
         *
         * Jumps to the <code>Step</code> clause of the <code>For</code> statement.
         * A <code>Break</code> will jump to the end of this clause;
         * thus terminating the loop.
         */
        public void EndLoop() throws ClassMakerException
        {
            if (getClassFileWriter() != null)
            {
                if (breakCount == 0)
                    throw createException("ClassMaker.ForDoesNotContainBreak");
                markLineNumber(); // possibly add a new line number entry.

                if (isDebugCode()) cfw.setDebugComment("For end");
                // Handles a For() statement with or without While() and Step() clauses.
                if (!calledWhile)
                {
                    cfw.add(ByteCode.GOTO, beginLoop);
                }
                else if (!calledStep)
                {
                    cfw.add(ByteCode.GOTO, beginLoop);
                    cfw.markLabel(endStep);
                    cfw.add(ByteCode.GOTO, beginStep);
                }
                else
                    cfw.add(ByteCode.GOTO, beginStep);
                cfw.markLabel(endLoop);
            }
            // Pop ForStatement off the stack.
            dispose();
        }

        /**
         * Iterates through the loop once more, calling the Step code if appropriate.
         */
        protected void continueLoop()
        {
            if (!calledWhile)
                // Jumps to the begining of the loop
                cfw.add(ByteCode.GOTO, beginLoop);
            else
                // Jumps to the Step code and then to the begining of the loop
                cfw.add(ByteCode.GOTO, beginStep);
        }
    }

    /**
     * Begins a <code>Loop</code> statement.
     * Control will jump here from the <code>EndLoop</code> clause or from
     * an enclosed <code>Continue</code> statement.
     * The loop will not terminate unless there is an enclosed statement that
     * breaks out of the loop, for example, <code>While</code> or <code>Break</code>.
     * <pre>
          Loop();
            If(LE(Get("n"), Literal(0)));
              Break();
            EndIf();
            Eval(Set("x", Mult(Get("x"), Get("n"))));
            Eval(Dec("n"));
          EndLoop();
     * </pre>
     * Delegates to <code>LoopStatement.Loop</code>.
     * @return an interface to set a Label
     */
    public Labelled Loop() throws ClassMakerException
    {
        LoopStatement stmt = new LoopStatement();
        stmt.Loop();
        return stmt;
    }

    /**
     * Ends a <code>Loop</code> statement.
     * Jumps to the <code>BeginLoop</code> clause.
     *
     * A <code>Break</code> or <code>While</code> will jump to the end of this clause;
     * thus terminating the loop.
     * Delegates to <code>LoopStatement.EndLoop</code>.
     */
    public void EndLoop() throws ClassMakerException
    {
        LoopStatement stmt = topLoopStatement("ClassMaker.EndLoopWithoutMatchingLoop");
        stmt.EndLoop();

        followsReturn = false;
    }

    /**
     * Iterates through a <code>Loop</code> while the condition is <code>true</code>
     * Breaks out of the enclosing <code>Loop</code> when the condition is <code>false</code>.
     * The <code>While</code> clause should be the first or last in a loop; however, this is not enforced.
     * <pre>
          Loop();
            While(GT(Get("n"), Literal(0)));
            Eval(Set("x", Mult(Get("x"), Get("n"))));
            Eval(Dec("n"));
          EndLoop();
     * </pre>
     * Delegates to <code>LoopStatement.While</code>.
     * @param condition the type of the condition expression must be boolean
     */
    public void While(Type condition) throws ClassMakerException
    {
        LoopStatement stmt = topLoopStatement("ClassMaker.WhileMustBeWithinLoop");
        stmt.While(condition);
    }

    /**
     * Start of a <code>For</code> loop.
     * </br>
     * Iterates through a <code>For</code> loop while the condition is <code>true</code>
     * and evaluates the step expression each time.
     * Used in a daisy chain like this.
     * <pre>
     *    For( <expression> ).While( <condition> ).Step( <increment> );
     * </pre>
     * Breaks out of the enclosing <code>For</code> loop when the condition is <code>false</code>.
     * <pre>
          Declare("n", int.class)
          For(Set("n", 5)).While(LE(Get("n"), Literal(0))).Step(Dec("n"));
            Set("x", Mult(Get("x"), Get("n")));
          EndFor();
     * </pre>
     * Delegates to <code>LoopStatement.For</code>.
     * @param declare the type of the initialization expression
     */
    public ForWhile For(Type declare) throws ClassMakerException
    {
    	if (declare != null)
    		Eval(declare);
        ForStatement stmt = new ForStatement();
        stmt.Loop();
        return stmt;
    }

    /**
     * Interface for the <code>While</code> part of a <code>For</code> loop.
     */
    public interface ForWhile
    {
        /**
         * The <code>While</code> part of a <code>For</code> loop.
         * </br>
         * Used in a daisy chain like this.
         * <pre>
         *    For( <expression> ).While( <condition> ).Step( <increment> );
         * </pre>
         * @param condition the <code>Type</code> of the condition expression
         * @return an interface to allow the <code>For</code> statement to be labeled
         * @throws ClassMakerException if the condition type is not boolean
         */
        ForStep While(Type condition) throws ClassMakerException;
    }

    /**
     * Interface for the <code>Step</code> part of a <code>For</code> loop.
     */
    public interface ForStep
    {
        /**
         * The <code>Step</code> part of a <code>For</code> loop.
         * </br>
         * Used in a daisy chain like this.
         * <pre>
         *    For( <expression> ).While( <condition> ).Step( <increment> );
         * </pre>
         * @param step the <code>Type</code> of the increment expression
         * @return an interface to allow the <code>For</code> statement to be labeled
         * @throws ClassMakerException
         */
        Labelled Step(Type step) throws ClassMakerException;
    }

    /**
     * Ends a <code>Loop</code> statement.
     * </br>
     * Jumps to the <code>BeginLoop</code> clause.
     * A <code>Break</code> or <code>While</code> will jump to the end of this clause;
     * thus terminating the loop.
     * Delegates to <code>LoopStatement.EndLoop</code>.
     */
    public void EndFor() throws ClassMakerException
    {
        ForStatement stmt = topForStatement("ClassMaker.EndForWithoutMatchingFor");
        stmt.EndLoop();

        followsReturn = false;
    }

    /** Breaks to the end of the nearest enclosing <code>Loop</code> or <code>Switch</code> statement. */
    public void Break() throws ClassMakerException
    {
        Break(null);
    }

    /** Breaks to the end of the enclosing statement with the given label.
     * <pre>
       Loop().setLabel("LOOP");
           Switch(Get("x"));
           {
           Case(0);
               Set("y", Literal(1));
               Break();
           Case(1);
               Set("y", Literal(2));
               Break();
           Default();
               Set("y", Literal(0));
               Break("LOOP");
           }
           EndSwitch();
           Inc("x");
       EndLoop();
     * </pre>
     */
    public void Break(String label) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return;
   	   if (isDebugCode()) 
   		   cfw.setDebugComment("Break(" + (label == null ? "" : label) + ")");
        Statement stmt = topStatement();
        markLineNumber(); // possibly add a new line number entry.
        if (stmt.jumpToTarget(BREAK, label) == null)
        {
        	if (label == null)
        		throw createException("ClassMaker.BreakWhileNotInLoopOrSwitch");
        	else
        		throw createException("ClassMaker.CouldNotFindTargetLabelForBreak_1", label);
        }
        
    }

    /** Continues the nearest enclosing <code>Loop<code> statement. */
    public void Continue() throws ClassMakerException
    {
        Continue(null);
    }

    /** Continues the enclosing <code>Loop<code> statement with the given label.
     * @param label the label of the <code>Loop<code> statement
     */
    public void Continue(String label) throws ClassMakerException
    {
        if (getClassFileWriter() == null) return;
    	   if (isDebugCode()) 
       		   cfw.setDebugComment("Continue(" + (label == null ? "" : label) + ")");
        Statement stmt = topStatement();
        markLineNumber(); // possibly add a new line number entry.
        if (stmt.jumpToTarget(CONTINUE, label) == null)
            throw createException("ClassMaker.ContinueWhileNotInLoop");
    }

    /**
     * Fetches the <code>SwitchStatement</code> at the top of the statement stack.
     * </br>
     * Casts the statement on the top of the statement stack or throws an
     * <code>IllegalStateException</code> if this is not possible.
     * @return the <code>SwitchStatement</code> on top of the stack
     */
    protected SwitchStatement topSwitchStatement(String msg)
    {
        if ((topStatement() instanceof SwitchStatement))
            return (SwitchStatement) topStatement();
        else
            throw createException(msg);
    }

    //################# Switch Statement ########################
    /**
     * Represents a <code>Switch</code> statement.
     * Manages the case keys and generates the bytecode for the switch statement.
     */
    protected class SwitchStatement extends Statement
    {
        int beginSwitch = 0;
        int endSwitch = 0;
        int defaultSwitch = 0;
        int[] cases = new int[16];
        int caseSize = 0;
        String label = null;
        short startLineNumber;

        /**
         * Begins a <code>Switch</code> statement.
         * </br>
         * The type of the selector must be int, char, short or byte.
         * The bytecode for the switch is added in <code>EndSwitch</code>,
         * after the bytecode for each case clause has been added,
         * so we jump to <code>EndSwitch</code>.
         * @param switchType the type of the selector for the switch
         */
        public void Switch(Type switchType)
        {
            if (getClassFileWriter() == null) return;
            checkSwitchType(switchType);
            markLineNumber(); // possibly add a new line number entry.
            startLineNumber = (short)getSourceLine().getLineNumber();
            beginSwitch = cfw.acquireLabel();
            endSwitch = cfw.acquireLabel();
            if (cfw.isDebugCode()) 
            	cfw.setDebugComment("Switch("+switchType+");");
            cfw.add(ByteCode.GOTO, beginSwitch);
        }

        /**
         * Adds a <code>Case</code> clause of a <code>Switch</code> statement.
         * </br>
         * The switch statement will jump here if the switch value matches the given key.
         * Bytecode is generated to mark the jump offset and insert it and the key
         * into the <code>cases</code> table.
         * @param caseKey the selector which will cause the switch statement to jump to this case
         */
        public void Case(int caseKey)
        {
            if (getClassFileWriter() == null) return;
            if (cfw.isDebugCode()) 
            	cfw.setDebugComment("Case("+caseKey+");");
            markLineNumber(); // possibly add a new line number entry.
            int caseLabel = cfw.acquireLabel();
            cfw.markLabel(caseLabel);

            insertCaseKey(caseKey, caseLabel);
        }

        /**
         * Adds a <code>Default</code> clause of a <code>Switch</code> statement.
         * </br>
         * The switch statement will jump here if none of the other cases apply.
         *
         * Bytecode is generated to mark the jump offset.
         */
        public void Default()
        {
            if (getClassFileWriter() == null) return;
            if (cfw.isDebugCode()) 
            	cfw.setDebugComment("Default();");
            if (defaultSwitch != 0)
                throw createException("ClassMaker.MoreThanOneDefaultInSwitch");
            markLineNumber(); // possibly add a new line number entry.

            defaultSwitch = cfw.acquireLabel();
            cfw.markLabel(defaultSwitch);
        }

        /**
         * Ends a <code>Switch</code> statement.
         * </br>
         * The switch statement jumps here before being redirected to the appropriate
         * code block.
         * </br>
         * Byte code is generated for either a Table Switch or a Lookup Switch
         * depending upon whether the case keys are contiguous. Control
         * will jump to the end of this code if <code>Break</code> is called.
         */
        public void EndSwitch()
        {
            if (getClassFileWriter() == null) return;
            if (caseSize == 0)
            	throw createException("ClassMaker.NoCaseClauseInSwitch");
            if (cfw.isDebugCode()) 
            	cfw.setDebugComment("EndSwitch();");
            if (defaultSwitch == 0)
            {   // Ensure there is a default option that does nothing.
            	Default();
            	Break();
            }

            cfw.addLineNumberEntry(startLineNumber);
            cfw.markLabel(beginSwitch);
            // Use a Table Switch if the keys are contiguous; otherwise use a Lookup Switch.
            if (isContiguous())
            	createTableSwitch();
            else
            	createLookupSwitch();

            cfw.markLabel(endSwitch);
            dispose();
        }
        
        protected int getStatementEnd()
        {
        	return endSwitch;
        }

        /** Doubles the size of the cases array. */
        protected void expand()
        {
            int[] tmp = new int[cases.length * 2];
            System.arraycopy(cases, 0, tmp, 0, cases.length);
            cases = tmp;
        }

        /**
         * Checks that the switch type is int, char, short or byte.
         * @param switchType the type of the selector for the switch
         */
        protected void checkSwitchType(Type switchType)
        {
            if (!INT_TYPE.equals(switchType) && !CHAR_TYPE.equals(switchType) &&
                !SHORT_TYPE.equals(switchType) && !BYTE_TYPE.equals(switchType))
                throw createException("ClassMaker.SwitchTypeMustBeNumberNot_1", switchType.getName());
        }

        /** Returns <code>true</code> if the case keys form a contigous sequence. */
        protected boolean isContiguous()
        {
            for (int i = 2; i < caseSize; i += 2)
            {
                if (cases[i - 2] + 1 != cases[i])
                    return false;
            }
            return true;
        }

        /**
         * Inserts a case key into the sequence for this <code>Switch</code>.
         * @param key the case key to be inserted
         * @param label the jump offset corresponding to the given key
         */
        protected void insertCaseKey(int key, int label)
        {
            // Expand array if required.
            if (caseSize + 2 > cases.length)
                expand();

            // insert key & label into correct place in array.
            int i;
            for (i = caseSize; i > 0; i -= 2)
            {
                if (cases[i - 2] > key)
                {
                    cases[i] = cases[i - 2];
                    cases[i + 1] = cases[i - 1];
                    continue;
                }
                else if (cases[i - 2] == key)
                    throw createException("ClassMaker.DuplicateCaseKey_1", Integer.toString(key));
                break;
            }
            cases[i] = key;
            cases[i + 1] = label;
            caseSize += 2;
        }

        /** Generates the bytecode for a <code>Switch<code> statement with contiguous keys. */
       protected void createTableSwitch()
       {
    	   if (cfw.isDebugCode()) 
    		   cfw.setDebugComment("Table Switch");
            int low = cases[0];
            int high = cases[caseSize - 2];
            int startSwitch = cfw.addTableSwitch(low, high);
            cfw.addTableSwitchDefaultLabel(startSwitch, defaultSwitch);
            //int prev = cases[0] - 1;
            int prev = -1; // first key is always zero
            for (int i = 0; i < caseSize; i += 2)
            {
                int entry = i / 2;
                int key = cases[i] - low;
                int label = cases[i + 1];
                if (prev == key)
                    throw new IllegalStateException("TableSwitch duplicate case key:" + key);
                if (prev + 1 != key)
                    throw new IllegalStateException("TableSwitch case keys are not contiguous, case " + prev + ": case" + key + ":");
                cfw.addTableSwitchCaseLabel(startSwitch, entry, label);
                prev = key;
            }
        }

       /** Generates the bytecode for a <code>Switch<code> statement with <b>non-</b>contiguous keys. */
        protected void createLookupSwitch()
        {
     	   if (cfw.isDebugCode()) 
    		   cfw.setDebugComment("Lookup Switch");
            int startSwitch = cfw.addLookupSwitch(caseSize / 2);
            cfw.addLookupSwitchDefaultLabel(startSwitch, defaultSwitch);
            int prev = cases[0] - 1;
            for (int i = 0; i < caseSize; i += 2)
            {
                int entry = i / 2;
                int key = cases[i];
                int label = cases[i + 1];
                if (prev == key)
                    throw new IllegalStateException("LookupSwitch duplicate case key:" + key);
                if (prev > key)
                    throw new IllegalStateException("TableSwitch case keys must be in ascending order, case " + prev + ": case " + key + ":");
                cfw.addLookupSwitchCaseLabel(startSwitch, entry, key, label);
                prev = key;
            }
        }

        /**
         * Jumps to <code>EndSwitch</code> when <code>Break</code> is called.
         * </br>
         * The <code>label</code> must also match this statement if it is provided;
         * otherwise, passess the jump request down the statement stack.
         * @param jumpTarget <code>ClassMaker.BREAK</code>, <code>ClassMaker.CONTINUE</code>, <code>ClassMaker.RETURN</code> or <code>null</code>.
         * @param label the name of the statement to jump to or <code>null</code>
         * @return the target <code>Statement</code> or <code>null</code> if not found.
         */
        protected Statement jumpToTarget(String jumpTarget, String label)
        {
            if (BREAK.equals(jumpTarget) && (label == null || label.equals(this.label)))
            {
                cfw.add(ByteCode.GOTO, endSwitch);
                return this;
            }
            return super.jumpToTarget(jumpTarget, label);
        }
    }

    /**
     * Begins a <code>Switch</code> statement.
     * <pre>
         Switch(Get("x"));
         {
         Case(0);
             Set("y", Literal(1));
             Break();
         Case(2);
             Set("y", Literal(2));
             Break();
         Case(4);
             Set("y", Literal(3));
             Break();
         Default();
             Set("y", Literal(0));
             Break();
        }
        EndSwitch();
     * </pre>
     * The switchType must be an <code>int</code> after numeric promotion.
     * Delegates to <code>SwitchStatement.Switch</code>.
     * @param switchType the type of the selector for the switch
     * @return an interface to set a Label
     */
    public Labelled Switch(Type type)
    {
        SwitchStatement stmt = new SwitchStatement();
        stmt.Switch(type);
        return stmt;
    }

    /**
     * Adds a <code>Case</code> clause of a <code>Switch</code> statement.
     * </br>
     * The switch statement will jump here if the switch value matches the given key.
     * Delegates to <code>SwitchStatement.Case</code>.
     * @param key the selector which will cause the switch statement to jump to this case
     */
    public void Case(int key)
    {
        SwitchStatement stmt = topSwitchStatement("ClassMaker.CaseWhileNotInSwitch");
        stmt.Case(key);
    }

    /**
     * Adds a <code>Default</code> clause of a <code>Switch</code> statement.
     * </br>
     * The switch statement will jump here if none of the other cases apply.
     * Delegates to <code>SwitchStatement.DefaultCase</code>.
     */
    public void Default()
    {
        SwitchStatement stmt = topSwitchStatement("ClassMaker.DefaultWhileNotInSwitch");
        stmt.Default();
    }

    /**
     * Ends a <code>Switch</code> statement.
     * </br>
     * Delegates to <code>SwitchStatement.EndSwitch</code>.
     */
    public void EndSwitch()
    {
        SwitchStatement stmt = topSwitchStatement("ClassMaker.EndSwitchWhileNotInSwitch");
        stmt.EndSwitch();
        followsReturn = false;
    }

    /**
     * Represents a <code>Try Catch Finally</code> statement.
     * Assists the generation of code for the statement by managing the
     * jump addresses and subroutines.
     */
    protected class TryCatchFinally extends Statement
    {
        /* Start of the try block is a parameter to the exception handlers. */
        int startTryBlock = 0;

        /* End of the try block is a parameter to the exception handlers. */
        int endTryBlock = 0;

        /* Jump to the end of the catch block from the try block and each exception handler. */
        int endCatchBlock = 0;

        /* Reference to the finally subroutine which is called from many places. */
        int finallySubroutine = 0;
        int startFinallyBlock = 0;

        /* An anonomous local variable holds the return PC for the finally subroutine. */
        int finallyReturnSlot = 0;
        int endFinallyBlock = 0;
        
        int finalyExceptionSlot = -1;
        
        /**
         * Begins a <code>Try Catch Finally</code> block.
         * </br>
         * Marks the start of the try block.
         */
        public void Try()
        {
            if (getClassFileWriter() == null) return;
            if (isDebugCode())
            	cfw.setDebugComment("Try();");
            startTryBlock = cfw.acquireLabel();
            endCatchBlock = cfw.acquireLabel();
            cfw.markLabel(startTryBlock);
        }

        /**
         * Catch an Exception type.
         * </br>
         * Catches the given Exception type and stores it in a local variable with the given name.
         * Also marks the begining of a block of code to handle the exception.
         * @param exceptionType the type of exception handled by this block of code
         * @param name the local variable name for the exception
         */
        public void Catch(Type exceptionType, String name) throws ClassMakerException
        {
            if (getClassFileWriter() == null) return;
            if (isDebugCode())
            	cfw.setDebugComment("Catch(" + exceptionType + ", " + name  + ");");
            endTryCatchBlock();

            // catch (Exception ex)
            int catchBlock = cfw.acquireLabel();
            String exceptionName = exceptionType.getName();
            cfw.addExceptionHandler(startTryBlock, endTryBlock, catchBlock, exceptionName);
            cfw.markLabel(catchBlock);
            cfw.adjustStackTop(1); // exception pointer pushed onto stack.
            markLineNumber(); // possibly add a new line number entry.

            Declare(name, exceptionType, 0);
            Eval(Set(name, exceptionType));
        }

        protected void endTryCatchBlock2()
        {
            if (endTryBlock == 0)
            {
                endTryBlock = cfw.acquireLabel();
                cfw.markLabel(endTryBlock);
            }
            finalyExceptionSlot = storeAnonymousValue(OBJECT_TYPE);
            // initialise slot
            // Jump over remaining catch and finally blocks.
            cfw.add(ByteCode.GOTO, endCatchBlock);
        }

       /**
         * Starts a Finaly block.
         * </br>
         * Begins a subroutine that will always be executed regardless of the execution path.
         * The finally sunroutine is called:
         * <UL>
         *   <LI>after execution of the Try block completes normally</LI>
         *   <LI>after a Catch clause processes an exception</LI>
         *   <LI>as appropriate when Break, Continue or Return methods are called</LI>
         *   <LI>whenever an exception passes through the method without being caught.</LI>
         * </UL>
         */
        public void Finally()
        {
            if (getClassFileWriter() == null) return;
            if (isDebugCode())
            	cfw.setDebugComment("Finally();");
            endTryCatchBlock();

            // Start finaly block
            int catchBlockAll = cfw.acquireLabel();
            cfw.addExceptionHandler(startTryBlock, endTryBlock, catchBlockAll, null);
            cfw.markLabel(catchBlockAll);
            // An exception pointer has been pushed onto the stack.
            cfw.adjustStackTop(1);
            finallySubroutine = cfw.acquireLabel();
            markLineNumber(); // possibly add a new line number entry.

            // Store the exception pointer in an anonomous local variable.
            if (cfw.isDebugCode())
            	cfw.setDebugComment("Store reference to exception");
            int finalyExceptionAddress = storeAnonymousValue(OBJECT_TYPE);

            // Jump to the finally subroutine
            callFinallySubroutine();

            // Rethrow the exception.
            if (cfw.isDebugCode())
            	cfw.setDebugComment("Load reference to exception");
            loadAnonymousValue(finalyExceptionAddress);
            if (cfw.isDebugCode())
            	cfw.setDebugComment("Rethrow exception");
            cfw.add(ByteCode.ATHROW);

            // Finaly subroutine
            if (cfw.isDebugCode())
            	cfw.setDebugComment("finally subroutine");
            cfw.markLabel(finallySubroutine);

            // Store return address in an annonomous local variable.
            finallyReturnSlot = storeAnonymousValue(OBJECT_TYPE);
        }

        /**
         * Generates the bytecode to end a <code>Try Catch Finally</code> block.
         * The <code>Try</code> block and all preceeding <code>Catch</code> blocks jump to here.
         * Completes from the finally subroutine and then calls it.
         */
        public void EndTry()
        {
            if (getClassFileWriter() != null)
            {
                if (cfw.isDebugCode()) 
                	cfw.setDebugComment("EndTry();");
                if (finallyReturnSlot != 0)
                {
                    MakerField local = localTable.get(finallyReturnSlot);
                    cfw.add(ByteCode.RET, local.getSlot());
                }
                cfw.markLabel(endCatchBlock);
                callFinallySubroutine();
            }
            dispose();
        }

        /**
         * Generates bytecode at the start of a <code>Catch</code> block.
         * </br>
         * Marks the bottom of the <code>Try</code> block so it can be used in
         * exception handlers.
         * Jumps over the following <code>Catch</code> blocks.
         */
        protected void endTryCatchBlock()
        {
            if (endTryBlock == 0)
            {
                endTryBlock = cfw.acquireLabel();
                cfw.markLabel(endTryBlock);
            }
            // Jump over remaining catch and finally blocks.
            cfw.add(ByteCode.GOTO, endCatchBlock);
        }

        /**
         * Jump to the finally subroutine.
         */
        protected void callFinallySubroutine()
        {
            if (finallySubroutine != 0)
            {
            	if (cfw.isDebugCode())
            		cfw.setDebugComment("jump to finally subroutine");
                cfw.add(ByteCode.JSR, finallySubroutine);
            }
        }
        
        protected int getStatementEnd()
        {
        	return endCatchBlock;
        }

    }

    /**
     * Fetches the <code>TryCatchFinally</code> statement at the top of the statement stack.
     * </br>
     * Casts the statement on the top of the statement stack or throws an
     * exception if this is not possible.
     * @return the <code>TryCatchFinally</code> on top of the stack
     */
    protected TryCatchFinally topTryCatchFinally(String msg)
    {
        if ((topStatement() instanceof TryCatchFinally))
            return (TryCatchFinally) topStatement();
        else
            throw createException(msg);
    }

    /**
     * Begins a <code>Try Catch Finally</code> block.
     * </br>
     * Begins a block of code where exceptions that are thrown
     * may be caught be the subseqent <code>Catch</code> clauses.
     * <pre>
        Try();
        {
            If(LT(Get("x"), Literal(0)));
                Throw(New(FileNotFoundException.class).Init(Push()));
            EndIf();
        }
        Catch(FileNotFoundException.class, "ex1");
        {
            Set("x", Literal(10000));
        }
        Finally();
        {
            Inc("x");
        }
        EndTry();
     * </pre>
     * Delegates to <code>TryCatchFinally.Try</code>.
     * @return an interface to set a Label
     */
    public Labelled Try()
    {
        TryCatchFinally stmt = new TryCatchFinally();
        stmt.Try();
        return stmt;
    }

    /**
     * Catches the Exception and stores it in a the named local variable.
     * </br>
     * Catches the given Exception and stores it in a local variable with the given name.
     * Also marks the begining of a block of code to handle the exception.
     * Delegates to <code>TryCatchFinally.Catch</code>.
     * @param exceptionName the name of the type of exception handled by this block of code
     * @param name the local variable name for the exception
     */
    public void Catch(String exceptionName, String name)
    {
        TryCatchFinally stmt = topTryCatchFinally("ClassMaker.CatchWithoutTry");
        DeclaredType declared = stringToDeclaredClass(exceptionName);
        ClassType exceptionType = declared.getClassType();
        stmt.Catch(exceptionType, name);
    }

    /**
     * Catches the Exception represented by the java Class.
     * </br>
     * Catches the given Exception type and stores it in a local variable with the given name.
     * Also marks the begining of a block of code to handle the exception.
     * Delegates to <code>TryCatchFinally.Catch</code>.
     * @param javaClass the <code>Class</code> of the exception to catch
     * @param name the local variable name to which to assign the exception
     */
    public void Catch(Class javaClass, String name) throws ClassMakerException
    {
        ClassType exceptionType = classToClassType(javaClass);
        TryCatchFinally stmt = topTryCatchFinally("ClassMaker.CatchWithoutTry");
        stmt.Catch(exceptionType, name);
    }

    /**
     * Starts a Finally block.
     * </br>
     * Begins a block of code that will always be executed.
     * The code in the block will be called:
     * <LU>
     *   <LI>at the end of the <code>Try</code> block</LI>
     *   <LI>at the end of each <code>Catch</code> block</LI>
     *   <LI>when <code>Return</code> is called</LI>
     *   <LI>when <code>Break</code> or <code>Continue</code> is called</LI>
     *   <LI>when an exception is thrown</LI>
     * </LU>
     * Delegates to <code>TryCatchFinally.Finally()</code>.
     */
    public void Finally() throws ClassMakerException
    {
        TryCatchFinally stmt = topTryCatchFinally("ClassMaker.FinallyWithoutTry");
        stmt.Finally();
    }

    /**
     * Ends a <code>Try Catch Finally</code> block.
     * </br>
     * Delegates to <code>TryCatchFinally.EndTry()</code>.
     */
    public void EndTry() throws ClassMakerException
    {
        TryCatchFinally stmt = topTryCatchFinally("ClassMaker.EndTryWithoutTry");
        stmt.EndTry();

        followsReturn = false;
    }

    // Nameless local variables for storing intermediate values.
    
    /**
     * Stores a value in a nameless local variable.
     * </br>
     * The value may be retrieved using the slot offset.
     * The type determines how may slots are reserved.
     * @param type type of value being stored.
     */
    protected int storeAnonymousValue(Type type) throws ClassMakerException
    {
        DeclaredType declared = getDeclaredType(type);
        int index = addLocal(null, declared, 0);
        MakerField local = lookupLocal(index);
        storeLocal(local, type);
        return index;
    }

    /**
     * Loads a value from a nameless local variable.
     * @param index the index of the anonymous field holding the value
     * @return type of the value being loaded
     */
    protected Type loadAnonymousValue(int index) throws ClassMakerException
    {
        MakerField local = lookupLocal(index);
        return loadLocal(local);
    }

    // Shortcut Logic expressions

    /**
     * Represents a logical And or logical Or expression.
     * </br>
     * Holds the jump addresses for an expression that includes shortcut AND
     * and shortcut OR logic.
     */
    public static class AndOrExpression
    {
    	public AndOrExpression prev = null;
        /** jump address for AND logic */
        public int jumpAnd = 0;
        /** jump address for OR logic */
        public int jumpOr = 0;
    };

    /**
     * Contains an expression that includes shortcut AND and OR logic.
     * </br>
     * If the preceeding <code>andOr</code> expression is shortcut then
     * evaluation of the <code>cond</code> expression will be jumped over.
     * <pr/>
     * The following code generates bytecode for <code>a && b || c</code>. <br/>
     <pre>
     Logic(OrElse(AndThen(Get("a")), Get("b")), Get("c"))
     </pre>
     * This method creates a label for the shortcut expression to jump to.
     * @param andOr preceeding logical expression
     * @param cond last conditional expression
     * @return return type is always boolean
     */
    public Type Logic(AndOrExpression andOr, Type cond)
    {
        if (getClassFileWriter() == null) return null;
        if (!BOOLEAN_TYPE.equals(cond))
            throw createException("ClassMaker.LogicConditionMustBeBoolean_1", cond.getName());

        markAndThenLabel(andOr);
    	markOrElseLabel(andOr);

        return cond;
    }
    
    private void markAndThenLabel(AndOrExpression andOr)
    {
        if (andOr != null && andOr.jumpAnd != 0)
        {
        	if (cfw.isDebugCode()) cfw.setDebugComment("preserve result on stack");
        	int temp = cfw.acquireLabel();
        	cfw.add(ByteCode.GOTO, temp);
            cfw.markLabel(andOr.jumpAnd);
            andOr.jumpAnd = 0;
        	if (cfw.isDebugCode()) cfw.setDebugComment("|| expression evaluates to false");
            cfw.add(ByteCode.ICONST_0);
            cfw.markLabel(temp);
        }
    }

    private void markOrElseLabel(AndOrExpression andOr)
    {
        if (andOr != null && andOr.jumpOr != 0)
        {
        	if (cfw.isDebugCode()) cfw.setDebugComment("preserve result on stack");
        	int temp = cfw.acquireLabel();
        	cfw.add(ByteCode.GOTO, temp);
            cfw.markLabel(andOr.jumpOr);
            andOr.jumpOr = 0;
        	if (cfw.isDebugCode()) cfw.setDebugComment("|| expression evaluates to true");
            cfw.add(ByteCode.ICONST_1);
            cfw.markLabel(temp);
        }
    }

    /**
     * Appends a <code>cond &&</code> logic expression to a preceeding expression.
     * </br>
     * If the preceeding <code>andOr</code> expression evaluates to true the
     * <code>cond</code> will be evaluated.
     * If the preceeding <code>andOr</code> expression evaluates to false then
     * evaluation of the <code>cond</code> expression will be jumped over.
     * <pr/>
     * The following code generates bytecode for <code>a && b && c</code>. <br/>
     <pre>
     Logic(AndThen(AndThen(Get("a")), Get("b")), Get("c"))
     </pre>
     * @param previous preceeding logical expression
     * @param cond next conditional expression
     * @return logic expression including shortcut logic
     */
    public AndOrExpression AndThen(AndOrExpression previous, Type cond)
    {
        if (getClassFileWriter() == null) return null;
        if (!BOOLEAN_TYPE.equals(cond))
            throw createException("ClassMaker.AndThenConditionMustBeBoolean_1", cond.getName());

        // handle change from && to || operator
        markOrElseLabel(previous);
        
        AndOrExpression andOr = new AndOrExpression();
        andOr.prev = previous;  // Chain similar shortcut operators
        // Jump to the same label as the previous AndThen expression, if available.
        andOr.jumpAnd = (previous == null || previous.jumpAnd == 0) ? cfw.acquireLabel() : previous.jumpAnd;
        //dup(BOOLEAN_TYPE); // Duplicate value so it is on stack at and of jump.
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("&& Jump if false on stack");
        cfw.add(ByteCode.IFEQ, andOr.jumpAnd); // Jump over other expression if
                                                // cond is false.
        //cfw.add(ByteCode.POP); // Previous value now irrelevant so remove from
                                // stack.

        markLineNumber(); // possibly add a new line number entry.

        return andOr;
    }

    /**
     * Creates a <code>cond &&</code> logic expression.
     * </br>
     * If the <code>cond</code> expression evaluates to true the
     * following logic expression will be evaluated.
     * If the <code>cond</code> expression evaluates to false then
     * evaluation of the following expression will be jumped over.
     * <pr/>
     * The following code generates bytecode for <code>a && b</code>. <br/>
     <pre>
     Logic(AndThen(Get("a")), Get("b"))
     </pre>
     * @param cond next conditional expression
     * @return logic expression including shortcut logic
     */
    public AndOrExpression AndThen(Type cond)
    {
    	return AndThen(null, cond);
    }

    /**
     * Appends a <code>cond ||</code> logic expression to a preceeding expression.
     * </br>
     * If the preceeding <code>andOr</code> expression evaluates to false the
     * <code>cond</code> will be evaluated.
     * If the preceeding <code>andOr</code> expression evaluates to true then
     * evaluation of the <code>cond</code> expression will be jumped over.
     * <pr/>
     * The following code generates bytecode for <code>a || b || c</code>. <br/>
     <pre>
     Logic(OrElse(OrElse(Get("a")), Get("b")), Get("c"))
     </pre>
     * @param andOr preceeding logical expression
     * @param cond next conditional expression
     * @return logic expression including shortcut logic
     */
    public AndOrExpression OrElse(AndOrExpression previous, Type cond)
    {
        if (getClassFileWriter() == null) return null;
        if (!BOOLEAN_TYPE.equals(cond))
            throw createException("ClassMaker.OrElseConditionMustBeBoolean_1", cond.getName());

        // handle change from && to || operator
        markAndThenLabel(previous);
        
        AndOrExpression andOr = new AndOrExpression();
        andOr.prev = previous;  // Chain similar shortcut operators
        // Jump to the same label as the previous OrElse expression, if available.
        andOr.jumpOr = (previous == null || previous.jumpOr == 0) ? cfw.acquireLabel() : previous.jumpOr;
        
        //dup(BOOLEAN_TYPE); // Duplicate cond so it is on stack at end of jump.
        if (cfw.isDebugCode()) 
        	cfw.setDebugComment("|| Jump if true on stack");
        cfw.add(ByteCode.IFNE, andOr.jumpOr); // Jump over other expression if cond is true.
        //cfw.add(ByteCode.POP); // Previous cond now irrelevant so remove from stack.

        markLineNumber(); // possibly add a new line number entry.

        return andOr;
    }

    /**
     * Creates a <code>cond ||</code> logic expression.
     * </br>
     * If the <code>cond</code> expression evaluates to false the
     * following logic expression will be evaluated.
     * If the <code>cond</code> expression evaluates to true then
     * evaluation of the following expression will be jumped over.
     * <pr/>
     * The following code generates bytecode for <code>a || b</code>. <br/>
     <pre>
     Logic(OrElse(Get("a")), Get("b"))
     </pre>
     * @param cond next conditional expression
     * @return logic expression including shortcut logic
     */
    public AndOrExpression OrElse(Type cond)
    {
    	return OrElse(null, cond);
    }

    /**
     * Creates a formatted ClassMaker exception.
     * @param key the key to lookup in the resource bundle
     * @return a formatted ClassMakerException.
     */
    public ClassMakerException createException(String key)
    {
        ExceptionFactory factory = getFactory().getExceptionFactory();
        return factory.createException(getSourceLine(), key, null);
    }

    /**
     * Creates an exception with a string property.
     * </br>
     * The resource bundle is <code>ExceptionMessages.properties</code>.
     * @param key the key to lookup in the resource bundle
     * @param p1 the string property
     * @return a formatted ClassMakerException.
     */
    public ClassMakerException createException(String key, String p1)
    {
        ExceptionFactory factory = getFactory().getExceptionFactory();
        String [] exceptionParams = {p1};
        return factory.createException(getSourceLine(), key, exceptionParams);
    }

    /**
     * Creates an exception with 2 string properties.
     * </br>
     * The resource bundle is <code>ExceptionMessages.properties</code>.
     * @param key the key to lookup in the resource bundle
     * @param p1 first string property
     * @param p2 secnd string property
     * @return a formatted ClassMakerException
     */
    public ClassMakerException createException(String key, String p1, String p2)
    {
        ExceptionFactory factory = getFactory().getExceptionFactory();
        String [] exceptionParams = {p1, p2};
        return factory.createException(getSourceLine(), key, exceptionParams);
    }

    /**
     * Creates an exception with 3 string properties.
     * </br>
     * The resource bundle is <code>ExceptionMessages.properties</code>.
     * @param key the key to lookup in the resource bundle
     * @param p1 first string property
     * @param p2 secnd string property
     * @param p3 third string property
     * @return a formatted ClassMakerException
     */
    public ClassMakerException createException(String key, String p1, String p2, String p3)
    {
        ExceptionFactory factory = getFactory().getExceptionFactory();
        String [] exceptionParams = {p1, p2, p3};
        return factory.createException(getSourceLine(), key, exceptionParams);
    }

    private void assertNotNull(Object obj, String name)
    {
        if (obj == null)
            throw new IllegalArgumentException(name + " cannot be null");
    }
    
    static class LocalSourceLine implements SourceLine
    {
        /** The name of the source file relative to the source path */
        private String sourceFilename = null;
        int currentLineNumber = 0;

        public void setFilename(String filename)
        {
            if (sourceFilename != null)
                throw new IllegalStateException("Filename cannot be set twice (old)" + sourceFilename + " (new)"
                        + filename);
            sourceFilename = filename;
        }

        /** 
         * Current source file name. 
         */
        public String getFilename()
        {
            return sourceFilename;
        }

        /** 
         * Current Line Number.
         */
        public int getLineNumber()
        {
            return currentLineNumber;
        }

        /**
         * Remembers the current line number.
         * <br/>
         * Called whenever the line number changes in the input file.
         * The line number may be used by <code>markLineNumber</code> to generate a
         * line number entry in the generated class file.
         *
         * @param lineNumber current line number
         */
        public void setLineNumber(int lineNumber)
        {
            currentLineNumber = lineNumber;
        }
    }

    /**
     * Get the <code>LineNumber</code> provider.
     * <br/>
     * The <code>LineNumber</code> interface provides the source file name and current line number for
     * debugging and error messages.
     * @return <code>LineNumber</code> provider
     */
    public SourceLine getSourceLine()
    {
    	if (sourceLine == null)
    		setSourceFilename(defaultSourceFilename());
    	return sourceLine;
    }
    
    /**
     * Remembers the current line number.
     * <br/>
     * Call this method whenever the line number changes in the input file.
     * The line number may be used by <code>markLineNumber</code> to generate a
     * line number entry in the generated class file.
     *
     * @param lineNumber current line number
     */
    public void setLineNumber(int lineNumber)
    {
        this.localSourceLine.setLineNumber(lineNumber);
    }

    /**
     * Adds a line number entry to the generated class, if appropriate.
     * <br/>
     * Called by methods that generate byte codes. A line number entry will
     * be added to the method being generated if the line number has changed
     * since the last time this method was called.
     */
    protected void markLineNumber()
    {
    	int lineNumber = getSourceLine().getLineNumber(); 
        if (lineNumber != previousLineNumber)
        {
            cfw.addLineNumberEntry((short)lineNumber);
            previousLineNumber = lineNumber;
        }
        // For convenience we reset the followsReturn flag
        // because almost every method calls this method.
        checkInMethod();
        followsReturn = false;
    }

    /**
     * Saves the class to the given output folder.
     * <br/>
     * The class will be placed in the appropriate path corresponding to the package name.
     * @param classesDir the base folder for output classes
     * @throws IOException if the class file cannot be created
     * @return a File referring to the saved class file
     */
    public File saveClass(File classesDir) throws IOException
    {
        if (!classesDir.exists())
        {
            throw createException("ClassMaker.OutputFolderDoesNotExist_1", classesDir.getName());
        }
        ClassFileWriter cfw = getClassFileWriter();
        String className = cfw.getClassName() + ".class";
        File classFile = new File(classesDir, className);
        File packageFile = classFile.getParentFile();
        if (!packageFile.exists())
        {
            packageFile.mkdirs();
        }
        FileOutputStream output = new FileOutputStream(classFile);
        cfw.write(output);
        output.close();

        return classFile;
    }

    /**
     * Deletes the class from the given output folder.
     * <br/>
     * The class will be deleted from the appropriate path corresponding to the package name.
     * @param classesDir the base folder for output classes
     * @throws IOException if the class file cannot be created
     */
    public void deleteClass(File classesDir) throws IOException
    {
        if (!classesDir.exists())
        {
            throw createException("ClassMaker.OutputFolderDoesNotExist_1", classesDir.getName());
        }
        String className = toSlashName(getFullyQualifiedClassName()) + ".class";
        File classFile = new File(classesDir, className);
        if (classFile.exists())
        {
            if (!classFile.delete())
                throw new IOException("Could not delete: " + classFile.getAbsolutePath());
        }
    }

}

// Copyright (c) 2010, Donald Strong.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// The views and conclusions contained in the software and documentation are those
// of the authors and should not be interpreted as representing official policies,
// either expressed or implied, of the FreeBSD Project.

package au.com.illyrian.classmaker;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.mozilla.classfile.ByteCode;
import org.mozilla.classfile.ClassFileWriter;

import au.com.illyrian.classmaker.members.MakerField;
import au.com.illyrian.classmaker.members.MakerMethod;
import au.com.illyrian.classmaker.members.MakerMethodCollector;
import au.com.illyrian.classmaker.types.ArrayType;
import au.com.illyrian.classmaker.types.ClassType;
import au.com.illyrian.classmaker.types.MakerClassType;
import au.com.illyrian.classmaker.types.PrimitiveType;
import au.com.illyrian.classmaker.types.Type;
import au.com.illyrian.classmaker.types.Value;
import au.com.illyrian.classmaker.util.LocalFieldList;
import au.com.illyrian.classmaker.util.MakerUtil;

/**
 * A ClassMaker instance is used to generate a class suitable to be loaded into
 * a Java Virtual Machine (JVM).
 * The generated byte code may be loaded directly from the ClassMaker instance
 * or it may be saved to a class file. <br/>
 * The ClassMaker API allows fields and methods to be created in a manner
 * similar to
 * writing java source code. The API supports the following features:
 * <UL>
 * <LI>methods and parameters</LI>
 * <LI>expressions including numeric promotion and assignment conversion</LI>
 * <LI>local, class and static fields</LI>
 * <LI>loops with break and continue statements</LI>
 * <LI>breaking to labelled statements</LI>
 * <LI>for loop statements</LI>
 * <LI>if-then-else statements</LI>
 * <LI>switch statements with both contiguous and non-contiguous keys</LI>
 * <LI>method calls including resolving methods and parameter conversion</LI>
 * <LI>string concatenation including conversion between String and StringBuffer
 * </LI>
 * <LI>try-catch-finally blocks</LI>
 * <LI>forward declaration or, alternatively, two pass generation.</LI>
 * <LI>debugger support</LI>
 * <LI>integration with ordinary java classes.</LI>
 * </UL>
 * 
 * Byte code is generated as a side effect of calling methods in the ClassMaker
 * instance.
 * <p/>
 * The following non-trivial example shows the java code to create a class that
 * implements a factorial algorithm and the equivalent ClassMaker code to
 * generate the same class. The <code>Unary</code> interface is shared between
 * both implementations.
 * <p/>
 * <table width="100%" border="1">
 * <tr>
 * <td width="50%" >
 * Java code</td>
 * <td>
 * ClassMaker code</td>
 * </tr>
 * <tr>
 * <td>
 * 
 * <pre>
 * public interface Unary {
 *     int unary(int a);
 * }
 * 
 * public class Factorial implements Unary {
 *     public int unary(int n) {
 *         int x;
 *         x = 1;
 *         while (n &gt; 0) {
 *             x = x * n;
 *             n--;
 *         }
 *         return x;
 *     }
 * }
 * </pre>
 * 
 * </td>
 * <td>
 * 
 * <pre>
 * ClassMakerFactory factory = new ClassMakerFactory();
 * ClassMaker maker = factory.createClassMaker();
 * 
 * maker.setModifiers(ClassMaker.ACC_PUBLIC);
 * maker.setClassName(&quot;Factorial&quot;);
 * maker.Implements(Unary.class);
 * 
 * maker.Method(&quot;unary&quot;, int.class, ClassMaker.ACC_PUBLIC);
 * maker.Declare(&quot;n&quot;, int.class, 0);
 * maker.Begin();
 *     maker.Declare(&quot;x&quot;, int.class, 0);
 *     maker.Eval(maker.Set(&quot;x&quot;, maker.Literal(1)));
 *     maker.Loop();
 *         maker.While(maker.GT(maker.Get(&quot;n&quot;), maker.Literal(0)));
 *         maker.Eval(maker.Set(&quot;x&quot;, maker.Mult(maker.Get(&quot;x&quot;), maker.Get(&quot;n&quot;))));
 *         maker.Eval(maker.Dec(&quot;n&quot;));
 *     maker.EndLoop();
 *     maker.Return(maker.Get(&quot;x&quot;));
 * maker.End();
 * 
 * Class myClass = maker.defineClass();
 * Unary exec = (Unary) myClass.newInstance();
 * </pre>
 * 
 * </td>
 * </tr>
 * </table>
 *
 * @author Donald Strong
 */
public class ClassMaker implements ClassMakerIfc, SourceLine, ClassMakerConstants {
    /**
     * Bit-mask of method modifiers that are incompatible with the <code>abstract</code> modifier.
     */
    private static final int MASK_INCOMPATABLE_WITH_ABSTRACT_METHOD = ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED
            | ACC_NATIVE | ACC_STRICTFP;

    /**
     * Constant for the <code>Return</code> jump target used by
     * <code>Statement.jumpToTarget</code>
     */
    public static final String RETURN = "return";
    /**
     * Constant for the <code>Break</code> jump target used by
     * <code>Statement.jumpToTarget</code>
     */
    public static final String BREAK = "break";
    /**
     * Constant for the <code>Continue</code> jump target used by
     * <code>Statement.jumpToTarget</code>
     */
    public static final String CONTINUE = "continue";

    /** Constant for the name of a constructor method */
    public static final String INIT = "<init>";

    // External references
    /** The super type of this type. */
    private ClassType extendsType = null;
    /** A list of interfaces implemented by the class being generated. */
    private Vector<ClassType> interfaces = new Vector<ClassType>();
    // Fields - internal references
    /** A list of constructors in the class being generated. */
    private Vector<MakerMethod> constructors = new Vector<MakerMethod>();
    /** A list of methods in the class being generated. */
    private Vector<MakerMethod> methods = new Vector<MakerMethod>();
    /** A list of member fields in the class being generated. */
    private Vector<MakerField> fieldTable = new Vector<MakerField>();
    /** A list of local variables in the class being generated. */
    private LocalFieldList localFields = null;
    /**
     * Short class names are mapped to class types as they are imported into the
     * class being generated.
     */
    private HashMap<String, ClassType> importMap = new HashMap<String, ClassType>();
    /** A list of packages to search for imported classes. */
    private Vector<String>importStar = new Vector<String>();
    /** A reference to the method currently being generated. */
    private MakerMethod method = null;
    /** Has the class declared a constructor. */
    private boolean hasConstructor = false;
    /** Indicates that the previous statement was a call to Return(). */
    private boolean followsReturn = false;

    /** The fully qualified name of the package */
    String packageName = null;
    /** The simple name of the class */
    String simpleClassName;
    /** The fully qualified name of the class */
    String fullyQualifiedClassName;
    /** A reference to the type information for the class being generated. */
    private MakerClassType thisClassType;
    /** The modifiers for the class being generated. */
    private int classModifiers = ACC_PUBLIC;

    // Fields - external references
    /* The code generator for this instance */
    private ClassGenerator gen;
    /* Remember the PrintStream for debug code */
    private PrintStream debugCodePrintStream = null;
    /* A ClassMakerFactory instance that may be shared with other instances of ClassMaker. */
    private final ClassMakerFactory factory;
    /* Checks access restrictions */
    private final AccessChecker checker = new AccessChecker(this);

    /** The name of the source file relative to the source path */
    private SourceLine sourceLine;
    private String sourceFilename = null;
    private int sourceLineNumber = 0;
    private SourceLineImpl localSourceLine;
    

    //#################### Constructors #################
    
    public ClassMaker createClassMaker() {
        return getFactory().createClassMaker();
    }

    /**
     * Creates a <code>ClassMaker</code> instance given a
     * <code>ClassMakerFactory</code>.
     * 
     * The <code>ClassMakerFactory</code> provides shared services for all
     * instances of <code>ClassMaker</code>.
     * 
     * @param globalFactory
     *            the <code>ClassMakerFactory</code> instance that is used by
     *            all class generators
     */
    protected ClassMaker(ClassMakerFactory globalFactory) {
        factory = globalFactory;
    }

    // Required properties

    /**
     * Provides a default name for the package.
     * </br>
     * The default is to have no package name, but this method may be
     * overridden.
     * 
     * @return the name of the package
     */
    protected String defaultPackageName() {
        return "";
    }

    /**
     * Sets the package name of the class being generated.
     * 
     * @param fullyQualifiedClassName
     *            the fully qualified name of the class
     * @throws ClassMakerException
     *             if it is too late to call this method
     */
    public void setPackageName(String packageName) throws ClassMakerException {
        if (isGeneratingCode()) {
            throw createException("ClassMaker.ToLateToNameThePackage");
        }
        this.packageName = packageName;
    }

    /**
     * The package name of the class being generated.
     * </br>
     * Returns the default package name if one has not been set explicitly.
     * 
     * @see #defaultPackageName()
     * @return the name of the class
     */
    public String getPackageName() {
        if (packageName == null) {
            setPackageName(defaultPackageName());
        }
        return packageName;
    }

    /**
     * Provides a default simple name for the class being generated.
     * </br>
     * Derives a simple name from the name of the ClassMaker class.
     * The default name will be the name of the Maker class with '
     * <code>_$</code>' appended.
     * This method may be overridden to provide another default.
     * 
     * @return the name of the generated class
     */
    protected String defaultSimpleClassName() {
        return getClass().getSimpleName() + "_$" + getFactory().incAnonomousClass();
    }

    /**
     * Sets the simple name of the class being generated.
     * 
     * @param className
     *            the fully qualified name of the class
     * @throws ClassMakerException
     *             if it is too late to call this method
     */
    public void setSimpleClassName(String className) throws ClassMakerException {
        if (isGeneratingCode())
            throw createException("ClassMaker.ToLateToNameTheClass");
        this.simpleClassName = className;
    }

    /**
     * The simple name of the generated class.
     * </br>
     * Generates a class name if one has not been set explicitly.
     * 
     * @see #defaultFullyQualifiedClassName()
     * @return the name of the class
     */
    public String getSimpleClassName() {
        if (simpleClassName == null)
            setSimpleClassName(defaultSimpleClassName());
        return simpleClassName;
    }

    /**
     * Provides a name for the generated class from the name of the ClassMaker
     * class.
     * </br>
     * The default name will be the name of the Maker class with '
     * <code>_$</code>' appended.
     * 
     * @return the name of the generated class
     */
    protected String defaultFullyQualifiedClassName() {
        String packageName = getPackageName();
        String simpleClassName = getSimpleClassName();
        return (packageName == null || "".equals(packageName)) ? simpleClassName : packageName + "." + simpleClassName;
    }

    /**
     * Sets the name of the class being generated.
     * 
     * @param className
     *            the fully qualified name of the class
     * @throws ClassMakerException
     *             if it is too late to call this method
     */
    public void setFullyQualifiedClassName(String className) throws ClassMakerException {
        if (isGeneratingCode())
            throw createException("ClassMaker.ToLateToNameTheFullyQualifiedClass");
        this.fullyQualifiedClassName = className;
    }

    /**
     * The fully qualified name of the generated class.
     * </br>
     * Generates a class name if one has not been set explicitly.
     * 
     * @see #defaultFullyQualifiedClassName()
     * @return the name of the class
     */
    public String getFullyQualifiedClassName() {
        if (fullyQualifiedClassName == null)
            setFullyQualifiedClassName(defaultFullyQualifiedClassName());
        return fullyQualifiedClassName;
    }

    /**
     * Generates a default source file name based on the class name.
     * 
     * @return the name of the source file relative to the source path
     */
    protected String defaultSourceFilename() {
        return MakerUtil.toSlashName(getFullyQualifiedClassName()) + ".java";
    }

    /**
     * Sets the name of the source file relative to the source path
     * 
     * @param filename
     *            the path to the source file
     * @throws ClassMakerException
     *             if it is too late to call this method
     */
    public void setSourceFilename(String filename) throws ClassMakerException {
        if (isGeneratingCode()) {
            throw createException("ClassMaker.ToLateToNameTheSourceFilename");
        }
        if (sourceLine != null) {
            throw createException("ClassMaker.CannotSetSourceFilename");
        }
        localSourceLine = new SourceLineImpl();
        localSourceLine.setFilename(filename);
        sourceLine = localSourceLine;
    }

    /** The signature of the generated class. */
    public String getClassSignature() {
        return getClassType().getSignature();
    }

    /**
     * Creates a default ClassType for the generated class.
     * 
     * @return the ClassType of the generated class
     */
    protected MakerClassType defaultThisClass() {
        MakerClassType classType = new MakerClassType(this);
        classType.setModifiers(classModifiers);
        getFactory().addType(classType);
        getFactory().addClassMaker(this);
       return classType;
    }

    /**
     * Sets the ClassType of the generated class.
     * 
     * @param classType
     *            the ClassType of the generated class
     * @throws ClassMakerException
     *             if it is too late to call this method
     */
    protected void setClassType(MakerClassType classType) {
        if (isGeneratingCode()) {
            throw createException("ClassMaker.ToLateToSetClassType");
        }
        thisClassType = classType;
        addClassTypeAlias(classType);
    }

    /**
     * Gets the ClassType of the generated class.
     * </br>
     * Generates a default ClassType if one has not been set explicitly.
     * 
     * The <code>Value</code> represents a reference to an instance of the
     * class that has been pushed onto the stack, such as may be used when
     * accessing
     * a non static member, while the <code>ClassType</code> represents the
     * class,
     * such as may be used when accessing a static member.
     * 
     * @see #defaultThisClass()
     * @return the ClassType of the generated class
     */
    public MakerClassType getClassType() {
        if (thisClassType == null) {
            setClassType(defaultThisClass());
        }
        return thisClassType;
    }

    /**
     * Gets the ClassType for the super class of the generated class.
     * </br>
     * Generates a default ClassType if one has not been set explicitly.
     * 
     * @see #defaultSuperClass()
     * @return classType the ClassType of the super class
     */
    public ClassType getExtendsType() {
        if (extendsType == null) {
            setExtendsType(defaultExtendsType());
        }
        return extendsType;
    }
    
    public void setExtendsType(ClassType superType) {
        if (isGeneratingCode()) {
            throw createException("ClassMaker.ToLateToExtendTheClass");
        }
        this.extendsType = superType;
    }
    
    public ClassType defaultExtendsType() {
        return ClassMakerFactory.OBJECT_TYPE;
    }

    /**
     * Determines whether the class should be generated using two passes.
     * </br>
     * The first pass will gather type information and method signatures.
     * The second pass will generate the byte-code.
     * 
     * @return true if two passes should be used; otherwise false
     */
    public boolean isTwoPass() {
        return (getPass() != ClassMakerConstants.ONE_PASS);
    }

    /**
     * The generated class extends the given class.
     * </br>
     * This version takes a <code>String</code> and can be used to extend other
     * generated classes.
     * 
     * @param className
     *            the name of the class that the generated class extends
     * @throws ClassMakerException
     *             if it is too late to call this method
     */
    public void Extends(String className) throws ClassMakerException {
        ClassType classType = stringToClassType(className);
        Extends(classType);
    }

    /**
     * The generated class extends the given class.
     * </br>
     * 
     * @param classType
     *            the type of the class that the generated class extends
     * @throws ClassMakerException
     *             if it is too late to call this method
     */
    public void Extends(ClassType classType) throws ClassMakerException {
        if (isGeneratingCode()) {
            throw createException("ClassMaker.ToLateToExtendTheClass");
        }
        if (getPass() != ClassMakerConstants.FIRST_PASS) {
            if (classType == null) {
                throw createException("ClassMaker.NoClassTypeCalled_1", classType.getName());
            }
            int mod = classType.getModifiers();
            if (Modifier.isInterface(mod))
                throw createException("ClassMaker.CannotExtendInterface", classType.getName());

        }
        setExtendsType(classType);
    }

    /**
     * The generated class extends the given java class.
     * </br>
     * This version takes a <code>Class</code> which must be available at
     * compile time.
     * This means the class must be a compiled java class or a generated class
     * that has
     * been loaded using the <code>defineClass</code> method.
     * 
     * @param javaClass
     *            the class that the generated class extends
     * @throws ClassMakerException
     *             if it is too late to call this method
     */
    public void Extends(Class javaClass) throws ClassMakerException {
        if (isGeneratingCode())
            throw createException("ClassMaker.ToLateToExtendTheClass");
        int mod = javaClass.getModifiers();
        if (Modifier.isInterface(mod))
            throw createException("ClassMaker.CannotExtendInterface", javaClass.getName());

        if (getPass() != ClassMakerConstants.FIRST_PASS) {
            ClassType classType = classToClassType(javaClass);
            setExtendsType(classType);
        }
    }

    /**
     * Indicates that the class implements the interface represented by the
     * given <code>Class</code>.
     * 
     * @param javaClass
     *            the <code>Class<code> of the implemented interface
     */
    public void Implements(Class javaClass) throws ClassMakerException {
        ClassType classType = classToClassType(javaClass);
        Implements(classType);
    }

    /**
     * Indicates that the class implements the named interface.
     * 
     * @param className the fully qualified class name
     */
    public void Implements(String className) throws ClassMakerException {
        ClassType classType = stringToClassType(className);
        if (getPass() != ClassMakerConstants.FIRST_PASS && classType == null) {
            throw createException("ClassMaker.NoClassTypeCalled_1", className);
        }
        Implements(classType);
    }

    /**
     * Indicates that the class implements the named interface.
     * 
     * @param classType the type of the interface
     */
    public void Implements(ClassType classType) {
        if (getPass() != ClassMakerConstants.FIRST_PASS && !classType.isInterface()) {
            throw createException("ClassMaker.CannotImplementClass", classType.getName());
        }
        if (getGen() != null) {
            getGen().addInterface(classType.getName());
        }
        if (getPass() != SECOND_PASS) {
            interfaces.add(classType);
        }
    }

    private ClassGenerator defaultClassGenerator() {
        return new ClassGenerator(this);
    }

    /**
     * Sets the ClassFileWriter instance for this ClassMaker.
     * 
     * @param classFileWriter
     *            the ClassFileWriter instance
     */
    public void setClassGenerator(ClassGenerator classGenerator) {
        if (debugCodePrintStream != null) {
            classGenerator.setDebugCodeOutput(debugCodePrintStream);
        }
        gen = classGenerator;
    }

    public ClassGenerator getGen() {
        if (gen == null && !isFirstPass()) {
            setClassGenerator(defaultClassGenerator());
        }
        return gen;
    }

    public boolean isGeneratingCode() {
        return gen != null;
    }

    protected boolean isFirstPass() {
        return getPass() == FIRST_PASS;
    }

    protected boolean isDebugCode() {
        if (getGen() != null) {
            return getGen().isDebugCode();
        }
        return false;
    }

    protected void setDebugComment(String comment) {
        if (getGen() != null) {
            getGen().setDebugComment(comment);
        }
    }

    public void setDebugCodeOutput(PrintStream printStream) {
        if (getGen() != null) {
            getGen().setDebugCodeOutput(printStream);
        } else {
            // Remember for when the ClassGenerator is set.
            debugCodePrintStream = printStream;
        }
    }

    /** <code>ClassMaker</code>s share a common <code>ClassMakerFactory</code>. */
    public ClassMakerFactory getFactory() {
        return factory;
    }

    // Convenience methods

    /**
     * Gets the methods declared by the generated class.
     * 
     * @return an array of declared methods.
     */
    public MakerMethod[] getDeclaredMethods() {
        return methods.toArray(ClassMakerFactory.METHOD_ARRAY);
    }

    /**
     * Gets the methods declared by the generated class and its super classes.
     * 
     * @return an array of declared methods.
     */
    MakerMethod[] getAllClassMethods(ClassType classType) {
        MakerMethodCollector allMethods = new MakerMethodCollector();
        allMethods.includeClassMethods(classType);
        return allMethods.toArray();
    }

    /**
     * Gets the methods declared by the interfaces implemented by this class.
     * 
     * @return an array of declared methods.
     */
    MakerMethod[] getAllInterfaceMethods(ClassType classType) {
        MakerMethodCollector allMethods = new MakerMethodCollector();
        allMethods.includeInterfaceMethods(classType);
        return allMethods.toArray();
    }

    /**
     * Gets the constructors declared by the generated class.
     * 
     * @return an array of declared constructors.
     */
    public MakerMethod[] getDeclaredConstructors() {
        return constructors.toArray(ClassMakerFactory.METHOD_ARRAY);
    }

    /**
     * Gets the interfaces implemented by the generated class.
     * 
     * @return an array of implemented interfaces
     */
    public ClassType[] getDeclaredInterfaces() {
        return interfaces.toArray(ClassMakerFactory.CLASS_TYPE_ARRAY);
    }

    /**
     * Gets the member fields declared by the generated class.
     * 
     * @return an array of member fields
     */
    public MakerField[] getDeclaredFields() {
        return fieldTable.toArray(ClassMakerFactory.FIELD_ARRAY);
    }

    /** The class modifiers for the generated class. */
    public int getModifiers() {
        return getClassType().getModifiers();
    }

    /**
     * Sets the class modifiers for the generated class.
     * 
     * @param modifiers
     *            valid class modifiers are:
     *            <code>ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE, ACC_STATIC, ACC_FINAL</code>
     *            and <code>ACC_ABSTRACT</code>
     */
    public void setClassModifiers(int modifiers) {
        if ((modifiers & ClassMakerConstants.ACC_INTERFACE) == ClassMakerConstants.ACC_INTERFACE) {
            checker.checkInterfaceModifiers(modifiers);
            // Interface always has modifiers ACC_INTERFACE and ACC_ABSTRACT
            classModifiers = ACC_INTERFACE | ACC_ABSTRACT;
        } else {
            checker.checkClassModifiers(modifiers);
            classModifiers = modifiers;
        }
        if (thisClassType != null)
            thisClassType.setModifiers(classModifiers);

    }

    /**
     * Determines whether the class being generated is abstract.
     * 
     * @return true if the generated class is abstract
     */
    public boolean isAbstract() {
        return (getModifiers() & ClassMakerConstants.ACC_ABSTRACT) == ClassMakerConstants.ACC_ABSTRACT;
    }

    /**
     * Determines whether the class being generated is an interface.
     * 
     * @return true if the generated class is an interface
     */
    public boolean isInterface() {
        return (getModifiers() & ClassMakerConstants.ACC_INTERFACE) == ClassMakerConstants.ACC_INTERFACE;
    }

    /**
     * Sets the class modifiers to turn this class into an interface.
     */
    public void setIsInterface() {
        setClassModifiers(ACC_INTERFACE);
    }

    /**
     * Ensures that a method is currently being generated.
     * 
     * @throws ClassMakerException
     *             if not generating a method
     */
    void checkInMethod() throws ClassMakerException {
        if (method == null) {
            throw createException("ClassMaker.MustBeInMethod");
        }
    }

    public int addModifier(int modifiers, String modifierName) {
        int modifier = MakerUtil.fromModifierString(modifierName);
        if ((modifiers & modifier) > 0)
            throw createException("ClassMaker.DuplicateModifier_1", modifierName);
        return modifiers | modifier;
    }

    /**
     * Determines whether a constructor has been declared for the generated
     * class.
     */
    public boolean hasConstructor() {
        return hasConstructor;
    }

    /**
     * Get the current pass for the class generator.
     * </br>
     * The following are valid options.
     * <ul>
     * <li><code>ClassMaker.ONE_PASS</code></li>
     * <li><code>ClassMaker.FIRST_PASS</code></li>
     * <li><code>ClassMaker.SECOND_PASS</code></li>
     * </ul>
     * The default is <code>ClassMaker.ONE_PASS</code>.
     */
    public int getPass() {
        return getFactory().getPass();
    }

    //################# Class Loader methods ##############

    /**
     * Defines this class in the factory <code>ClassLoader</code>.
     * 
     * @return the generated class
     */
    public <T> Class<T> defineClass() {
        if (thisClassType != null && thisClassType.getJavaClass() != null) {
            return thisClassType.getJavaClass();
        }
        EndClass();
        if (getPass() == FIRST_PASS) {
            throw createException("ClassMaker.CannotDefineClassAfterFirstPhase");
        }
        defineClassType(getClassType().getExtendsType());
        defineInterfaces(this.getDeclaredInterfaces());
        @SuppressWarnings("unchecked")
        Class<T> thisClass = (Class<T>)getFactory().getClassLoader().defineClass(getGen().getClassName(), getGen().toByteArray());
        thisClassType.setJavaClass(thisClass);
        return thisClass;
    }

    private void defineInterfaces(ClassType[] interfaces) {
        for (ClassType type : interfaces) {
            defineClassType(type);
        }
    }

    private void defineClassType(ClassType classType) {
        ClassMaker maker = factory.findClassMaker(classType.getName());
        if (maker != null) {
            maker.defineClass();
        }
    }

    /**
     * Completes processing of the class.
     * This method is automatically called when the class is defined.
     */
    public void EndClass() throws ClassMakerException {
        if (method != null) {
            throw createException("ClassMaker.MissingEndForPreviousMethod_1", method.toString());
        }
        if (getPass() != COMPLETED_PASS) {
            getClassType(); // Loads generated class into types visible from the factory
            if (!hasConstructor() && !isInterface()) {
                defaultConstructor();
                // Reset the hasConstructor flag if we are doing two passes.
                if (getPass() == FIRST_PASS)
                    hasConstructor = false;
            }
            thisClassType.setModifiers(classModifiers);
            thisClassType.setConstructors(getDeclaredConstructors());
            thisClassType.setDeclaredMethods(getDeclaredMethods());
            thisClassType.setInterfaces(getDeclaredInterfaces());
            thisClassType.setDeclaredFields(getDeclaredFields());

            if (getPass() != FIRST_PASS) {
                checkClassMethodsAreConcrete();
                checkInterfaceMethodsAreAbstract();
                checkInterfaceMethodsAreImplemented();
            }
        }
    }

    /**
     * Checks that all the methods in the class are concrete.
     * </br>
     * The exception message includes a list of abstract methods.
     * 
     * @throws ClassMakerException
     *             if an abstract method is found
     */
    void checkClassMethodsAreConcrete() throws ClassMakerException {
        if (!isAbstract() && !isInterface()) {
            boolean hasAbstractMethod = false;
            StringBuffer buf = new StringBuffer();
            MakerMethod[] allMethods = getAllClassMethods(getClassType());
            for (MakerMethod method : allMethods) {
                if ((method.getModifiers() & ClassMakerConstants.ACC_ABSTRACT) == ClassMakerConstants.ACC_ABSTRACT) {
                    hasAbstractMethod = true;
                    MakerUtil.appendStrings(buf, method.toString(), "\n");
                }
            }
            if (hasAbstractMethod) {
                throw createException("ClassMaker.AbstractMethodsInConcreteClass_1", buf.toString());
            }
        }
    }

    /**
     * Checks that all the methods in the interface are abstract.
     * </br>
     * The exception message includes a list of concrete methods.
     * 
     * @throws ClassMakerException
     *             if a concrete method is found
     */
    void checkInterfaceMethodsAreAbstract() throws ClassMakerException {
        if (isInterface()) {
            boolean hasConcreteMethod = false;
            StringBuffer buf = new StringBuffer();
            for (MakerMethod method : getAllInterfaceMethods(getClassType())) {
                if ((method.getModifiers() & ClassMakerConstants.ACC_ABSTRACT) != ClassMakerConstants.ACC_ABSTRACT) {
                    hasConcreteMethod = true;
                    MakerUtil.appendStrings(buf, method.toString(), "\n");
                }
            }
            if (hasConcreteMethod)
                throw createException("ClassMaker.ConcreteMethodsInInterface_1", buf.toString());
        }
    }

    /**
     * Checks that all of the interface methods in the generated class have been
     * implemented.
     * </br>
     * The exception message includes a list of unimplemented methods.
     * 
     * @throws ClassMakerException
     *             if an unimplemented method is found
     */
    void checkInterfaceMethodsAreImplemented() throws ClassMakerException {
        if (!isInterface()) {
            boolean hasUnimplementedMethod = false;
            StringBuffer buf = new StringBuffer();
            MakerMethod[] interfaceMethods = getAllInterfaceMethods(getClassType());
            for (MakerMethod abstractMethod : interfaceMethods) {
                MakerMethod concreteMethod = findImplementingMethod(abstractMethod, !isAbstract());
                if (concreteMethod == null) {
                    hasUnimplementedMethod = true;
                    MakerUtil.appendStrings(buf, abstractMethod.toString(), "\n");
                }
            }
            if (hasUnimplementedMethod) {
                throw createException("ClassMaker.UnimplementedInterfaceMethods_1", buf.toString());
            }
        }
    }

    /**
     * Find a method that implements the given interface method.
     * </br>
     * Abstract methods are sufficient to implement the interface if the class
     * is abstract.
     * 
     * @param interfaceMethod the interface method that requires an implementation
     * @param excludeAbstract whether to exclude abstract methods
     * @return the method that implements the interface method
     */
    MakerMethod findImplementingMethod(MakerMethod interfaceMethod, boolean excludeAbstract) {
        MakerMethod[] allMethods = getAllClassMethods(getClassType());
        for (MakerMethod method : allMethods) {
            if (excludeAbstract
                    && (method.getModifiers() & ClassMakerConstants.ACC_ABSTRACT) == ClassMakerConstants.ACC_ABSTRACT) {
                continue; // ignore abstract methods
            }
            if (interfaceMethod.equals(method)) {
                return method;
            }
        }
        return null;
    }

    /**
     * Generate a default constructor for the class.
     */
    public void defaultConstructor() {
        Method(INIT, ClassMakerFactory.VOID_TYPE, ClassMakerConstants.ACC_PUBLIC);
        Begin();
        Init(Super(), null);
        Return();
        End();
    }

    //##################### Import methods ###############

    /**
     * Imports the named class and creates a mapping for the short class name.
     * 
     * @param className
     *            the fully qualified name for the class
     * @throws ClassMakerException
     *             if the class does not exist
     */
    public void Import(String className) throws ClassMakerException {
        if (className.endsWith(".*")) {
            String packageName = className.substring(0, className.length()-2);
            ImportStar(packageName);
        } else {
            ClassType importedType = importMap.get(MakerUtil.toDotName(className));
            if (importedType == null) {
                importedType = stringToClassType(MakerUtil.toDotName(className));
                addClassTypeAlias(importedType);
            }
        }
    }

    /**
     * Imports all classes in the package.
     * 
     * @param packageName the name of a package
     */
    public void ImportStar(String packageName) throws ClassMakerException {
        importStar.add(packageName);
    }

    /**
     * Imports the given class and creates a mapping for the short class name.
     * 
     * @param javaClass
     *            the class to be imported
     * @throws ClassMakerException
     *             if the javaClass does not represent a class type
     */
    public void Import(Class javaClass) throws ClassMakerException {
        ClassType classType = classToClassType(javaClass);
        addClassTypeAlias(classType);
    }

    /**
     * Finds or creates a <code>ClassType</code> wrapper around a java
     * <code>Class</code>.
     * </br>
     * An existing ClassType is returned if the java class has been used
     * previously. <code>ClassType</code>s are cached in the shared
     * <code>ClassMakerFactory</code>.
     * 
     * @param javaClass
     *            the java class to be wrapped
     * @return the <code>ClassType</code> that describes the java class
     * @throws ClassMakerException
     *             if the javaClass does not represent a class type
     */
    public ClassType classToClassType(Class javaClass) throws ClassMakerException {
        Type type = getFactory().classToType(javaClass);
        if (type.toClass() != null) {
            return type.toClass();
        }
        throw createException("ClassMaker.NotAClass_1", javaClass.getSimpleName());
    }
    /**
     * Allows a <code>ClassType</code> to be found using the short class name.
     * </br>
     * Aliases are created by the <code>Import</code> method.
     * The simple class name is an alias for the fully qualified class name.
     * Aliases are stored locally in the <code>ClassMaker</code> instance.
     * </br>
     * Only the fully qualified name will be used if two classes are imported
     * with the same name, e.g. java.util.Date and java.sql.Date.
     * 
     * @param classType the class to be added to the alias table
     */
    void addClassTypeAlias(ClassType classType) {
        String className = MakerUtil.toDotName(classType.getName());
        if (importMap.get(className) != null) {
            return;
        }
        int index = className.lastIndexOf('$');
        if (index == -1) {
            index = className.lastIndexOf('.');
        }
        if (index > -1) { // A simple name exists so add it to the alias map.
            String simpleName = className.substring(index + 1);
            Type aliasType = importMap.get(simpleName);
            if (aliasType == null) {
                importMap.put(simpleName, classType);
            } else {
                // A clash of simple names exists so we must use fully qualified names.
                if (!ClassMakerFactory.NULL_TYPE.equals(aliasType)) { 
                    // Use ClassMakerFactory.NULL_TYPE as a marker to force fully qualified names.
                    importMap.put(simpleName, ClassMakerFactory.NULL_TYPE);
                }
            }
        }
        // Add the fully qualified class name to the alias map.
        importMap.put(className, classType);
    }

    //##################### Method resolving ###################

    /**
     * Determines which constructor in this class should be invoked.
     *
     * Uses <code>MethodResolver</code> to determine the appropriate constructor
     * given the actual parameters.
     * 
     * @param classType the type of the class containing the method
     * @param actualParameters the parameters on the call stack
     * @return a <code>MakerMethod</code> which represents the resolved method
     */
    MakerMethod resolveConstructor(ClassType classType, CallStack actualParameters) {
        MakerMethod[] constructors = classType.getConstructors();
        return getFactory().getMethodResolver().resolveMethod(this, constructors, INIT, actualParameters);
    }

    /**
     * Determines which method in the given class should be invoked.
     *
     * Uses <code>MethodResolver</code> to determine the appropriate method
     * given the method name and actual parameters.
     * 
     * @param classType
     *            the type of the class containing the method
     * @param name
     *            the name of the method
     * @param actualParameters
     *            the parameters on the call stack
     * @return a <code>MakerMethod</code> which represents the resolved method
     */
    public MakerMethod resolveMethod(ClassType classType, String name, CallStack actualParameters) {
        MakerMethod[] methods = classType.getMethods(name);
        return getFactory().getMethodResolver().resolveMethod(this, methods, name, actualParameters);
    }

    //################### Methods #####################
    /**
     * Starts the declaration of a method with a <code>Class</code> representing
     * the return type.
     * 
     * @param methodName
     *            the name of the method to be generated
     * @param returnType
     *            the <code>Class</code> of the return type for the method
     * @param methodModifiers
     *            appropriate modifiers include:
     *            <code>ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE, ACC_STATIC, ACC_FINAL</code>
     */
    public void Method(String methodName, Class returnType, int methodModifiers) throws ClassMakerException {
        Type type = getFactory().classToType(returnType);
        Method(methodName, type, methodModifiers);
    }

    /**
     * Starts the declaration of a method.
     * 
     * @param methodName
     *            the name of the method to be generated
     * @param returnType
     *            the return type for the method
     * @param methodModifiers
     *            appropriate modifiers include:
     *            <code>ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE, ACC_STATIC, ACC_FINAL</code>
     */
    public void Method(String methodName, String returnType, int methodModifiers) throws ClassMakerException {
        Type type = stringToType(returnType);
        Method(methodName, type, methodModifiers);
    }

    /**
     * Starts the declaration of a method.
     * 
     * @param methodName
     *            the name of the method to be generated
     * @param returnType
     *            the return type for the method
     * @param methodModifiers
     *            appropriate modifiers include:
     *            <code>ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE, ACC_STATIC, ACC_FINAL</code>
     */
    public void Method(String methodName, Type returnType, int methodModifiers) throws ClassMakerException {
        checker.checkMethodModifiers(methodModifiers);
        if (method != null) {
            throw createException("ClassMaker.MissingEndForPreviousMethod_1", method.toString());
        }
        method = new MakerMethod(getClassType(), methodName, returnType, (short) methodModifiers);

        // Adjust the slots used to account for the this pointer, if present.
        localFields = new LocalFieldList(getGen());
        localFields.incLocalSlots(method.isStatic() ? 0 : getClassType().getSlotSize());

        // Determine whether the class declares a constructor.
        if (INIT.equals(methodName)) {
            hasConstructor = true;
        }
    }

    /**
     * Begins the body of a method.
     * Local variables declared before <code>Begin()</code> are the formal
     * parameters
     * of the method.
     */
    void BeginMethod() throws ClassMakerException {
        if (method == null) {
            throw createException("ClassMaker.NotInMethod");
        }
        if (method.isAbstract()) {
            throw createException("ClassMaker.AbstractMethodCannotHaveBody_1", "Begin()");
        }

        method.setFormalTypes(getLocalFields().createFormalParameters());
        method.setFormalFields(getLocalFields().getMakerFields());

        if (isFirstPass()) {
            method.setHasBody(false);
        } else if (isForwardDeclared(method)) {
            removeMethod(method);
        }
        addMethod(method);

        if (getGen() != null) {
            getGen().beginMethod(method, getClassSignature());
            markLineNumber(); // possibly add a new line number entry.
        }
    }

    /**
     * Ends the body of a method.
     * Checks that the method body ends with a <code>Return</code> or
     * <code>Throw</code> statement.
     * Adds an implicit return for for void methods, if it is missing.
     * 
     * @throws ClassMakerException
     *             if the method must return a Value but doesn't and doesn't
     *             throw an exception.
     */
    void EndMethod() throws ClassMakerException {
        if (method.isAbstract()) {
            throw createException("ClassMaker.AbstractMethodCannotHaveBody_1", "End()");
        }
        if (getGen() != null) {
            // Check that Return has been called.
            if (!followsReturn) {
                if (ClassMakerFactory.VOID_TYPE.equals(method.getReturnType())) {
                    Return();
                } else {
                    throw createException("ClassMaker.ReturnOrThrowMustPrecedeEnd");
                }
            }
            markLineNumber(); // possibly add a new line number entry.
            getGen().endMethod(getLocalFields());
        }

        // Exit method.
        method = null;
        localFields = null;
    }

    /**
     * Begins a method body or compound statement with its own scope. <br/>
     * Local variables declared within this scope will be unaccessible when the
     * scope is exited.
     * The compound statement may be labelled so it can be the target of a
     * <code>Break</code> statement.
     * 
     * <pre>
     * Begin();
     * Declare(&quot;a&quot;, int.class);
     * Set(&quot;a&quot;, Literal(2));
     * End();
     * </pre>
     *
     * Delegates to <code>ScopeStatement.Begin</code>.
     * 
     * @return an interface to set a Label
     */
    public Labelled Begin() throws ClassMakerException {
        if (!isInBody()) {
            MethodBodyStatement bottomStatement = statementManager.createMethodBodyStatement();
            bottomStatement.Begin();
            return bottomStatement;
        } else {
            ScopeStatement stmt = statementManager.createScopeStatement();
            stmt.Begin();
            return stmt;
        }
    }

    /**
     * Ends the body of a method or compound statement.
     * Checks that the method body ends with a <code>Return</code> or
     * <code>Throw</code> statement.
     * Delegates to <code>ScopeStatement.End</code>.
     */
    public void End() throws ClassMakerException {
        ScopeStatement stmt = statementManager.topScopeStatement("ClassMaker.EndWithoutMatchingBegin");
        stmt.End();
        stmt.dispose(statementManager);
    }

    /**
     * Ends a method that does not have a body.
     * </br>
     * This may be because the method is abstract or because it is being forward
     * declared so that only one pass is necessary to parse the source file.
     */
    public void Forward() throws ClassMakerException {
        method.setFormalTypes(getLocalFields().createFormalParameters());
        if (getPass() == FIRST_PASS) {
            if (methods.indexOf(method) >= 0 || constructors.indexOf(method) >= 0) {
                throw createException("ClassMaker.MethodDeclaredMoreThanOnce_1", method.toString());
            }
        } else if (isForwardDeclared(method)) {
            removeMethod(method);
        }
        method.setHasBody(false);
        addMethod(method);
        if (getGen() != null) {
            markLineNumber(); // possibly add a new line number entry.
            if (method.isAbstract() || isInterface()) {
                getGen().addAbstractMethod(method);
            }
        }
        method = null;
        localFields = null;
    }

    /**
     * Determines whether the current method is forward declared.
     * 
     * @param method the current method
     * @return true if the method has been forward declared or false if the
     *         method has not been declared
     * @throws ClassMakerException
     *             if the current method has been declared more than once
     */
    boolean isForwardDeclared(MakerMethod method) throws ClassMakerException {
        int index;
        if ((index = methods.indexOf(method)) >= 0) {
            MakerMethod forwardMethod = methods.elementAt(index);
            if (forwardMethod.hasBody() == false) {
                return true;
            }
            throw createException("ClassMaker.MethodDeclaredMoreThanOnce_1", method.toString());
        } else if ((index = constructors.indexOf(method)) >= 0) {
            MakerMethod forwardMethod = constructors.elementAt(index);
            if (forwardMethod.hasBody() == false) {
                return true;
            }
            throw createException("ClassMaker.MethodDeclaredMoreThanOnce_1", method.toString());
        }
        return false;
    }

    /**
     * Adds the given method to the class.
     * 
     * @param method
     *            the method to add
     */
    void addMethod(MakerMethod method) {
        if (INIT.equals(method.getName())) {
            constructors.add(method);
        } else {
            methods.add(method);
        }
    }

    /**
     * Removes the given method from the class.
     * </br>
     * Only used to remove methods that have been forward declared.
     * 
     * @param method
     *            the method to remove
     */
    void removeMethod(MakerMethod method) {
        if (INIT.equals(method.getName())) {
            constructors.remove(method);
        } else {
            methods.remove(method);
        }
    }

    /**
     * Checks whether a method is currently being generated.
     * Variables declared before the method body will be considered formal
     * parameters.
     * Variables declared outside of a method will be treated as member fields.
     * 
     * @return true if generating a method
     */
    boolean isInMethod() {
        return method != null;
    }

    /**
     * Checks whether a method body is currently being generated.
     * Variable declared in the method body will be considered local.
     * 
     * @return true if generating a method body
     */
    boolean isInBody() {
        return statementManager.getBottomStatement() != null;
    }

    //################ Class Instantiation #########################
    /**
     * Creates a new instance of the given <code>Class</code>.
     * 
     * @param javaClass
     *            the <code>Class</code> to be instantiated
     * @return an <code>Initialiser</code> for the instance
     */
    public Initialiser New(Class javaClass) throws ClassMakerException {
        String className = MakerUtil.classToName(javaClass);
        return New(className);
    }

    /**
     * Creates a new instance of the named class.
     * 
     * @param className
     *            the name of the class to instantiate
     * @return an <code>Initialiser</code> for the instance
     */
    public Initialiser New(String className) throws ClassMakerException {
        Type type = null;
        if (!isFirstPass()) {
            type = findType(className);
        }
        return New(type);
    }

    /**
     * Creates a new instance of the class.
     * 
     * @param declared
     *            a declared type represents the type of class
     * @return an <code>Initialiser</code> for the instance
     */
    public Initialiser New(Type classType) throws ClassMakerException {
        Value reference = null;
        markLineNumber(); // possibly add a new line number entry.
        if (!isFirstPass()) {
            reference = getGen().New(classType);
        }
        return new InitialiserImpl(this, reference);
    }

    /**
     * Calls a constructor from the base class that is appropriate for the
     * actual parameters.
     * </br>
     * Uses <code>MethodResolver</code> to determine the appropriate constructor
     * for the
     * actual parameters and invokes that constructor using the reference to
     * <code>super</code> on top of the stack. The first parameter to this call
     * must be <code>Super()</code>.
     * 
     * @param classType
     *            the type of the base class
     * @param actualParameters
     *            the types of the actual parameters in the call stack
     */
    public void Init(Value reference, CallStack actualParameters) throws ClassMakerException {
        if (!isFirstPass()) {
            ClassType classType = reference.toClass();
            MakerMethod method = resolveConstructor(classType, actualParameters);
            checker.checkAccessDenied(classType, method);
            markLineNumber(); // possibly add a new line number entry.
            getGen().invokeSpecial(classType, method);
        }
    }

    //################## Method calls ##########################
    /**
     * Calls a static method in the given class that is appropriate for the
     * actual parameters.
     * </br>
     * Uses <code>MethodResolver</code> to determine the appropriate method for
     * the actual parameters and
     * then statically invokes the method.
     * 
     * @param javaClass
     *            the <code>Class<code> containing the method to be invoked
     * @param methodName
     *            the name of the method to call
     * @param actualParameters
     *            the types of the actual parameters in the call stack
     * @return the return type of the called method
     */
    public Value Call(Class javaClass, String methodName, CallStack actualParameters) throws ClassMakerException {
        String className = MakerUtil.classToName(javaClass);
        return Call(className, methodName, actualParameters);
    }

    /**
     * Calls a static method in the named class that is appropriate for the
     * actual parameters.
     * Uses <code>MethodResolver</code> to determine the appropriate method for
     * the actual parameters and then statically invokes the method.
     * 
     * @param className a fully qualified classname
     * @param methodName the name of the method to call
     * @param actualParameters the types of the actual parameters in the call stack
     * @return the return type of the called method
     */
    public Value Call(String className, String methodName, CallStack actualParameters) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        Type type = stringToClassType(className);
        return methodCall(type, methodName, actualParameters, true).getValue();
    }

    /**
     * Calls a method from the class instance on top of the stack that is
     * appropriate for the actual parameters.
     * Uses <code>MethodResolver</code> to determine the appropriate method for
     * the actual parameters and then determines whether the method is private, 
     * static, virtual or an interface method and uses the appropriate invocation.
     * 
     * @param type the type of the reference on top of the stack
     * @param methodName the name of the method to call
     * @param actualParameters the types of the actual parameters in the call stack
     * @return the return type of the called method
     */
    public Value Call(Value reference, String methodName, CallStack actualParameters) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        Type type = reference.getType();
        Type result = methodCall(reference.getType(), methodName, actualParameters, false);
        if (result == null) {
            throw new NullPointerException();
        }
        return result.getValue();
    }

    /**
     * Calls a method from the class instance on top of the stack that is
     * appropriate for the actual parameters.
     * </br>
     * Uses <code>MethodResolver</code> to determine the appropriate method for
     * the actual parameters and
     * then determines whether the method is private, static, virtual or an
     * interface method and uses the appropriate invocation.
     * 
     * @param type
     *            the type of the reference on top of the stack
     * @param actualParameters
     *            the types of the actual parameters in the call stack
     * @return the return type of the called method
     */
    private Type methodCall(Type refType, String methodName, CallStack actualParameters, boolean isStatic)
            throws ClassMakerException {
        if (!Type.isClass(refType)) {
            throw createException("ClassMaker.TypeIsNotAClass_1", refType.getName());
        }
        ClassType classType = refType.toClass();
        MakerMethod method = resolveMethod(classType, methodName, actualParameters);
        // Method must be static if reference was a declared type.
        if (isStatic && !method.isStatic()) {
            throw createException("ClassMaker.StaticCallToNonStaticMethod_2", method.toString(), method.getClassType()
                    .getName());
        }
        checker.checkAccessDenied(classType, method);
        markLineNumber(); // possibly add a new line number entry.
        if (classType.isInterface()) {
            getGen().invokeInterface(classType, method);
        } else if (method.isStatic()) {
            getGen().invokeStatic(classType.getName(), method);
        } else if (method.isPrivate()) {
            // FIXME Constructors and super methods
            getGen().invokeSpecial(classType, method);
        } else {
            getGen().invokeVirtual(classType, method);
        }
        return method.getReturnType();
    }

    /**
     * Throws an <code>Exception</code>.
     * </br>
     * The last statement of a method must be either <code>Return</code> or
     * <code>Throw</code>.
     * 
     * @param exception
     *            type exception being thrown
     */
    public void Throw(Value exception) throws ClassMakerException {
        if (isFirstPass()) {
            return;
        }
        markLineNumber(); // possibly add a new line number entry.
        Type type = exception.getType();
        if (!Type.isClass(type)) {
            throw createException("ClassMaker.CannotThrowType_1", type.getName());
        }
        if (!getFactory().getAssignmentConversion().isConvertable(type, ClassMakerFactory.THROWABLE_TYPE)) {
            throw createException("ClassMaker.ClassCannotBeThrown_1", type.getName());
        }
        getGen().Throw(type);

        // Throwing an exception is the equivalent of calling return;
        followsReturn = true;
    }

    /**
     * Returns from the current method.
     * </br>
     * The last statement of a method must be either <code>Return</code> or
     * <code>Throw</code>.
     */
    public void Return() throws ClassMakerException {
        if (isFirstPass()) {
            return;
        }
        if (isDebugCode()) {
            setDebugComment("Return();");
        }

        // Call any finally subroutines before returning
        Statement stmt = statementManager.topStatement();
        if (stmt == null || stmt.jumpToTarget(RETURN, null) == null) {
            throw createException("ClassMaker.ReturnWhileNotInAMethod");
        }
        if (!ClassMakerFactory.VOID_TYPE.equals(method.getReturnType())) {
            throw createException("ClassMaker.MethodMustReturnType_2", method.getName(), method.getReturnType()
                    .getName());
        }
        markLineNumber(); // possibly add a new line number entry.
        getGen().Return();

        // Indicate that return has been called.
        // This flag is reset by markLineNumber();
        followsReturn = true;
    }

    /**
     * Returns with the value on top of the stack.
     * </br>
     * Promotes the value to the return type using
     * <code>AssignmentConversion</code>.
     * The last statement of a method must be either <code>Return</code> or
     * <code>Throw</code>.
     */
    public void Return(Value value) throws ClassMakerException {
        if (isFirstPass()) {
            return;
        }
        if (isDebugCode()) {
            setDebugComment("Return(" + value + ");");
        }
        // Call any finally subroutines before returning
        Statement stmt = statementManager.topStatement();
        if (stmt == null || stmt.jumpToTarget(RETURN, null) == null) {
            throw createException("ClassMaker.ReturnWhileNotInAMethod");
        }
        if (ClassMakerFactory.VOID_TYPE.equals(method.getReturnType())) {
            throw createException("ClassMaker.MethodIsVoidSoMustNotReturnAValue_1", method.getName());
        }
        if (ClassMakerFactory.VOID_TYPE.equals(value.getType())) {
            throw createException("ClassMaker.CannotReturnTypeVoid");
        }
        // possibly add a new line number entry.
        markLineNumber();
        Type type = value.getType();
        Type returnType = method.getReturnType();
        if (getFactory().getAssignmentConversion().isConvertable(type, returnType)) {
            type = getFactory().getAssignmentConversion().convertTo(this, type, returnType);
        } else {
            throw createException("ClassMaker.MethodReturnsTypeSoCannotReturnType_3", method.getName(),
                    returnType.getName(), type.getName());
        }
        getGen().Return(type);

        // Indicate that return has been called.
        // This flag is reset by markLineNumber();
        followsReturn = true;
    }

    /**
     * Creates an empty call stack.
     * An empty stack can be used when calling methods that have no formal
     * parameters.
     * 
     * @return an empty call stack
     */
    public CallStack Push() throws ClassMakerException {
        return new CallStackMaker(this);
    }

    /**
     * Pushes an actual parameter onto a call stack.
     * </br>
     * Creates a <code>CallStack</code> and pushes the given parameter onto it.
     * The <code>CallStack</code> instance can be used to push more actual
     * parameters
     * by "daisy chaining" <code>Push</code> calls.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>process(1, a);<code></td>
     * <td>
     * <code>Call(This(), "process", Push(Literal(1)).Push(Get("a")));</code></td>
     * </tr>
     * </table>
     * 
     * @param param
     *            type of the actual parameter
     * @return a <code>CallStack</code> which can be used to <code>Push</code>
     *         more actual parameters types
     */
    public CallStack Push(Value param) throws ClassMakerException {
        CallStack stack = Push();
        if (param != null) {
            stack.Push(param);
        }
        return stack;
    }

    // Special references
    /**
     * Pushes a reference to <code>this</code> class onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>this.process();<code></td>
     * <td><code>Call(This(), "process", null);</code></td>
     * </tr>
     * </table>
     * 
     * @return a Value representing this class
     */
    public Value This() throws ClassMakerException {
        if (!isFirstPass()) {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode()) {
                setDebugComment("This();");
            }
            getGen().loadThis();
        }
        return thisClassType.getValue();
    }

    /**
     * Pushes a reference to this class's <code>super</code> class onto the
     * stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>super();<code></td>
     * <td><code>Init(Super(), null);</code></td>
     * </tr>
     * <tr>
     * <td><code>super.process();<code></td>
     * <td><code>Call(Super(), "process", null);</code></td>
     * </tr>
     * </table>
     * 
     * @return a Value representing the super class
     */
    public Value Super() throws ClassMakerException {
        if (!isFirstPass()) {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode()) {
                setDebugComment("Super();");
            }
            getGen().loadThis();
        }
        return getExtendsType().getValue();
    }

    /**
     * Pushes <code>null</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>null<code></td>
     * <td><code>Null()</code></td>
     * </tr>
     * </table>
     * 
     * @return the type for <code>null</code>
     */
    public Value Null() throws ClassMakerException {
        if (!isFirstPass()) {
            markLineNumber(); // possibly add a new line number entry.
            if (isDebugCode()) {
                setDebugComment("Null();");
            }
            getGen().Null();
        }
        return ClassMakerFactory.NULL_TYPE.getValue();
    }

    // Literals
    /**
     * Pushes a literal <code>double</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>234.56789D<code></td>
     * <td><code>Literal(234.56789D)</code></td>
     * </tr>
     * </table>
     * 
     * @param value
     *            the double to be pushed onto the stack
     * @return the type for <code>double</code>
     */
    public Value Literal(double value) throws ClassMakerException {
        markLineNumber(); // possibly add a new line number entry.
        return isFirstPass() ? null : getGen().Literal(value);
    }

    /**
     * Pushes a literal <code>float</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>223.345F<code></td>
     * <td><code>Literal(123.456F)</code></td>
     * </tr>
     * </table>
     * 
     * @param value
     *            the float to be pushed onto the stack
     * @return the type for <code>float</code>
     */
    public Value Literal(float value) throws ClassMakerException {
        markLineNumber(); // possibly add a new line number entry.
        return isFirstPass() ? null : getGen().Literal(value);
    }

    /**
     * Pushes a literal <code>long</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>2000000L<code></td>
     * <td><code>Literal(2000000L)</code></td>
     * </tr>
     * </table>
     * 
     * @param value
     *            the long to be pushed onto the stack
     * @return the type for <code>long</code>
     */
    public Value Literal(long value) throws ClassMakerException {
        markLineNumber(); // possibly add a new line number entry.
        return isFirstPass() ? null : getGen().Literal(value);
    }

    /**
     * Pushes a literal <code>int</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>200<code></td>
     * <td><code>Literal(200)</code></td>
     * </tr>
     * </table>
     * 
     * @param value
     *            the int to be pushed onto the stack
     * @return the type for <code>int</code>
     */
    public Value Literal(int value) throws ClassMakerException {
        markLineNumber(); // possibly add a new line number entry.
        return isFirstPass() ? null : getGen().Literal(value);
    }

    /**
     * Pushes a literal <code>char</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>'Z'<code></td>
     * <td><code>Literal('Z')</code></td>
     * </tr>
     * </table>
     * 
     * @param value
     *            the char to be pushed onto the stack
     * @return the type for <code>char</code>
     */
    public Value Literal(char value) throws ClassMakerException {
        markLineNumber(); // possibly add a new line number entry.
        return isFirstPass() ? null : getGen().Literal(value);
    }

    /**
     * Pushes a literal <code>byte</code> value onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>(byte)200<code></td>
     * <td><code>Literal((byte)200)</code></td>
     * </tr>
     * </table>
     * 
     * @param value
     *            the byte to be pushed onto the stack
     * @return the type for <code>byte</code>
     */
    public Value Literal(byte value) throws ClassMakerException {
        markLineNumber(); // possibly add a new line number entry.
        return isFirstPass() ? null : getGen().Literal(value);
    }

    /**
     * Pushes a literal <code>short</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>(short)32000<code></td>
     * <td><code>Literal((short)32000)</code></td>
     * </tr>
     * </table>
     * 
     * @param value
     *            the short to be pushed onto the stack
     * @return the type for <code>short</code>
     */
    public Value Literal(short value) throws ClassMakerException {
        markLineNumber(); // possibly add a new line number entry.
        return isFirstPass() ? null : getGen().Literal(value);
    }

    /**
     * Pushes a literal <code>boolean</code> value onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>true<code></td>
     * <td><code>Literal(true)</code></td>
     * </tr>
     * </table>
     * 
     * @param value
     *            the boolean value to be pushed onto the stack
     * @return the type for <code>boolean</code>
     */
    public Value Literal(boolean value) throws ClassMakerException {
        markLineNumber(); // possibly add a new line number entry.
        return isFirstPass() ? null : getGen().Literal(value);
    }

    /**
     * Pushes a literal <code>String</code> onto the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>"Hello World"<code></td>
     * <td><code>Literal("Hello World")</code></td>
     * </tr>
     * </table>
     * 
     * @param value
     *            the string to be pushed onto the stack
     * @return the type for <code>String</code>
     */
    public Value Literal(String value) throws ClassMakerException {
        markLineNumber(); // possibly add a new line number entry.
        return isFirstPass() ? null : getGen().Literal(value);
    }

    //#################### Getters and Setters ######################
    /**
     * Assigns the value on top of the stack to a local variable or formal
     * parameter and leaves the value on the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>x = i = a;<code></td>
     * <td><code>Eval(Assign("x", Assign("i", Get("a"))));</code></td>
     * </tr>
     * </table>
     * The value is subject to assignment conversion before it is stored.
     * A copy of the unconverted value is left on top of the stack.
     * 
     * @param name
     *            the name of the local variable
     * @param value
     *            the value being set
     * @return the unconverted value on top of the stack
     */
    public Value Assign(String name, Value value) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("Assign(" + name + ", " + value + ")");
        }
        // Stack: value
        getGen().dup(value.getType());
        // Stack: value, value
        Set(name, value);
        // Stack: value
        return value;
    }

    /**
     * Assigns a value to a member variable and leaves the value on the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>x = obj.i = a;<code></td>
     * <td><code>Eval(Assign("x", Assign(Get("obj"), "i", Get("a"))));</code></td>
     * </tr>
     * </table>
     * The value is subject to assignment conversion before it is stored.
     * A copy of the unconverted value is left on top of the stack.
     * 
     * @param refType
     *            the type of the class containing the variable
     * @param fieldName
     *            the name of the member variable
     * @param value
     *            the value to be set
     * @return the unconverted value on top of the stack
     */
    public Value Assign(Value reference, String fieldName, Value value) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        Type refType = reference.getType();
        Type valueType = value.getType();
        if (isDebugCode()) {
            setDebugComment("Assign(" + refType + ", " + fieldName + ", " + valueType + ")");
        }
        // Duplicate the value on top of the stack before storing it.
        // Stack: reference, value
        getGen().dupunder(refType, valueType);
        // Stack: value, reference, value
        Set(reference, fieldName, value);
        // Stack: value
        return value;
    }

    /**
     * Assigns a value to a static member field, leaving the value on top of the
     * stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>MyClass.i = a;<code></td>
     * <td><code>Eval(Assign("MyClass", "i", Get("a")));</code></td>
     * </tr>
     * </table>
     * The value is subject to assignment conversion before it is stored.
     * A copy of the unconverted value is left on top of the stack.
     * 
     * @param className
     *            the short or fully qualified name of the class
     * @param fieldName
     *            the name of the static member variable
     * @param valueType
     *            the type of the value to be set
     * @return the unconverted value on top of the stack
     */
    public Value Assign(String className, String fieldName, Value value) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("Assign(" + className + ", " + fieldName + ", " + value + ")");
        }
        // Duplicate the value on top of the stack before storing it.
        // Stack: value
        getGen().dup(value.getType());
        // Stack: value, value
        Set(className, fieldName, value);
        // Stack: value
        return value;
    }

    /**
     * Sets the value on top of the stack to the named local variable or formal
     * parameter.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>i = a;<code></td>
     * <td><code>Set("i", Get("a"));</code></td>
     * </tr>
     * </table>
     * Performs assignment conversion on the value on top of the stack before
     * storing it in the named local variable.
     * 
     * @param name
     *            name of the local variable
     * @param type
     *            type of the value being set
     * @return <code>ClassMaker.VOID_TYPE</code>
     */
    public Value Set(String name, Value value) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        Type valueType = value.getType();
        if (isDebugCode()) {
            setDebugComment("Set(" + name + ", " + valueType + ")");
        }
        markLineNumber(); // possibly add a new line number entry.

        MakerField field = Find(name);
        Type varType = field.getType();
        if (getFactory().getAssignmentConversion().isConvertable(valueType, varType))
            valueType = getFactory().getAssignmentConversion().convertTo(this, valueType, varType);
        else
            throw createException("ClassMaker.CannotAssignToLocalVariableOfType_3", valueType.getName(),
                    field.getName(), varType.getName());

        getGen().storeLocal(field);
        return ClassMakerFactory.VOID_TYPE.getValue();
    }

    /**
     * Sets a member variable to a value.
     * </br>
     * Set differs from Assign in that the value is not left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>obj.i = a;<code></td>
     * <td><code>Eval(Set(Get("obj"), "i", Get("a")));</code></td>
     * </tr>
     * </table>
     * The value is subject to assignment conversion before it is set.
     * 
     * @param reference a reference to the class containing the variable
     * @param fieldName the name of the member variable
     * @param valueType the type of the value to be set
     * @return a <code>Value</code> representing <code>void</code>
     */
    public Value Set(Value reference, String fieldName, Value value) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        Type valueType = value.getType();
        if (isDebugCode()) {
            setDebugComment("Set(" + reference + ", " + fieldName + ", " + valueType + ")");
        }
        MakerField field = Find(reference, fieldName);
        Type fieldType = field.getType();
        if (fieldType == null) {
            throw createException("ClassMaker.FieldTypeCannotBeDetermined_1");
        }
        if (!getFactory().getAssignmentConversion().isConvertable(valueType, fieldType)) {
            String classField = field.getClassType().getName() + '.' + field.getName();
            throw createException("ClassMaker.FieldOfTypeCannotBeAssignedType_3", classField, fieldType.getName(),
                    valueType.getName());
        }

        markLineNumber(); // possibly add a new line number entry.
        getFactory().getAssignmentConversion().convertTo(this, valueType, fieldType);

        getGen().storeField(field);
        return ClassMakerFactory.VOID_TYPE.getValue();
    }

    /**
     * Sets a static member field to a value.
     * </br>
     * Set differs from Assign in that the value is not left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>MyClass.i = a;<code></td>
     * <td><code>Set("MyClass", "i", Get("a"));</code></td>
     * </tr>
     * </table>
     * The value is subject to assignment conversion before it is set.
     * 
     * @param className the short or fully qualified name of the class
     * @param fieldName the name of the static member variable
     * @param valueType the type of the value to be set
     * @return a <code>Value</code> representing <code>void</code>
     */
    public Value Set(String className, String fieldName, Value value) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        Type valueType = value.getType();
        if (isDebugCode()) {
            setDebugComment("Set(" + className + ", " + fieldName + ", " + valueType + ")");
        }
        // Find checks that the field is static
        MakerField field = Find(className, fieldName);
        Type type = field.getType();

        if (!getFactory().getAssignmentConversion().isConvertable(valueType, type)) {
            throw createException("ClassMaker.StaticFieldOfTypeCannotBeAssignedType_3", field.getName(),
                    type.getName(), valueType.getName());
        }
        markLineNumber(); // possibly add a new line number entry.
        getFactory().getAssignmentConversion().convertTo(this, valueType, type);
        getGen().storeStatic(field);
        return ClassMakerFactory.VOID_TYPE.getValue();
    }

    /**
     * Gets a value from a member variable.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>obj.i<code></td>
     * <td><code>Get(Get("obj"), "i");</code></td>
     * </tr>
     * </table>
     * 
     * @param reference
     *            the type of the class containing the variable
     * @param fieldName
     *            the name of the member variable
     * @return the type of the value left on the stack
     */
    public Value Get(Value reference, String fieldName) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        markLineNumber(); // possibly add a new line number entry.
        if (isDebugCode()) {
            setDebugComment("Get(" + reference + ", " + fieldName + ")");
        }
        MakerField field = Find(reference, fieldName);
        return getGen().loadField(field).getValue();
    }

    /**
     * Gets a value from a static member variable.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>MyClass.i<code></td>
     * <td><code>Get("MyClass", "i");</code></td>
     * </tr>
     * </table>
     * 
     * @param className
     *            the short or fully qualified name of the class
     * @param fieldName
     *            the name of the static member variable
     * @return the type of the value left on the stack
     */
    public Value Get(String className, String fieldName) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("Get(\"" + className + "\", " + fieldName + ")");
        }
        markLineNumber(); // possibly add a new line number entry.
        MakerField field = Find(className, fieldName);
        return getGen().loadStatic(field);
    }

    /**
     * Gets a local variable or formal parameter by name.
     * 
     * @param name
     *            name of the local variable
     * @return type of the local variable
     */
    public Value Get(String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("Get(" + name + ");");
        }
        markLineNumber(); // possibly add a new line number entry.
        MakerField field = Find(name);
        return getGen().loadLocal(field);
    }

    //##################### Member Field Methods. #####################

    /**
     * Finds a named field in the given class.
     * </br>
     * Delegates to <code>findMemberField</code> and throws an
     * <code>Exception</code> if the field is not found.
     * 
     * @param reference
     *            a Value representing a class reference on the stack
     * @param name
     *            name of the member field
     * @return the <code>MakerField</code> corresponding to the given name
     * @throws ClassMakerException
     *             if the field is not found
     */
    public MakerField Find(Value reference, String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        assertNotNull(reference, "reference");
        assertNotNull(name, "name");
        ClassType classType = reference.toClass();
        if (classType == null) {
            throw createException("ClassMaker.TypeMustBeAClass_1", reference.getName());
        }
        MakerField field = classType.findField(name);
        if (field == null) {
            throw createException("ClassMaker.CannotFindMemberFieldInClass_2", name, classType.getName()); 
        }
        checker.checkAccessDenied(classType, field);
        return field;
    }

    public Type findType(String name) {
        assertNotNull(name, "name");
        // The import table maps simple class names to ClassTypes.
        Type type = findImportedType(name);
        if (type == null) {
            type = findPackageType(name);
        }
        if (type == null) {
            type = getFactory().stringToType(name);
        }
        return type;
    }

    /**
     * Finds a named field in the given class.
     * </br>
     * Delegates to <code>findMemberField</code> and throws an
     * <code>Exception</code> if the field is not found.
     * 
     * @param classType
     *            type of the class
     * @param name
     *            name of the member field
     * @return the <code>MakerField</code> corresponding to the given name
     * @throws ClassMakerException
     *             if the field is not found
     */
    public MakerField Find(String className, String fieldName) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        ClassType classType = stringToClassType(className);
        MakerField field = classType.findField(fieldName); 
        if (field == null) {
            throw createException("ClassMaker.CannotFindStaticFieldInClass_2", fieldName, classType.getName());
        }
        if (!field.isStatic()) {
            throw createException("ClassMaker.ClassVariableIsNotStatic_1", classType.getName() + "." + fieldName);
        }
        checker.checkAccessDenied(classType, field);
        return field;
    }

    /**
     * Finds a member field declared in the class being generated.
     * 
     * @param name
     *            name of the member field
     * @return the <code>MakerField</code> corresponding to the given name
     */
    private MakerField findMemberField(String name) {
        for (int i = 0; i < fieldTable.size(); i++) {
            MakerField field = fieldTable.get(i);
            if (name.equals(field.getName())) {
                return fieldTable.get(i);
            }
        }
        return null;
    }

    /**
     * Adds a member field to the class being generated.
     * 
     * @param name
     *            name of the field
     * @param type
     *            type of the field
     * @param modifiers
     *            access modifiers
     * @return index of the field in <code>fieldTable</code>
     */
    int addMemberField(String name, Type type, int modifiers) {
        checker.checkFieldModifiers(modifiers);

        MakerField field = new MakerField(getClassType(), name, type, modifiers);
        int index = fieldTable.size();
        fieldTable.add(field);
        return index;
    }

    //##################### Find Types. #####################

    /**
     * Converts a class name to a <code>ClassType</code>.
     * </br>
     * An existing <code>ClassType</code> is returned if the java class has been
     * used previously.
     * A simple class name will be successful if the class was previously
     * imported. <code>Type</code>s are cached in the shared
     * <code>ClassMakerFactory</code>.
     * 
     * @param className
     *            the short or fully qualified name of the <code>Class</code>
     * @return the <code>ClassType</code> associated with the className
     * @throws ClassMakerException
     *             if the class does not exist
     */
    public ClassType stringToClassType(String className) throws ClassMakerException {
        Type type = findType(className);
        if (type == null || type.toClass() == null) {
            throw createException("ClassMaker.NoClassTypeCalled_1", className);
        }
        return type.toClass();
    }

    /**
     * Converts a type name to a <code>Type</code>.
     * </br>
     * An existing Type is returned if a primitive type is named or the java
     * class has been used previously.
     * A simple class name will be successful if the class was imported.
     * <code>Type</code>s are cached in the shared
     * <code>ClassMakerFactory</code>.
     * 
     * @param typeName
     *            the simple name or fully qualified name of the type
     * @return the <code>Type</code> associated with the typeName
     * @throws ClassMakerException
     *             if the type does not exist
     */
    public Type stringToType(String typeName) throws ClassMakerException {
        Type type = findType(typeName);
        if (type == null) {
            throw createException("ClassMaker.NoTypeCalled_1", typeName);
        }
        return type;
    }

    private Type findPackageType(String className) throws ClassMakerException {
        Type classType = null;
        if (packageName != null && !"".equals(packageName)) {
            String classNameFQ = packageName + "." + className;
            classType = getFactory().stringToType(classNameFQ);
        }
        return classType;
    }

    /**
     * Finds a <code>ClassType</code> given a simple or fully qualified class
     * name.
     * </br>
     * Aliases are created by the <code>Import</code> method.
     * The simple class name is an alias for the fully qualified class name.
     * Aliases are stored locally in the <code>ClassMaker</code> instance.
     * </br>
     * A fully qualified class name must be used if two classes are imported
     * with the same
     * simple name, e.g. java.util.Date and java.sql.Date.
     * 
     * @param className
     *            the simple or fully qualified class name
     * @return the <code>ClassType</code> corresponding to the name
     * @throws ClassMakerException
     *             if a fully qualified class name must be used
     */
    public ClassType findImportedType(String className) throws ClassMakerException {
        ClassType classType = importMap.get(MakerUtil.toDotName(className));
        if (classType != null) {
            // The alias map uses NULL_TYPE if more than one class with the same simple class name has been imported.
            if (ClassMakerFactory.NULL_TYPE.equals(classType)) {
                throw createException("ClassMaker.MustUseFullyQualifiedClassName_1", className);
            }
        } else {
            classType = findImportedStar(className);
        }
        return classType;
    }

    /**
     * Finds a <code>ClassType</code> given a simple class name.
     * </br>
     * Default packages to search are added by the <code>ImportStar</code> method.
     * The simple class name is appended to each package name to find a matching class.
     * 
     * @param className the simple name for the class
     * @return the <code>ClassType</code> corresponding to the name; otherwise null
     * @throws ClassMakerException if className is found in more than one imported package
     */
    public ClassType findImportedStar(String className) throws ClassMakerException {
        ClassType result = null;
        for (String packageName : importStar) {
            String fullyQualifiedName = packageName + '.' + className;
            Type type = factory.stringToType(fullyQualifiedName);
            if (type != null && type.toClass() != null) {
                ClassType classType = type.toClass();
                if (result == null) {
                    result = classType;
                } else {
                    throw createException("ClassMaker.MustUseFullyQualifiedClassName_1", className);
                }
            }
        }
        return result;
    }
    
    //############### Local variable methods ##################

    /**
     * Finds a local variable in the method.
     * 
     * @param name
     *            the name of the variable
     * @return a <code>Field</code> that describes the variable
     */
    public MakerField Find(String name) // FIXME rename
    {
        if (isFirstPass()) {
            return null;
        }
        checkInMethod();
        MakerField field = findField(name);
        if (field == null) {
            throw createException("ClassMaker.NoLocalCalled_1", name);
        }
        return field;
    }

    /**
     * Gets a local variable or formal parameter by name.
     * 
     * @param name
     *            name of the local variable
     * @return type of the local variable
     */
    public MakerField findField(String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        checkInMethod();
        MakerField field = getLocalFields().findLocalField(name);
        if (field == null) {
            field = getClassType().findField(name);
        }
        return field;
    }

    LocalFieldList getLocalFields() {
        if (!isInMethod()) {
            throw new NullPointerException("Local fields are only available within a method");            
        }
        return localFields;
    }
    
    //############# Variable declarations ################

    /**
     * Declare a local variable or member field using a java class descriptor.
     * </br>
     * This method is used to declare all variables. The variable will be a
     * class member, formal parameter or local variable depending upon where
     * the <code>declare</code> method is called.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code><pre>
    class Process
    {
        public int       c1;
        protected String c2;
        private int      c3;
        int              c4;
        public static String s1;   &nbsp;

        public void process(
            String p1,
            final int p2 )
        {
            String l1;
            volatile int l2;
        }
    }
     * </pre><code></td>
     * <td><code><pre>
    class ProcessMaker extends ClassMakerBase {
    public void code() {
        Declare("c1", int.class, ACC_PUBLIC);
        Declare("c1", String.class, ACC_PROTECTED);
        Declare("c1", int.class, ACC_PRIVATE);
        Declare("c1", int.class, 0);
        Declare("s1", String.class, ACC_PUBLIC | ACC_STATIC);   &nbsp;

        Method("process", void.class, ACC_PUBLIC);
            Declare("p1", String.class, 0);
            Declare("p2", int.class, ACC_FINAL);
        Begin();
            Declare("l1", String.class, 0);
            Declare("l2", int.class, ACC_VOLATILE);
        End();
    }
       </pre></code></td>
     * </tr>
     * </table>
     * 
     * @param name
     *            the name of the variable
     * @param javaClass
     *            a class that describes the type of the variable
     * @param modifiers
     *            bitmask of variable modifiers
     */
    public void Declare(String name, Class javaClass, int modifiers) throws ClassMakerException {
        Type type = getFactory().classToType(javaClass);
        Declare(name, type, modifiers);
    }

    /**
     * Declare a local variable or member field using the name of a type.
     * </br>
     * This method is used to declare all variables. The variable will be a
     * class member, formal parameter or local variable depending upon where
     * the <code>declare</code> method is called.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code><pre>
    class Process
    {
        public int       c1;
        protected String c2;
        private int      c3;
        int              c4;
        public static String s1;   &nbsp;

        public void process(
            String p1,
            final int p2 )
        {
            String l1;
            volatile int l2;
        }
    }
     * </pre><code></td>
     * <td><code><pre>
    class ProcessMaker extends ClassMakerBase {
    public void code() {
        Declare("c1", "int", ACC_PUBLIC);
        Declare("c1", "String", ACC_PROTECTED);
        Declare("c1", "int", ACC_PRIVATE);
        Declare("c1", "int", 0);
        Declare("s1", "String", ACC_PUBLIC | ACC_STATIC);   &nbsp;

        Method("process", void.class, ACC_PUBLIC);
            Declare("p1", "String", 0);
            Declare("p2", "int", ACC_FINAL);
        Begin();
            Declare("l1", "String", 0);
            Declare("l2", "int", ACC_VOLATILE);
        End();
    }
       </pre></code></td>
     * </tr>
     * </table>
     * 
     * @param name
     *            the name of the variable
     * @param typeName
     *            the name of the type of the variable
     * @param modifiers
     *            bitmask of variable modifiers
     */
    public void Declare(String name, String typeName, int modifiers) throws ClassMakerException {
        Type type = stringToType(typeName);
        Declare(name, type, modifiers);
    }

    /**
     * Declares a local variable or member field using a <code>Type</code>.
     * </br>
     * This version of <code>Declare</code> may be used when there is no
     * class descriptor for the type.
     * The first pass of a two pass compiler will produce a <code>Type</code>,
     * but the <code>Class</code> will not be available until after the second
     * pass.
     * The <code>Type</code> can be used to declare Classes during the first
     * pass.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code><pre>
        public OtherClass x;
     * </pre><code></td>
     * <td><code><pre>
        Type otherClass = findClass("au.com.Illyrian.OtherClass");
        Declare("x", otherClass, ACC_PUBLIC);
       </pre></code></td>
     * </tr>
     * </table>
     * 
     * @param name
     *            the name of the variable
     * @param type
     *            the type of the variable
     * @param modifiers
     *            bitmask of variable modifiers
     */
    public void Declare(String name, Type type, int modifiers) throws ClassMakerException {
        if (getPass() != FIRST_PASS) {
            if (ClassMakerFactory.VOID_TYPE.equals(type) || ClassMakerFactory.NULL_TYPE.equals(type)) {
                throw createException("ClassMaker.CannotDeclareType_1", type.getName());
            }
        }
        if (!isInMethod()) { // Class Member Field
            MakerField field = findMemberField(name);
            if (getPass() != SECOND_PASS) {
                if (field != null) {
                    throw createException("ClassMaker.DuplicateMemberFieldDeclaration_1", name);
                }
                addMemberField(name, type, modifiers);
            }
            if (getGen() != null) {
                getGen().declareVariable(name, type, modifiers);
            }
        } else { // Local variable or parameter
            if (getPass() != SECOND_PASS && localFields.findLocalField(name) != null) {
                throw createException("ClassMaker.DuplicateLocalVariableDeclaration_1", name);
            }
            MakerField local = localFields.addLocalField(name, type, modifiers, getScopeLevel(), getProgramCounter());
            if (getGen() != null) {
                getGen().addToScope(local, getScopeLevel());
                if (isInBody()) {
                    getGen().initLocal(local);
                }
            }
        }
    }

    /**
     * The nesting level of the current scoped code block.
     * 
     * @return the nesting level of the current scoped code block
     */
    int getScopeLevel() {
        if (statementManager.topStatement() == null) {
            return 1;
        } else {
            return statementManager.topStatement().getScopeLevel();
        }
    }

    protected int getProgramCounter() {
        return (getGen() != null) ? getGen().getProgramCounter() : 0;
    }

    //################### Casting methods. ##################
    /**
     * Casts a value to a type represented by a string.
     * </br>
     * Performs a casting conversion between the source and target types.
     * The short or fully qualified name of the target class may be used.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>(Runnable)a<code></td>
     * <td><code>Cast(Get("a"), "java/lang/Runnable")</code></td>
     * </tr>
     * <tr>
     * <td><code>(String)null<code></td>
     * <td><code>Cast(Null(), "String")</code></td>
     * </tr>
     * </table>
     * 
     * @param source
     *            the value on top of the stack
     * @param target
     *            the type into which to cast
     * @return the value cast to the target type
     */
    public Value Cast(Value source, String target) throws ClassMakerException {
        Type makerType = stringToType(target);
        return Cast(source, makerType);
    }

    /**
     * Casts a value to a type represented by a Class.
     * </br>
     * Performs a casting conversion between the source and target types.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>(Runnable)a<code></td>
     * <td><code>Cast(Get("a"), Runnable.class)</code></td>
     * </tr>
     * <tr>
     * <td><code>(String)null<code></td>
     * <td><code>Cast(Null(), String.class)</code></td>
     * </tr>
     * </table>
     * 
     * @param source
     *            the value on top of the stack
     * @param target
     *            the type into which to cast
     * @return the value cast to the target type
     */
    public Value Cast(Value source, Class target) throws ClassMakerException {
        Type type = getFactory().classToType(target);
        return Cast(source, type);
    }

    /**
     * Casts a value from one Type to another.
     * Performs a casting conversion between the source and target types.
     * 
     * @param source
     *            the value on top of the stack
     * @param target
     *            the type into which to cast
     * @return the value cast to the target type
     */
    public Value Cast(Value source, Type target) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("Cast(" + source + ", " + target + ");");
        }
        markLineNumber(); // possibly add a new line number entry.
        Type sourceType = source.getType();
        if (getFactory().getCastingConversion().isConvertable(sourceType, target)) {
            return getFactory().getCastingConversion().convertTo(this, sourceType, target).getValue();
        } else {
            throw createException("ClassMaker.CannotCastFromTypeToType_2", source.getName(), target.getName());
        }
    }

    public Value InstanceOf(Value reference, Class javaClass) {
        Type type = getFactory().classToType(javaClass);
        return InstanceOf(reference, type);
    }

    public Value InstanceOf(Value reference, String target) {
        Type type = findType(target);
        return InstanceOf(reference, type);
    }

    public Value InstanceOf(Value reference, Type target) {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("InstanceOf(" + reference.getName() + ", " + target.getName() + ");");
        }
        if (reference.toClass() == null) {
            throw createException("ClassMaker.InstanceOfMustTestAClass_1", reference.getName());
        }
        if (target.toClass() == null) {
            throw createException("ClassMaker.CannotTestInstanceOfType_1", target.getName());
        }
        markLineNumber(); // possibly add a new line number entry.
        return getGen().checkInstanceOf(reference.getType(), target.toClass()).getValue();
    }

    //################ Arithmetic operators ######################

    /**
     * <b>Add</b>s the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then added.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a + b<code></td>
     * <td><code>Add(Get("a"), Get("b"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the left operand
     * @param op2
     *            the type of the right operand
     * @return the type of the result after promotion
     */
    public Value Add(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        markLineNumber(); // possibly add a new line number entry.

        if (isNumericType(op1) && isNumericType(op2)) {
            if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
                op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
            }
            return getGen().primitiveAdd(op1.toPrimitive(), op2.toPrimitive()).getValue();
        } else if (getFactory().getStringConversion().isConvertable(op1, op2)) {
            return getFactory().getStringConversion().convertTo(this, op1, op2).getValue();
        } else {
            throw createException("ClassMaker.CannotAddType_2", op1.getName(), op2.getName());
        }
    }

    /**
     * <b>Subt</b>racts the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then
     * subtracted.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a - b<code></td>
     * <td><code>Subt(Get("a"), Get("b"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the left operand
     * @param op2
     *            the type of the right operand
     * @return the type of the result after promotion
     */
    public Value Subt(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        markLineNumber(); // possibly add a new line number entry.

        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (op1 == op2 && isNumericType(op1)) {
            return getGen().primitiveSubt(op1.toPrimitive(), op2.toPrimitive()).getValue();
        } else {
            throw createException("ClassMaker.CannotSubtractType_2", op1.getName(), op2.getName());
        }
    }

    /**
     * <b>Mult</b>iplies the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then
     * multiplied.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a * b<code></td>
     * <td><code>Mult(Get("a"), Get("b"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the left operand
     * @param op2
     *            the type of the right operand
     * @return the type of the result after promotion
     */
    public Value Mult(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        if (isDebugCode()) {
            setDebugComment("Mult(" + op1 + ", " + op2 + ");");
        }
        markLineNumber(); // possibly add a new line number entry.

        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (op1 == op2 && isNumericType(op1)) {
            return getGen().primitiveMult(op1.toPrimitive(), op2.toPrimitive()).getValue();
        } else {
            throw createException("ClassMaker.CannotMultiplyType_2", op1.getName(), op2.getName());
        }
    }

    /**
     * <b>Div</b>ides the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then divided.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a / b<code></td>
     * <td><code>Div(Get("a"), Get("b"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the left operand
     * @param op2
     *            the type of the right operand
     * @return the type of the result after promotion
     */
    public Value Div(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (op1 == op2 && isNumericType(op1)) {
            return getGen().primitiveDiv(op1.toPrimitive(), op2.toPrimitive()).getValue();
        } else {
            throw createException("ClassMaker.CannotDivideType_2", op1.getName(), op2.getName());
        }
    }

    /**
     * Determines the integer <b>Rem</b>ainder after dividing the two values on
     * top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then integer
     * divided.
     * The remainder is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a % 3<code></td>
     * <td><code>Rem(Get("a"), Literal(3))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the left operand
     * @param op2
     *            the type of the right operand
     * @return the type of the result after promotion
     */
    public Value Rem(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        markLineNumber(); // possibly add a new line number entry.

        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (op1 == op2 && isNumericType(op1)) {
            return getGen().primitiveRem(op1.toPrimitive(), op2.toPrimitive()).getValue();
        } else {
            throw createException("ClassMaker.CannotRemainderType_2", op1.getName(), op2.getName());
        }
    }

    /**
     * Negates the numeric value on top of the stack.
     * </br>
     * The value is numerically promoted to <code>int</code>, if appropriate,
     * and then negated.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>-a<code></td>
     * <td><code>Neg(Get("a"))</code></td>
     * </tr>
     * </table>
     * 
     * @param type
     *            the Value of the value
     * @return the type of the promoted value
     */
    public Value Neg(Value value) {
        if (isFirstPass()) {
            return null;
        }
        Type type = value.getType();
        markLineNumber(); // possibly add a new line number entry.

        if (getFactory().getNumericPromotion().isConvertable(type)) {
            type = getFactory().getNumericPromotion().convertTo(this, type);
        }
        if (isNumericType(type)) {
            return getGen().primitiveNeg(type).getValue();
        } else {
            throw createException("ClassMaker.CannotNegType_1", type.getName());
        }
    }

    /**
     * Applies bitwise <b>exclisive or</b> to the two values on top of the
     * stack.
     * </br>
     * The operands are numerically promoted to the same type and then exclusive
     * or'ed.
     * A result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a ^ 3<code></td>
     * <td><code>Xor(Get("a"), Literal(3))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the left operand
     * @param op2
     *            the type of the right operand
     * @return the type of the result after promotion
     */
    public Value Xor(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        markLineNumber(); // possibly add a new line number entry.

        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (isLongIntegerType(op1) && op1.equals(op2)) {
            return getGen().primitiveXor(op1.toPrimitive(), op2.toPrimitive()).getValue();
        } else {
            throw createException("ClassMaker.CannotXorType_2", op1.getName(), op2.getName());
        }
    }

    /**
     * Applies bitwise <b>and</b> to the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then bitwised
     * and'ed.
     * A result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a & 3<code></td>
     * <td><code>And(Get("a"), Literal(3))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the left operand
     * @param op2
     *            the type of the right operand
     * @return the type of the result after promotion
     */
    public Value And(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (isLongIntegerType(op1) && op1.equals(op2)) {
            return getGen().primitiveAnd(op1.toPrimitive(), op2.toPrimitive()).getValue();
        } else {
            throw createException("ClassMaker.CannotAndType_2", op1.getName(), op2.getName());
        }
    }

    /**
     * Applies bitwise <b>or</b> to the two values on top of the stack.
     * </br>
     * The operands are numerically promoted to the same type and then bitwised
     * or'ed.
     * The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a | 3<code></td>
     * <td><code>Or(Get("a"), Literal(3))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the left operand
     * @param op2
     *            the type of the right operand
     * @return the type of the result after promotion
     */
    public Value Or(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        markLineNumber(); // possibly add a new line number entry.

        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (isLongIntegerType(op1) && op1.equals(op2)) {
            return getGen().primitiveOr(op1.toPrimitive(), op2.toPrimitive()).getValue();
        } else {
            throw createException("ClassMaker.CannotOrType_2", op1.getName(), op2.getName());
        }
    }

    /**
     * Applies bitwise <b>Inv</b>ersion to the value on top of the stack.
     * </br>
     * The operand is numerically promoted to an <code>int</code>, if
     * appropriate,
     * and then bitwised inverted. The result is left on the stack.
     *
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>~ a<code></td>
     * <td><code>Inv(Get("a"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the left operand
     * @return the type of the result after promotion
     */
    public Value Inv(Value value) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value.getType();
        markLineNumber(); // possibly add a new line number entry.
        if (getFactory().getNumericPromotion().isConvertable(op1)) {
            op1 = getFactory().getNumericPromotion().convertTo(this, op1);
        }
        if (Type.isPrimitive(op1) && isLongIntegerType(op1)) {
            return getGen().primitiveInv(op1.toPrimitive()).getValue();
        } else {
            throw createException("ClassMaker.CannotInvertType_1", op1.getName());
        }
    }

    //################ Bitwise shifting operators ####################

    static boolean isIntegerType(Type operand) {
        return ClassMakerFactory.INT_TYPE.equals(operand) || ClassMakerFactory.SHORT_TYPE.equals(operand)
                || ClassMakerFactory.CHAR_TYPE.equals(operand) || ClassMakerFactory.BYTE_TYPE.equals(operand);
    }

    static boolean isLongIntegerType(Type operand) {
        return isIntegerType(operand) || ClassMakerFactory.LONG_TYPE.equals(operand);
    }

    static boolean isNumericType(Type operand) {
        return isLongIntegerType(operand) || 
                ClassMakerFactory.FLOAT_TYPE.equals(operand) || 
                ClassMakerFactory.DOUBLE_TYPE.equals(operand);
    }

    /**
     * <b>SH</b>ifts <b>L</b>eft the value of the first operand by the number of
     * bits indicated by the second operand.
     * </br>
     * The operands are independantly numerically promoted.
     * A shifted result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a << 3<code></td>
     * <td><code>SHL(Get("a"), Literal(3))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the operand being shifted
     * @param op2
     *            the type of the operand indicating places to shift
     * @return the type of op1 after promotion
     */
    public Value SHL(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        if (isDebugCode()) {
            setDebugComment("SHL(" + op1 + ", " + op2 + ");");
        }
        markLineNumber(); // possibly add a new line number entry.

        // Promote left and right operands independantly.
        if (getFactory().getNumericPromotion().isConvertable(op1)) {
            op1 = getFactory().getNumericPromotion().convertTo(this, op1);
        }
        if (getFactory().getNumericPromotion().isConvertable(op2)) {
            op2 = getFactory().getNumericPromotion().convertTo(this, op2);
        }
        if (Type.isPrimitive(op1) && isLongIntegerType(op1)) {
            if (Type.isPrimitive(op2) && isIntegerType(op2)) {
                return getGen().primitiveShiftLeft(op1.toPrimitive(), op2.toPrimitive()).getValue();
            } else {
                throw createException("ClassMaker.ShiftOperandMustBeIntegerTypeNot_1", op2.getName());
            }
        } else {
            throw createException("ClassMaker.CannotShiftLeftType_1", op1.getName());
        }
    }

    /**
     * <b>SH</b>ifts <b>R</b>ight the signed value of the first operand by the
     * number of bits indicated by the second operand.
     * </br>
     * The operands are independantly numerically promoted.
     * A shifted result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a >> 3<code></td>
     * <td><code>SHR(Get("a"), Literal(3))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the operand being shifted
     * @param op2
     *            the type of the operand indicating places to shift
     * @return the type of op1 after promotion
     */
    public Value SHR(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        if (isDebugCode()) {
            setDebugComment("SHR(" + op1 + ", " + op2 + ");");
        }
        markLineNumber(); // possibly add a new line number entry.

        // Promote left and right operands independantly.
        if (getFactory().getNumericPromotion().isConvertable(op1)) {
            op1 = getFactory().getNumericPromotion().convertTo(this, op1);
        }
        if (getFactory().getNumericPromotion().isConvertable(op2)) {
            op2 = getFactory().getNumericPromotion().convertTo(this, op2);
        }
        if (Type.isPrimitive(op1) && isLongIntegerType(op1)) {
            if (Type.isPrimitive(op2) && isIntegerType(op2)) {
                return getGen().primitiveShiftRight(op1.toPrimitive(), op2.toPrimitive()).getValue();
            } else {
                throw createException("ClassMaker.ShiftOperandMustBeIntegerTypeNot_1", op2.getName());
            }
        } else {
            throw createException("ClassMaker.CannotShiftRightType_1", op1.getName());
        }
    }

    /**
     * <b>U</b>nsigned <b>SH</b>ifts <b>R</b>ight the value of the first operand
     * by the number of bits indicated by the second operand.
     * </br>
     * The operands are independantly numerically promoted.
     * A shifted result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a >>> 3<code></td>
     * <td><code>USHR(Get("a"), Literal(3))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the operand being shifted
     * @param op2
     *            the type of the operand indicating places to shift
     * @return the type of op1 after promotion
     */
    public Value USHR(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        markLineNumber(); // possibly add a new line number entry.

        // Promote left and right operands independantly.
        if (getFactory().getNumericPromotion().isConvertable(op1)) {
            op1 = getFactory().getNumericPromotion().convertTo(this, op1);
        }
        if (getFactory().getNumericPromotion().isConvertable(op2)) {
            op2 = getFactory().getNumericPromotion().convertTo(this, op2);
        }
        if (Type.isPrimitive(op1) && isLongIntegerType(op1)) {
            if (Type.isPrimitive(op2) && isIntegerType(op2)) {
                return getGen().primitiveUnsignedShiftRight(op1.toPrimitive(), op2.toPrimitive()).getValue();
            } else {
                throw createException("ClassMaker.ShiftOperandMustBeIntegerTypeNot_1", op2.getName());
            }
        } else {
            throw createException("ClassMaker.CannotUnsignedShiftRightType_1", op1.getName());
        }
    }

    //################# Comparison operators ######################
    /**
     * Tests whether the first value is <b>G</b>reater <b>T</b>han the second.
     * </br>
     * The operand are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a > b<code></td>
     * <td><code>GT(Get("a"), Get("b"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the first operand
     * @param op2
     *            the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Value GT(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (op1 == op2 && isNumericType(op1)) {
            return getGen().primitiveGreaterThan(op1, op2);
        } else {
            throw createException("ClassMaker.CannotGTTypes_2", op1.getName(), op2.getName());
        }
    }

    /**
     * Tests whether the first value is <b>G</b>reater than or <B>E</B>qual to
     * the second.
     * </br>
     * The operand are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a >= b<code></td>
     * <td><code>GE(Get("a"), Get("b"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the first operand
     * @param op2
     *            the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Value GE(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (op1 == op2 && isNumericType(op1)) {
            return getGen().primitiveGreaterEqual(op1, op2);
        } else {
            throw createException("ClassMaker.CannotGETypes_2", op1.getName(), op2.getName());
        }
    }

    /**
     * Tests whether the first value is <b>L</b>ess than or <B>E</B>qual to the
     * second.
     * </br>
     * The operand are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a <= b<code></td>
     * <td><code>LE(Get("a"), Get("b"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the first operand
     * @param op2
     *            the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Value LE(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        markLineNumber(); // possibly add a new line number entry.

        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (op1 == op2 && isNumericType(op1)) {
            return getGen().primitiveLessEqual(op1, op2);
        } else {
            throw createException("ClassMaker.CannotLETypes_2", op1.getName(), op2.getName());
        }
    }

    /**
     * Tests whether the first value is <b>L</b>ess <b>T</b>han the second.
     * </br>
     * The operand are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a < b<code></td>
     * <td><code>LT(Get("a"), Get("b"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the first operand
     * @param op2
     *            the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Value LT(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        markLineNumber(); // possibly add a new line number entry.

        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (op1 == op2 && isNumericType(op1)) {
            return getGen().primitiveLessThan(op1, op2);
        } else {
            throw createException("ClassMaker.CannotLTTypes_2", op1.getName(), op2.getName());
        }
    }

    /**
     * Tests whether the two values are <b>Eq</b>ual.
     * </br>
     * The operands are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a == b<code></td>
     * <td><code>EQ(Get("a"), Get("b"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the first operand
     * @param op2
     *            the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Value EQ(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        markLineNumber(); // possibly add a new line number entry.
        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (getFactory().getAssignmentConversion().isConvertable(op1, op2) ||
            getFactory().getAssignmentConversion().isConvertable(op2, op1)) {
            return getGen().primitiveIsEqual(op1, op2);
        } else {
            throw createException("ClassMaker.CannotEQTypes_2", op1.getName(), op2.getName());
        }
    }

    /**
     * Tests whether the two values are <b>N</b>ot <b>E</b>qual.
     * </br>
     * The operands are numerically promoted to the same type and then compared.
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a != b<code></td>
     * <td><code>NE(Get("a"), Get("b"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the first operand
     * @param op2
     *            the type of the second operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Value NE(Value value1, Value value2) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value1.getType();
        Type op2 = value2.getType();
        markLineNumber(); // possibly add a new line number entry.
        if (getFactory().getNumericPromotion().isConvertable(op1, op2)) {
            op1 = op2 = getFactory().getNumericPromotion().convertTo(this, op1, op2);
        }
        if (getFactory().getAssignmentConversion().isConvertable(op1, op2) ||
            getFactory().getAssignmentConversion().isConvertable(op2, op1)) {
            return getGen().primitiveNotEqual(op1, op2);
        } else {
            throw createException("ClassMaker.CannotNETypes_2", op1.getName(), op2.getName());
        }
    }

    /**
     * Negates a boolean value.
     * </br>
     * A boolean result is left on the stack.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code> ! a<code></td>
     * <td><code>Not(Get("a"))</code></td>
     * </tr>
     * </table>
     * 
     * @param op1
     *            the type of the first operand
     * @return the type of the result is always <code>boolean</code>
     */
    public Value Not(Value value) {
        if (isFirstPass()) {
            return null;
        }
        Type op1 = value.getType();
        if (Type.isPrimitive(op1) && op1.toPrimitive().index == PrimitiveType.BOOLEAN_INDEX) {
            markLineNumber(); // possibly add a new line number entry.
            return getGen().primitiveNot(op1);
        } else {
            throw createException("ClassMaker.CannotNotType_1", op1.getName());
        }
    }

    //##################### Arrays ##########################
    /**
     * Checks that the array dimension is of an appropriate type.
     * 
     * @param msg
     *            message describing the dimension of the array
     * @param sizeType
     *            the type of the dimension
     */
    protected void checkArrayDimensionType(String msg, Type sizeType) {
        if (!isIntegerType(sizeType)) {
            throw createException("ClassMaker.MustBeIntegerTypeNot_2", msg, sizeType.getName());
        }
    }

    /**
     * Checks that an array index is of an appropriate type.
     * 
     * @param indexType
     *            the Type of the index to the array
     * @throws ClassMakerException
     *             if the type cannot be used to index the array
     */
    protected void checkArrayIndex(Type indexType) throws ClassMakerException {
        if (!isIntegerType(indexType)) {
            throw createException("ClassMaker.ArrayIndexMustBeIntegerType_1", indexType.getName());
        }
    }

    /**
     * Creates an array using the dimension on the stack.
     * 
     * <pre>
     * Set(&quot;x&quot;, NewArray(ArrayOf(int.class), Literal(5)));
     * </pre>
     * 
     * @param arrayType
     *            the type of array to be created
     * @param sizeType
     *            the type of the dimension
     * @return the type of the new array instance
     */
    public Value NewArray(Type arrayType, Value size) {
        if (isFirstPass()) {
            return null;
        }
        Type sizeType = size.getType();
        if (isDebugCode()) {
            setDebugComment("NewArray(" + arrayType + ", " + size + ");");
        }
        if (!Type.isArray(arrayType)) {
            throw createException("ClassMaker.NotATypeOfArray_1", arrayType.getName());
        }
        checkArrayDimensionType("Array size", sizeType);
        markLineNumber(); // possibly add a new line number entry.
        return getGen().primitiveNewArray(arrayType.toArray(), sizeType);
    }

    /**
     * Creates an multi-dimensional array using the dimensions on the stack.
     * 
     * <pre>
     * Type mint_array = ArrayOf(ArrayOf(ArrayOf(int.class)));
     * Declare(&quot;x&quot;, mint_array, 0);
     * // x = new int[3,2,2];
     * Set(&quot;x&quot;, NewArray(mint_array, Push(Literal(3)).Push(Literal(2)).Push(Literal(2))));
     * </pre>
     * 
     * Note:
     * 
     * @param array
     *            the type of array to be created
     * @param dimensions
     *            the call stack
     * @return an new instance of a multi-dimensional array
     */
    public Value NewArray(Type array, CallStack dimensions) {
        if (isFirstPass()) {
            return null;
        }
        if (!Type.isArray(array))
            throw createException("ClassMaker.NotATypeOfArray_1", array.getName());
        ArrayType arrayType = array.toArray();
        Type[] dims = dimensions.toArray();
        for (int i = 0; i < dims.length; i++) {
            Type sizeType = dims[i];
            checkArrayDimensionType("Type of array dimension " + i, sizeType);
        }
        markLineNumber(); // possibly add a new line number entry.
        return getGen().primitiveNewArray(arrayType, dims);
    }

    /**
     * Finds a type representing an array of the given java class.
     * 
     * <pre>
     * Declare(&quot;intArray&quot;, ArrayOf(int.class), 0);
     * </pre>
     * 
     * @param javaClass
     *            the class of element in the array
     * @return an <code>ArrayType</code> whose elements are of the given class
     */
    public ArrayType ArrayOf(Class javaClass) {
        Type type = getFactory().classToType(javaClass);
        return ArrayOf(type);
    }

    /**
     * Finds a type representing an array of the given java class.
     * 
     * <pre>
     * Declare(&quot;intArray&quot;, ArrayOf(&quot;int&quot;), 0);
     * </pre>
     * 
     * @param typeName
     *            the class name of the element in the array
     * @return an <code>ArrayType</code> whose elements are of the given class
     */
    public ArrayType ArrayOf(String typeName) {
        Type type = stringToType(typeName);
        return ArrayOf(type);
    }

    /**
     * Finds a type representing an array of the given type.
     * 
     * <pre>
     * Declare(&quot;intArray&quot;, ArrayOf(ClassMaker.INT_TYPE), 0);
     * Declare(&quot;processArray&quot;, ArrayOf(getClassType()), 0);
     * </pre>
     * 
     * This method must be used when there is no concrete <code>Class</code> for
     * the array element, for example when declaring an array of
     * the class currently being generated.
     * 
     * @param type
     *            the type of element in the array
     * @return an <code>ArrayType</code> whose elements are of the given type
     */
    public ArrayType ArrayOf(Type type) {
        return getFactory().typeToArray(type);
    }

    /**
     * Gets a value from an array element.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a[0]<code></td>
     * <td><code>GetAt(Get("a"), Literal(0));</code></td>
     * </tr>
     * </table>
     * The <code>indexType</code> must be int, short, char or byte.
     * 
     * @param array
     *            the Value of the array containing the element
     * @param index
     *            the Value of the index into the array
     * @return the type of the value on the stack
     */
    public Value GetAt(Value array, Value index) {
        if (isFirstPass()) {
            return null;
        }
        ArrayType arrayType = array.toArray();
        if (arrayType == null)
            throw createException("ClassMaker.ArrayExpectedOnStack_1", array.getName());
        Type indexType = index.getType();
        checkArrayIndex(indexType);
        markLineNumber(); // possibly add a new line number entry.
        return getGen().getAtIndex(arrayType, indexType);
    }

    /**
     * Assigns an array element to a value and leaves the value on the stack.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>x = a[0] = b;<code></td>
     * <td><code>Set("x", AssignAt(Get("a"), Literal(0), Get("b")));</code></td>
     * </tr>
     * </table>
     * The <code>indexType</code> must be int, short, char or byte.
     * The value is subject to assignment conversion before it is set.
     * 
     * @param arrayType
     *            the type of the array containing the element
     * @param indexType
     *            the type of the index into the array
     * @param valueType
     *            the type of the value to be set
     * @return the type of the value on the stack
     */
    public Value AssignAt(Value array, Value index, Value value) {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("AssignAt(" + array + ", " + index + ", " + value + ");");
        }
        markLineNumber(); // possibly add a new line number entry.

        Type valueType = value.getType();
        // Cannot dupunder two wide types so store value in an anonomous local variable.
        getGen().dup(valueType);
        MakerField anon = storeAnonymousField(valueType);
        SetAt(array, index, valueType.getValue());
        loadAnonymousField(anon);
        return value;
    }

    /**
     * Sets an array element to a value.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a[0] = b;<code></td>
     * <td><code>SetAt(Get("a"), Literal(0), Get("b"));</code></td>
     * </tr>
     * </table>
     * The <code>indexType</code> must be int, short, char or byte.
     * The value is subject to assignment conversion before it is set.
     * 
     * @param arrayType
     *            the type of the array containing the element
     * @param indexType
     *            the type of the index into the array
     * @param value
     *            the type of the value to be set
     * @return a <code>Value</code> representing <code>void</code>
     */
    public Value SetAt(Value array, Value index, Value value) {
        if (isFirstPass()) {
            return null;
        }
        Type refType = array.getType();
        Type indexType = index.getType();
        Type valueType = value.getType();
        if (isDebugCode()) {
            setDebugComment("SetAt(" + refType + ", " + indexType + ", " + valueType + ");");
        }
        ArrayType arrayType = refType.toArray();
        if (arrayType == null)
            throw createException("ClassMaker.ArrayExpectedOnStack_1", refType.getName());
        checkArrayIndex(indexType);
        Type elementType = arrayType.getComponentType();
        if (!getFactory().getAssignmentConversion().isConvertable(valueType, elementType))
            throw createException("ClassMaker.ArrayOfTypeCannotBeAssigned_2", elementType.getName(),
                    valueType.getName());
        markLineNumber(); // possibly add a new line number entry.

        getFactory().getAssignmentConversion().convertTo(this, valueType, elementType);

        return getGen().setAtIndex(arrayType, indexType, elementType);
    }

    /**
     * Gets the length of the array on top of the stack.
     * 
     * <pre>
     * Eval(Set(&quot;len&quot;, Length(Get(&quot;anArray&quot;))));
     * </pre>
     * 
     * @param array
     *            the Type of the array
     * @return the length of the array
     */
    public Value Length(Value array) {
        if (isFirstPass()) {
            return null;
        }
        ArrayType arrayType = array.toArray();
        if (arrayType == null)
            throw createException("ClassMaker.ArrayExpectedOnStack_1", array.getName());
        markLineNumber(); // possibly add a new line number entry.
        if (isDebugCode())
            setDebugComment("Length(" + array + ");");
        return getGen().arrayLength(arrayType);
    }

    /**
     * Evaluate an expression as though it were a statement.
     * </br>
     * An <code>Eval</code> should surround each expression that is used like a
     * statement.
     * Expressions leave their results on the top of the program stack. Calling
     * <code>Eval</code> discards the result of the expression by popping it off
     * the stack.
     * Expressions that have no result, such as method calls that return
     * <code>void</code>,
     * are ignored.
     * 
     * <pre>
     * Eval(Dec(&quot;a&quot;));
     * </pre>
     * 
     * @param type
     *            the result Type of the expression
     */
    public void Eval(Value value) {
        if (isFirstPass()) {
            return;
        }
        Type type = value.getType();
        if (!ClassMakerFactory.VOID_TYPE.equals(type)) {
            if (isDebugCode())
                setDebugComment("Eval(" + type + ")");
            getGen().pop(type);
        }
    }

    //############# Increment & Decrement operators ###############

    /**** Inc ****/

    /**
     * Gets the value of a local variable after incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>++i;<code></td>
     * <td><code>Inc("i")</code></td>
     * </tr>
     * </table>
     * 
     * @param name
     *            the name of the member variable
     * @return the value of the variable after it is incremented
     */
    public Value Inc(String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("Inc(" + name + ")");
        }
        markLineNumber(); // possibly add a new line number entry.

        MakerField local = Find(name);
        ClassGenerator gen = getGen();
        if (!gen.incrementLocal(local, 1)) {
            throw createException("ClassMaker.CannotIncrementVariableOfType_2", 
                    local.getName(), local.getType().getName());
        }
        return gen.loadLocal(local);
    }

    /**
     * Gets the value of a member variable after incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>++obj.i;<code></td>
     * <td><code>Inc(Get("obj"), "i")</code></td>
     * </tr>
     * </table>
     * 
     * @param type
     *            the type of the class containing the variable
     * @param name
     *            the name of the member variable
     * @return the value of the variable after it is incremented
     */
    public Value Inc(Value reference, String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("Inc(" + reference + ", " + name + ")");
        }
        MakerField field = Find(reference, name);
        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        ClassType classType = field.getClassType();

        // GET myclass.id
        ClassGenerator gen = getGen();
        gen.dup(classType);
        gen.loadField(field);

        if (!gen.increment(fieldType, 1)) {
            throw createException("ClassMaker.CannotIncrementFieldOfType_2", name, fieldType.getName());
        }
        gen.dupunder(thisClassType, fieldType);

        gen.storeField(field);

        return fieldType.getValue();
    }

    /**
     * Gets the value of a static member variable after incrementing it.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>++MyClass.i;<code></td>
     * <td><code>Inc("MyClass", "i")</code></td>
     * </tr>
     * </table>
     * 
     * @param className
     *            the short or fully qualified name of the class
     * @param name
     *            the name of the static member variable
     * @return the value of the variable after it is incremented
     */
    public Value Inc(String className, String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode())
            setDebugComment("Inc(\"" + className + "\", " + name + ")");
        MakerField field = Find(className, name);

        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();

        // GET myclass.id
        ClassGenerator gen = getGen();
        gen.loadStatic(field);

        if (!gen.increment(fieldType, 1))
            throw createException("ClassMaker.CannotIncrementFieldOfType_2", fieldName, fieldType.getName());
        gen.dup(fieldType);

        gen.storeStatic(field);

        return fieldType.getValue();
    }

    /**** Dec ****/

    /**
     * Gets the value of a local variable after decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>--i;<code></td>
     * <td><code>Dec("i")</code></td>
     * </tr>
     * </table>
     * 
     * @param name
     *            the name of the member variable
     * @return the value of the variable after it is decremented
     */
    public Value Dec(String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("Dec(" + name + ")");
        }
        markLineNumber(); // possibly add a new line number entry.

        ClassGenerator gen = getGen();
        MakerField local = Find(name);
        if (!gen.incrementLocal(local, -1)) {
            throw createException("ClassMaker.CannotDecrementVariableOfType_2", 
                    local.getName(), local.getType().getName());
        }
        return gen.loadLocal(local);
    }

    /**
     * Gets the value of a member variable after decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>--obj.i;<code></td>
     * <td><code>Dec(Get("obj"), "i")</code></td>
     * </tr>
     * </table>
     * 
     * @param type
     *            the type of the class containing the variable
     * @param name
     *            the name of the member variable
     * @return the value of the variable after it is decremented
     */
    public Value Dec(Value reference, String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode())
            setDebugComment("Dec(" + reference + ", " + name + ")");
        MakerField field = Find(reference, name);

        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();
        ClassType classType = field.getClassType();

        // GET myclass.id
        ClassGenerator gen = getGen();
        gen.dup(classType);
        gen.loadField(field);

        if (!gen.increment(fieldType, -1))
            throw createException("ClassMaker.CannotDecrementFieldOfType_2", fieldName, fieldType.getName());
        gen.dupunder(classType, fieldType);

        // PUT myclass.id
        gen.storeField(field);

        return fieldType.getValue();
    }

    /**
     * Gets the value of a static member variable after decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>--MyClass.i;<code></td>
     * <td><code>Dec("MyClass", "i")</code></td>
     * </tr>
     * </table>
     * 
     * @param className
     *            the short or fully qualified name of the class
     * @param name
     *            the name of the static member variable
     * @return the value of the variable after it is decremented
     */
    public Value Dec(String className, String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode())
            setDebugComment("Dec(\"" + className + "\", " + name + ")");
        MakerField field = Find(className, name);

        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();

        markLineNumber(); // possibly add a new line number entry.
        // GET myclass.id
        ClassGenerator gen = getGen();
        gen.loadStatic(field);

        if (!gen.increment(fieldType, -1))
            throw createException("ClassMaker.CannotDecrementFieldOfType_2", fieldName, fieldType.getName());
        gen.dup(fieldType);

        gen.storeStatic(field);

        return fieldType.getValue();
    }

    /**** PostInc ****/

    /**
     * Gets the value of a local variable before incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>i++;<code></td>
     * <td><code>PostInc("i")</code></td>
     * </tr>
     * </table>
     * 
     * @param name
     *            the name of the member variable
     * @return the value of the variable before it is incremented
     */
    public Value PostInc(String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("PostInc(" + name + ")");
        }
        markLineNumber(); // possibly add a new line number entry.

        MakerField local = Find(name);
        ClassGenerator gen = getGen();
        Value value = gen.loadLocal(local);
        if (!gen.incrementLocal(local, 1)) {
            throw createException("ClassMaker.CannotIncrementVariableOfType_2", 
                    local.getName(), local.getType().getName());
        }
        return value;
    }

    /**
     * Gets the value of a member variable before incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>obj.i++;<code></td>
     * <td><code>PostInc(Get("obj"), "i")</code></td>
     * </tr>
     * </table>
     * 
     * @param type
     *            the type of the class containing the variable
     * @param name
     *            the name of the member variable
     * @return the value of the variable before it is incremented
     */
    public Value PostInc(Value reference, String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("PostInc(" + reference + ", " + name + ")");
        }
        MakerField field = Find(reference, name);

        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();
        ClassType classType = field.getClassType();

        ClassGenerator gen = getGen();
        gen.dup(classType);
        gen.loadField(field);

        gen.dupunder(classType, fieldType);
        if (!gen.increment(fieldType, 1)) {
            throw createException("ClassMaker.CannotIncrementFieldOfType_2", fieldName, fieldType.getName());
        }
        // PUT myclass.id
        gen.storeField(field);

        return fieldType.getValue();
    }

    /**
     * Gets the value of a static member variable before incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>MyClass.i++;<code></td>
     * <td><code>PostInc("MyClass", "i")</code></td>
     * </tr>
     * </table>
     * 
     * @param className
     *            the short or fully qualified name of the class
     * @param name
     *            the name of the static member variable
     * @return the value of the variable before it is incremented
     */
    public Value PostInc(String className, String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode())
            setDebugComment("PostInc(\"" + className + "\", " + name + ")");
        MakerField field = Find(className, name);

        markLineNumber(); // possibly add a new line number entry.
        Type fieldType = field.getType();
        String fieldName = field.getName();

        markLineNumber(); // possibly add a new line number entry.
        // GET myclass.id
        ClassGenerator gen = getGen();
        gen.loadStatic(field);

        gen.dup(fieldType);
        if (!gen.increment(fieldType, 1)) {
            throw createException("ClassMaker.CannotIncrementFieldOfType_2", fieldName, fieldType.getName());
        }
        gen.storeStatic(field);

        return fieldType.getValue();
    }

    /**** PostDec ****/

    /**
     * Gets the value of a local variable before decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>i--;<code></td>
     * <td><code>PostDec("i")</code></td>
     * </tr>
     * </table>
     * 
     * @param name
     *            the name of the member variable
     * @return the value of the variable before it is decremented
     */
    public Value PostDec(String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode()) {
            setDebugComment("PostDec(" + name + ")");
        }
        markLineNumber(); // possibly add a new line number entry.

        MakerField local = Find(name);
        Value value = getGen().loadLocal(local);
        if (!getGen().incrementLocal(local, -1))
            throw createException("ClassMaker.CannotDecrementVariableOfType_2", local.getName(), local.getType()
                    .getName());
        return value;
    }

    /**
     * Gets the value of a member variable before decrementing it.
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>obj.i--;<code></td>
     * <td><code>PostDec(Get("obj"), "i")</code></td>
     * </tr>
     * </table>
     * 
     * @param type
     *            the type of the class containing the variable
     * @param name
     *            the name of the member variable
     * @return the value of the variable before if is decremented
     */
    public Value PostDec(Value reference, String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode())
            setDebugComment("PostDec(" + reference + ", " + name + ")");
        MakerField field = Find(reference, name);

        Type fieldType = field.getType();
        String fieldName = field.getName();
        ClassType classType = field.getClassType();

        markLineNumber(); // possibly add a new line number entry.
        // GET myclass.id
        ClassGenerator gen = getGen();
        gen.dup(classType);
        gen.loadField(field);

        gen.dupunder(classType, fieldType);
        if (!gen.increment(fieldType, -1))
            throw createException("ClassMaker.CannotDecrementFieldOfType_2", fieldName, fieldType.getName());

        // PUT myclass.id
        gen.storeField(field);

        return fieldType.getValue();
    }

    /**
     * Gets the value of a static member variable before decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>MyClass.i--;<code></td>
     * <td><code>PostDec("MyClass", "i")</code></td>
     * </tr>
     * </table>
     * 
     * @param className
     *            the short or fully qualified name of the class
     * @param name
     *            the name of the static member variable
     * @return the value of the variable before if is decremented
     */
    public Value PostDec(String className, String name) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        if (isDebugCode())
            setDebugComment("PostDec(\"" + className + "\", " + name + ")");
        MakerField field = Find(className, name);

        Type fieldType = field.getType();
        String fieldName = field.getName();

        markLineNumber(); // possibly add a new line number entry.
        // GET myclass.id
        ClassGenerator gen = getGen();
        gen.loadStatic(field);

        gen.dup(fieldType);
        if (!gen.increment(fieldType, -1)) {
            throw createException("ClassMaker.CannotDecrementFieldOfType_2", fieldName, fieldType.getName());
        }
        gen.storeStatic(field);

        return fieldType.getValue();
    }

    /**** IncAt ****/

    /**
     * Gets the value of an array element after incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>a = ++values[2];<code></td>
     * <td><code>Set("a", IncAt(Get("values"), Literal(2)));</code></td>
     * </tr>
     * </table>
     * 
     * @param array
     *            the type of the array
     * @param index
     *            the type of the index
     * @return the value of the array element after it is incremented
     */
    public Value IncAt(Value array, Value index) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        ArrayType arrayType = array.toArray();
        Type indexType = index.getType();
        if (arrayType == null)
            throw createException("ClassMaker.NotATypeOfArray_1", array.getName());
        Type elementType = arrayType.getComponentType();
        if (!isIntegerType(indexType)) {
            throw createException("ClassMaker.ArrayIndexMustBeIntegerType_1", index.getName());
        }
        markLineNumber(); // possibly add a new line number entry.
        if (incrementAtIndex(arrayType, indexType, elementType, 1)) {
            return elementType.getValue();
        } else {
            throw createException("ClassMaker.CannotIncrementArrayElementOfType_1", elementType.getName());
        }
    }

    protected boolean incrementAtIndex(ArrayType arrayType, Type indexType, Type elementType, int amount) {
        markLineNumber(); // possibly add a new line number entry.
        ClassGenerator gen = getGen();
        //# Stack contents
        //# array index
        gen.swap(arrayType, indexType);
        //# index array
        gen.dupunder(indexType, arrayType);
        //# array index array
        gen.swap(indexType, arrayType);
        //# array array index
        gen.dupunder(arrayType, indexType);
        //# array index array index
        gen.getAtIndex(arrayType, indexType);
        //# array index value
        if (!gen.increment(elementType, amount)) {
            return false;
        }
        //# array index value+1
        gen.dup(elementType);
        //# array index value+1 value+1
        MakerField anon = storeAnonymousField(elementType);
        //# array index value+1
        gen.setAtIndex(arrayType, indexType, elementType);
        //# -
        loadAnonymousField(anon);
        //# value+1

        return true;
    }

    /**
     * Gets the value of an array element after decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>--obj.i;<code></td>
     * <td><code>Dec(Get("obj"), "i")</code></td>
     * </tr>
     * </table>
     * 
     * @param array
     *            the type of the array
     * @param index
     *            the type of the index
     * @return the value of the array element after it is decremented
     */
    public Value DecAt(Value array, Value index) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        markLineNumber(); // possibly add a new line number entry.
        ArrayType arrayType = array.toArray();
        Type indexType = index.getType();
        if (arrayType == null)
            throw createException("ClassMaker.NotATypeOfArray_1", array.getName());
        Type elementType = arrayType.getComponentType();
        if (!isIntegerType(indexType)) {
            throw createException("ClassMaker.ArrayIndexMustBeIntegerType_1", index.getName());
        }
        if (incrementAtIndex(arrayType, indexType, elementType, -1)) {
            return elementType.getValue();
        } else {
            throw createException("ClassMaker.CannotDecrementArrayElementOfType_1", elementType.getName());
        }
    }

    /**
     * Gets the value of an array element before incrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>obj.i++;<code></td>
     * <td><code>PostInc(Get("obj"), "i")</code></td>
     * </tr>
     * </table>
     * 
     * @param array
     *            the type of the array
     * @param index
     *            the type of the index
     * @return the value of the array element before it is incremented
     */
    public Value PostIncAt(Value array, Value index) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        ArrayType arrayType = array.toArray();
        Type indexType = index.getType();
        if (arrayType == null)
            throw createException("ClassMaker.NotATypeOfArray_1", array.getName());
        Type elementType = arrayType.getComponentType();
        if (!isIntegerType(indexType)) {
            throw createException("ClassMaker.ArrayIndexMustBeIntegerType_1", index.getName());
        }
        if (postIncrementAtIndex(arrayType, indexType, elementType, 1)) {
            return elementType.getValue();
        } else {
            throw createException("ClassMaker.CannotIncrementArrayElementOfType_1", elementType.getName());
        }
    }

    boolean postIncrementAtIndex(ArrayType arrayType, Type indexType, Type elementType, int amount) {
        markLineNumber(); // possibly add a new line number entry.
        ClassGenerator gen = getGen();
        //# Stack contents
        //# array index
        gen.swap(arrayType, indexType);
        //# index array
        gen.dupunder(indexType, arrayType);
        //# array index array
        gen.swap(indexType, arrayType);
        //# array array index
        gen.dupunder(arrayType, indexType);
        //# array index array index
        gen.getAtIndex(arrayType, indexType);
        //# array index value
        gen.dup(elementType);
        //# array index value value
        MakerField anon = storeAnonymousField(elementType);
        //# array index value
        if (!gen.increment(elementType, amount)) {
            return false;
        }
        //# array index value+1
        gen.setAtIndex(arrayType, indexType, elementType);
        //# -
        loadAnonymousField(anon);
        //# value

        return true;
    }

    /**
     * Gets the value of an array element before decrementing it.
     * </br>
     * The following code is equivalent.
     * <table border="1" width="100%">
     * <tr>
     * <td>Java code</td>
     * <td>ClassMaker code</td>
     * </tr>
     * <tr>
     * <td><code>obj.i--;<code></td>
     * <td><code>PostDec(Get("obj"), "i")</code></td>
     * </tr>
     * </table>
     * 
     * @param array
     *            the type of the array
     * @param index
     *            the type of the index
     * @return the value of the array element before if is decremented
     */
    public Value PostDecAt(Value array, Value index) throws ClassMakerException {
        if (isFirstPass()) {
            return null;
        }
        ArrayType arrayType = array.toArray();
        Type indexType = index.getType();
        if (arrayType == null)
            throw createException("ClassMaker.NotATypeOfArray_1", array.getName());
        Type elementType = arrayType.getComponentType();
        if (!isIntegerType(indexType)) {
            throw createException("ClassMaker.ArrayIndexMustBeIntegerType_1", index.getName());
        }
        if (postIncrementAtIndex(arrayType, indexType, elementType, -1)) {
            return elementType.getValue();
        } else {
            throw createException("ClassMaker.CannotDecrementArrayElementOfType_1", elementType.getName());
        }
    }

    //################# Statement Management ###################
    
    private final StatementManager statementManager = createStatementManager();

    public StatementManager getStatementManager() {
        return statementManager;
    }

    protected StatementManager createStatementManager() {
        return new StatementManager(this);
    }

    // ##################  If Then Else EndIf  ###################
    /**
     * Begins an <code>If</code> statement.
     * The subsequent code block is executed if the <code>condition</code>
     * evaluates to <code>true</code>.
     * 
     * <pre>
     * If(LT(Get(&quot;a&quot;), Literal(0)));
     * Set(&quot;a&quot;, Literal(0));
     * EndIf();
     * </pre>
     *
     * Delegates to <code>IfStatement.If</code>.
     * 
     * @return an interface to set a Label
     */
    public Labelled If(Value condition) throws ClassMakerException {
        IfStatement stmt = statementManager.createIfStatement();
        stmt.If(condition);
        return stmt;
    }

    /**
     * Begins an <code>Else</code> clause of an <code>If</code> statement.
     * The subsequent code block is executed if the <code>condition</code> in
     * the <code>If</code> clause evaluated to <code>false</code>.
     * 
     * <pre>
     * If(LT(Get(&quot;a&quot;), Literal(0)));
     * Set(&quot;a&quot;, Literal(0));
     * Else();
     * Set(&quot;a&quot;, Literal(1));
     * EndIf();
     * </pre>
     *
     * Delegates to <code>IfStatement.Else</code>.
     */
    public void Else() throws ClassMakerException {
        IfStatement stmt = statementManager.topIfStatement("ClassMaker.ElseWithoutMatchingIf");
        stmt.Else();
    }

    /**
     * Ends an <ocde>If</code> Statement.
     * Control jumps to here if the preceeding code block is not executed.
     *
     * Delegates to <code>IfStatement.Else</code>.
     */
    public void EndIf() throws ClassMakerException {
        IfStatement stmt = statementManager.topIfStatement("ClassMaker.EndIfWithoutMatchingIf");
        stmt.EndIf();
        stmt.dispose(statementManager);

        followsReturn = true;
    }

    // #######################  Loop Statement ######################
    /**
     * Begins a <code>Loop</code> statement.
     * Control will jump here from the <code>EndLoop</code> clause or from
     * an enclosed <code>Continue</code> statement.
     * The loop will not terminate unless there is an enclosed statement that
     * breaks out of the loop, for example, <code>While</code> or
     * <code>Break</code>.
     * 
     * <pre>
     * Loop();
     * If(LE(Get(&quot;n&quot;), Literal(0)));
     * Break();
     * EndIf();
     * Eval(Set(&quot;x&quot;, Mult(Get(&quot;x&quot;), Get(&quot;n&quot;))));
     * Eval(Dec(&quot;n&quot;));
     * EndLoop();
     * </pre>
     * 
     * Delegates to <code>LoopStatement.Loop</code>.
     * 
     * @return an interface to set a Label
     */
    public Labelled Loop() throws ClassMakerException {
        LoopStatement stmt = statementManager.createLoopStatement();
        stmt.Loop();
        return stmt;
    }

    /**
     * Ends a <code>Loop</code> statement.
     * Jumps to the <code>BeginLoop</code> clause.
     *
     * A <code>Break</code> or <code>While</code> will jump to the end of this
     * clause;
     * thus terminating the loop.
     * Delegates to <code>LoopStatement.EndLoop</code>.
     */
    public void EndLoop() throws ClassMakerException {
        LoopStatement stmt = statementManager.topLoopStatement("ClassMaker.EndLoopWithoutMatchingLoop");
        stmt.EndLoop();
        stmt.dispose(statementManager);

        followsReturn = false;
    }

    /**
     * Iterates through a <code>Loop</code> while the condition is
     * <code>true</code> Breaks out of the enclosing <code>Loop</code> when the
     * condition is <code>false</code>.
     * The <code>While</code> clause should be the first or last in a loop;
     * however, this is not enforced.
     * 
     * <pre>
     * Loop();
     * While(GT(Get(&quot;n&quot;), Literal(0)));
     * Eval(Set(&quot;x&quot;, Mult(Get(&quot;x&quot;), Get(&quot;n&quot;))));
     * Eval(Dec(&quot;n&quot;));
     * EndLoop();
     * </pre>
     * 
     * Delegates to <code>LoopStatement.While</code>.
     * 
     * @param condition
     *            the type of the condition expression must be boolean
     */
    public void While(Value condition) throws ClassMakerException {
        LoopStatement stmt = statementManager.topLoopStatement("ClassMaker.WhileMustBeWithinLoop");
        stmt.While(condition.getType());
    }

    /**
     * Start of a <code>For</code> loop.
     * </br>
     * Iterates through a <code>For</code> loop while the condition is
     * <code>true</code> and evaluates the step expression each time.
     * Used in a daisy chain like this.
     * 
     * <pre>
     *    For( <expression> ).While( <condition> ).Step( <increment> );
     * </pre>
     * 
     * Breaks out of the enclosing <code>For</code> loop when the condition is
     * <code>false</code>.
     * 
     * <pre>
     *           Declare("n", int.class)
     *           For(Set("n", 5)).While(LE(Get("n"), Literal(0))).Step(Dec("n"));
     *             Set("x", Mult(Get("x"), Get("n")));
     *           EndFor();
     * </pre>
     * 
     * Delegates to <code>LoopStatement.For</code>.
     * 
     * @param declare
     *            the type of the initialization expression
     */
    public ForWhile For(Value declare) throws ClassMakerException {
        ForStatement stmt = statementManager.createForStatement();
        stmt.For(declare);
        stmt.Loop();
        return stmt;
    }

    /**
     * Ends a <code>Loop</code> statement.
     * </br>
     * Jumps to the <code>BeginLoop</code> clause.
     * A <code>Break</code> or <code>While</code> will jump to the end of this
     * clause;
     * thus terminating the loop.
     * Delegates to <code>LoopStatement.EndLoop</code>.
     */
    public void EndFor() throws ClassMakerException {
        ForStatement stmt = statementManager.topForStatement("ClassMaker.EndForWithoutMatchingFor");
        stmt.EndLoop();
        stmt.dispose(statementManager);

        followsReturn = false;
    }

    /**
     * Breaks to the end of the nearest enclosing <code>Loop</code> or
     * <code>Switch</code> statement.
     */
    public void Break() throws ClassMakerException {
        Break(null);
    }

    /**
     * Breaks to the end of the enclosing statement with the given label.
     * 
     * <pre>
     * Loop().setLabel(&quot;LOOP&quot;);
     * Switch(Get(&quot;x&quot;));
     * {
     *     Case(0);
     *     Set(&quot;y&quot;, Literal(1));
     *     Break();
     *     Case(1);
     *     Set(&quot;y&quot;, Literal(2));
     *     Break();
     *     Default();
     *     Set(&quot;y&quot;, Literal(0));
     *     Break(&quot;LOOP&quot;);
     * }
     * EndSwitch();
     * Inc(&quot;x&quot;);
     * EndLoop();
     * </pre>
     */
    public void Break(String label) throws ClassMakerException {
        if (isFirstPass()) {
            return;
        }
        if (isDebugCode())
            setDebugComment("Break(" + (label == null ? "" : label) + ")");
        Statement stmt = statementManager.topStatement();
        markLineNumber(); // possibly add a new line number entry.
        if (stmt.jumpToTarget(BREAK, label) == null) {
            if (label == null)
                throw createException("ClassMaker.BreakWhileNotInLoopOrSwitch");
            else
                throw createException("ClassMaker.CouldNotFindTargetLabelForBreak_1", label);
        }

    }

    /** Continues the nearest enclosing <code>Loop<code> statement. */
    public void Continue() throws ClassMakerException {
        Continue(null);
    }

    /**
     * Continues the enclosing <code>Loop<code> statement with the given label.
     * 
     * @param label
     *            the label of the <code>Loop<code> statement
     */
    public void Continue(String label) throws ClassMakerException {
        if (isFirstPass()) {
            return;
        }
        if (isDebugCode()) {
            setDebugComment("Continue(" + (label == null ? "" : label) + ")");
        }
        Statement stmt = statementManager.topStatement();
        markLineNumber(); // possibly add a new line number entry.
        if (stmt.jumpToTarget(CONTINUE, label) == null) {
            throw createException("ClassMaker.ContinueWhileNotInLoop");
        }
    }

    // #######################  Switch Statement ######################
    /**
     * Begins a <code>Switch</code> statement.
     * 
     * <pre>
     * Switch(Get(&quot;x&quot;));
     * {
     *     Case(0);
     *     Set(&quot;y&quot;, Literal(1));
     *     Break();
     *     Case(2);
     *     Set(&quot;y&quot;, Literal(2));
     *     Break();
     *     Case(4);
     *     Set(&quot;y&quot;, Literal(3));
     *     Break();
     *     Default();
     *     Set(&quot;y&quot;, Literal(0));
     *     Break();
     * }
     * EndSwitch();
     * </pre>
     * 
     * The switchType must be an <code>int</code> after numeric promotion.
     * Delegates to <code>SwitchStatement.Switch</code>.
     * 
     * @param switchType
     *            the type of the selector for the switch
     * @return an interface to set a Label
     */
    public Labelled Switch(Value value) {
        SwitchStatement stmt = statementManager.createSwitchStatement();
        stmt.Switch(value.getType());
        return stmt;
    }

    /**
     * Adds a <code>Case</code> clause of a <code>Switch</code> statement.
     * </br>
     * The switch statement will jump here if the switch value matches the given
     * key.
     * Delegates to <code>SwitchStatement.Case</code>.
     * 
     * @param key
     *            the selector which will cause the switch statement to jump to
     *            this case
     */
    public void Case(int key) {
        SwitchStatement stmt = statementManager.topSwitchStatement("ClassMaker.CaseWhileNotInSwitch");
        stmt.Case(key);
    }

    /**
     * Adds a <code>Default</code> clause of a <code>Switch</code> statement.
     * </br>
     * The switch statement will jump here if none of the other cases apply.
     * Delegates to <code>SwitchStatement.DefaultCase</code>.
     */
    public void Default() {
        SwitchStatement stmt = statementManager.topSwitchStatement("ClassMaker.DefaultWhileNotInSwitch");
        stmt.Default();
    }

    /**
     * Ends a <code>Switch</code> statement.
     * </br>
     * Delegates to <code>SwitchStatement.EndSwitch</code>.
     */
    public void EndSwitch() {
        SwitchStatement stmt = statementManager.topSwitchStatement("ClassMaker.EndSwitchWhileNotInSwitch");
        stmt.EndSwitch();
        stmt.dispose(statementManager);

        followsReturn = false;
    }

    // #######################  Try/Catch/Finally Statement ######################
    /**
     * Begins a <code>Try Catch Finally</code> block.
     * </br>
     * Begins a block of code where exceptions that are thrown
     * may be caught be the subseqent <code>Catch</code> clauses.
     * 
     * <pre>
     * Try();
     * {
     *     If(LT(Get(&quot;x&quot;), Literal(0)));
     *     Throw(New(FileNotFoundException.class).Init(Push()));
     *     EndIf();
     * }
     * Catch(FileNotFoundException.class, &quot;ex1&quot;);
     * {
     *     Set(&quot;x&quot;, Literal(10000));
     * }
     * Finally();
     * {
     *     Inc(&quot;x&quot;);
     * }
     * EndTry();
     * </pre>
     * 
     * Delegates to <code>TryCatchFinally.Try</code>.
     * 
     * @return an interface to set a Label
     */
    public Labelled Try() {
        TryCatchFinally stmt = statementManager.createTryCatchFinally();
        stmt.Try();
        return stmt;
    }

    /**
     * Catches the Exception and stores it in a the named local variable.
     * </br>
     * Catches the given Exception and stores it in a local variable with the
     * given name.
     * Also marks the begining of a block of code to handle the exception.
     * Delegates to <code>TryCatchFinally.Catch</code>.
     * 
     * @param exceptionName
     *            the name of the type of exception handled by this block of
     *            code
     * @param name
     *            the local variable name for the exception
     */
    public void Catch(String exceptionName, String name) {
        TryCatchFinally stmt = statementManager.topTryCatchFinally("ClassMaker.CatchWithoutTry");
        ClassType exceptionType = stringToClassType(exceptionName);
        stmt.Catch(exceptionType, name);
    }

    /**
     * Catches the Exception represented by the java Class.
     * </br>
     * Catches the given Exception type and stores it in a local variable with
     * the given name.
     * Also marks the begining of a block of code to handle the exception.
     * Delegates to <code>TryCatchFinally.Catch</code>.
     * 
     * @param javaClass
     *            the <code>Class</code> of the exception to catch
     * @param name
     *            the local variable name to which to assign the exception
     */
    public void Catch(Class javaClass, String name) throws ClassMakerException {
        ClassType exceptionType = classToClassType(javaClass);
        TryCatchFinally stmt = statementManager.topTryCatchFinally("ClassMaker.CatchWithoutTry");
        stmt.Catch(exceptionType, name);
    }

    /**
     * Starts a Finally block.
     * </br>
     * Begins a block of code that will always be executed.
     * The code in the block will be called:
     * <LU> <LI>at the end of the <code>Try</code> block</LI> <LI>at the end of
     * each <code>Catch</code> block</LI> <LI>when <code>Return</code> is called
     * </LI> <LI>when <code>Break</code> or <code>Continue</code> is called</LI>
     * <LI>when an exception is thrown</LI> </LU>
     * Delegates to <code>TryCatchFinally.Finally()</code>.
     */
    public void Finally() throws ClassMakerException {
        TryCatchFinally stmt = statementManager.topTryCatchFinally("ClassMaker.FinallyWithoutTry");
        stmt.Finally();
    }

    /**
     * Ends a <code>Try Catch Finally</code> block.
     * </br>
     * Delegates to <code>TryCatchFinally.EndTry()</code>.
     */
    public void EndTry() throws ClassMakerException {
        TryCatchFinally stmt = statementManager.topTryCatchFinally("ClassMaker.EndTryWithoutTry");
        stmt.EndTry();
        stmt.dispose(statementManager);

        followsReturn = false;
    }

    // Nameless local variables for storing intermediate values.

    /**
     * Stores a value in a nameless local variable.
     * </br>
     * The value may be retrieved using the slot offset.
     * The type determines how may slots are reserved.
     * 
     * @param type
     *            type of value being stored.
     */
    protected MakerField storeAnonymousField(Type type) throws ClassMakerException {
        MakerField local = getLocalFields().addLocalField(null, type, 0, getScopeLevel(), getProgramCounter());
        getGen().storeLocal(local);
        return local;
    }

    /**
     * Loads a value from a nameless local variable.
     * 
     * @param index
     *            the index of the anonymous field holding the value
     * @return type of the value being loaded
     */
    protected Value loadAnonymousField(MakerField local) throws ClassMakerException {
        return getGen().loadLocal(local);
    }

    // Shortcut Logic expressions

    /**
     * Represents a logical And or logical Or expression.
     * </br>
     * Holds the jump addresses for an expression that includes shortcut AND
     * and shortcut OR logic.
     */
    public static class AndOrExpression {
        public AndOrExpression prev = null;
        /** jump address for AND logic */
        public int jumpAnd = 0;
        /** jump address for OR logic */
        public int jumpOr = 0;
    };

    /**
     * Contains an expression that includes shortcut AND and OR logic.
     * </br>
     * If the preceeding <code>andOr</code> expression is shortcut then
     * evaluation of the <code>cond</code> expression will be jumped over.
     * <pr/>
     * The following code generates bytecode for <code>a && b || c</code>. <br/>
     * 
     * <pre>
     * Logic(OrElse(AndThen(Get(&quot;a&quot;)), Get(&quot;b&quot;)), Get(&quot;c&quot;))
     * </pre>
     * 
     * This method creates a label for the shortcut expression to jump to.
     * 
     * @param andOr
     *            preceeding logical expression
     * @param cond
     *            last conditional expression
     * @return return type is always boolean
     */
    public Value Logic(AndOrExpression andOr, Value cond) {
        if (isFirstPass()) {
            return null;
        }
        if (!ClassMakerFactory.BOOLEAN_TYPE.equals(cond.getType()))
            throw createException("ClassMaker.LogicConditionMustBeBoolean_1", cond.getName());

        getGen().markAndThenLabel(andOr);
        getGen().markOrElseLabel(andOr);

        return cond;
    }

    /**
     * Appends a <code>cond &&</code> logic expression to a preceeding
     * expression.
     * </br>
     * If the preceeding <code>andOr</code> expression evaluates to true the
     * <code>cond</code> will be evaluated.
     * If the preceeding <code>andOr</code> expression evaluates to false then
     * evaluation of the <code>cond</code> expression will be jumped over.
     * <pr/>
     * The following code generates bytecode for <code>a && b && c</code>. <br/>
     * 
     * <pre>
     * Logic(AndThen(AndThen(Get(&quot;a&quot;)), Get(&quot;b&quot;)), Get(&quot;c&quot;))
     * </pre>
     * 
     * @param previous
     *            preceeding logical expression
     * @param cond
     *            next conditional expression
     * @return logic expression including shortcut logic
     */
    public AndOrExpression AndThen(AndOrExpression previous, Value cond) {
        if (isFirstPass()) {
            return null;
        }
        if (!ClassMakerFactory.BOOLEAN_TYPE.equals(cond.getType())) {
            throw createException("ClassMaker.AndThenConditionMustBeBoolean_1", cond.getName());
        }
        // handle change from && to || operator
        getGen().markOrElseLabel(previous);

        AndOrExpression andOr = new AndOrExpression();
        andOr.prev = previous; // Chain similar shortcut operators
        // Jump to the same label as the previous AndThen expression, if available.
        andOr.jumpAnd = (previous == null || previous.jumpAnd == 0) ? getGen().acquireLabel() : previous.jumpAnd;
        if (isDebugCode()) {
            setDebugComment("&& Jump if false on stack");
        }
        getGen().jumpIfEqualZero(andOr.jumpAnd); // Jump over other expression if cond is false.
        markLineNumber(); // possibly add a new line number entry.

        return andOr;
    }

    /**
     * Creates a <code>cond &&</code> logic expression.
     * </br>
     * If the <code>cond</code> expression evaluates to true the
     * following logic expression will be evaluated.
     * If the <code>cond</code> expression evaluates to false then
     * evaluation of the following expression will be jumped over.
     * <pr/>
     * The following code generates bytecode for <code>a && b</code>. <br/>
     * 
     * <pre>
     * Logic(AndThen(Get(&quot;a&quot;)), Get(&quot;b&quot;))
     * </pre>
     * 
     * @param cond
     *            next conditional expression
     * @return logic expression including shortcut logic
     */
    public AndOrExpression AndThen(Value cond) {
        return AndThen(null, cond);
    }

    /**
     * Appends a <code>cond ||</code> logic expression to a preceeding
     * expression.
     * </br>
     * If the preceeding <code>andOr</code> expression evaluates to false the
     * <code>cond</code> will be evaluated.
     * If the preceeding <code>andOr</code> expression evaluates to true then
     * evaluation of the <code>cond</code> expression will be jumped over.
     * <pr/>
     * The following code generates bytecode for <code>a || b || c</code>. <br/>
     * 
     * <pre>
     * Logic(OrElse(OrElse(Get(&quot;a&quot;)), Get(&quot;b&quot;)), Get(&quot;c&quot;))
     * </pre>
     * 
     * @param andOr
     *            preceeding logical expression
     * @param cond
     *            next conditional expression
     * @return logic expression including shortcut logic
     */
    public AndOrExpression OrElse(AndOrExpression previous, Value cond) {
        if (isFirstPass()) {
            return null;
        }
        if (!ClassMakerFactory.BOOLEAN_TYPE.equals(cond.getType())) {
            throw createException("ClassMaker.OrElseConditionMustBeBoolean_1", cond.getName());
        }
        // handle change from && to || operator
        getGen().markAndThenLabel(previous);

        AndOrExpression andOr = new AndOrExpression();
        andOr.prev = previous; // Chain similar shortcut operators
        // Jump to the same label as the previous OrElse expression, if available.
        andOr.jumpOr = (previous == null || previous.jumpOr == 0) ? getGen().acquireLabel() : previous.jumpOr;

        if (isDebugCode()) {
            setDebugComment("|| Jump if true on stack");
        }
        getGen().jumpIfNotEqualZero(andOr.jumpOr); // Jump over other expression if cond is true.

        markLineNumber(); // possibly add a new line number entry.

        return andOr;
    }

    /**
     * Creates a <code>cond ||</code> logic expression.
     * </br>
     * If the <code>cond</code> expression evaluates to false the
     * following logic expression will be evaluated.
     * If the <code>cond</code> expression evaluates to true then
     * evaluation of the following expression will be jumped over.
     * <pr/>
     * The following code generates bytecode for <code>a || b</code>. <br/>
     * 
     * <pre>
     * Logic(OrElse(Get(&quot;a&quot;)), Get(&quot;b&quot;))
     * </pre>
     * 
     * @param cond
     *            next conditional expression
     * @return logic expression including shortcut logic
     */
    public AndOrExpression OrElse(Value cond) {
        return OrElse(null, cond);
    }

    /**
     * Creates an exception with a variable number of parameters to the error message.
     * </br>
     * The resource bundle is <code>ExceptionMessages.properties</code>.
     * 
     * @param key the key to lookup in the resource bundle
     * @param values a variable list of values to be substituted into the error message
     * @return a formatted ClassMakerException
     */
    public ClassMakerException createException(String key, String ... values) {
        ExceptionFactory factory = getFactory().getExceptionFactory();
        return factory.createException(getSourceLine(), key, values);
    }

    private void assertNotNull(Object obj, String name) {
        if (obj == null) {
            throw new IllegalArgumentException(name + " cannot be null");
        }
    }

    /**
     * Get the <code>LineNumber</code> provider. <br/>
     * The <code>LineNumber</code> interface provides the source file name and
     * current line number for
     * debugging and error messages.
     * 
     * @return <code>LineNumber</code> provider
     */
    public SourceLine getSourceLine() {
        if (sourceLine == null)
            setSourceFilename(defaultSourceFilename());
        return sourceLine;
    }

    public void setSourceLine(SourceLine source) {
        this.sourceLine = source;
    }

    /**
     * Remembers the current line number. <br/>
     * Call this method whenever the line number changes in the input file.
     * The line number may be used by <code>markLineNumber</code> to generate a
     * line number entry in the generated class file.
     *
     * @param lineNumber
     *            current line number
     */
    public void setLineNumber(int sourceLineNumber) {
        this.sourceLineNumber = sourceLineNumber;
    }
    
    public int getLineNumber() {
        return sourceLineNumber;
    }

    public String getFilename() {
        return sourceFilename;
    }

    public void setFilename(String filename) {
        sourceFilename = filename;
    }

    /**
     * Adds a line number entry to the generated class, if appropriate. <br/>
     * Called by methods that generate byte codes. A line number entry will
     * be added to the method being generated if the line number has changed
     * since the last time this method was called.
     */
    protected void markLineNumber() {
        if (getGen() != null) {
            int lineNumber = getSourceLine().getLineNumber();
            getGen().markLineNumber(lineNumber);
        }
        // For convenience we reset the followsReturn flag
        // because almost every method calls this method.
        checkInMethod();
        followsReturn = false;
    }

    /**
     * Saves the class to the given output folder. <br/>
     * The class will be placed in the appropriate path corresponding to the
     * package name.
     * 
     * @param classesDir
     *            the base folder for output classes
     * @throws IOException
     *             if the class file cannot be created
     * @return a File referring to the saved class file
     */
    public File saveClass(File classesDir) throws IOException {
        if (!classesDir.exists()) {
            throw createException("ClassMaker.OutputFolderDoesNotExist_1", classesDir.getName());
        }
        EndClass();
        return getGen().saveClass(classesDir);
    }

    /**
     * Deletes the class from the given output folder. <br/>
     * The class will be deleted from the appropriate path corresponding to the
     * package and class name.
     * 
     * @param classesDir the base directory for output classes
     * @throws IOException if the class file cannot be created
     */
    public void deleteClass(File classesDir) throws IOException {
        if (!classesDir.exists()) {
            throw createException("ClassMaker.OutputFolderDoesNotExist_1", classesDir.getName());
        }
        String className = MakerUtil.toSlashName(getFullyQualifiedClassName()) + ".class";
        File classFile = new File(classesDir, className);
        if (classFile.exists()) {
            if (!classFile.delete())
                throw new IOException("Could not delete: " + classFile.getAbsolutePath());
        }
    }

    public String toString() {
        StringBuffer buf = new StringBuffer();
        buf.append("ClassMaker(");
        if (fullyQualifiedClassName != null) {
            buf.append(fullyQualifiedClassName).append(' ');
        } else {
            if (packageName != null)
                buf.append(packageName).append('.');
            if (simpleClassName != null)
                buf.append(simpleClassName).append(' ');
            else
                buf.append("? ");
        }
        if (getExtendsType() != null) {
            buf.append("extends ").append(getExtendsType().getName());
        }
        if (factory != null) {
            switch (getPass()) {
            case ONE_PASS:
                buf.append(", ONE_PASS");
                break;
            case FIRST_PASS:
                buf.append(", FIRST_PASS");
                break;
            case SECOND_PASS:
                buf.append(", SECOND_PASS");
                break;
            case COMPLETED_PASS:
                buf.append(", COMPLETED_PASS");
                break;
            }
        }
        if (sourceLine != null)
            buf.append(", ").append(sourceLine.getFilename()).append(":").append(sourceLine.getLineNumber());
        buf.append(')');
        return buf.toString();
    }
}
